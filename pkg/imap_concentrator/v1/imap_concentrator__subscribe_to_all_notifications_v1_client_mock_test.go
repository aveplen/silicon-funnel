package imap_concentrator

// Code generated by http://github.com/gojuno/minimock (3.0.10). DO NOT EDIT.

//go:generate minimock -i github.com/aveplen/silicon-funnel/pkg/imap_concentrator/v1.ImapConcentrator_SubscribeToAllNotificationsV1Client -o ./imap_concentrator__subscribe_to_all_notifications_v1_client_mock_test.go -n ImapConcentrator_SubscribeToAllNotificationsV1ClientMock

import (
	context "context"
	sync "sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"google.golang.org/grpc/metadata"
)

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMock implements ImapConcentrator_SubscribeToAllNotificationsV1Client
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMock struct {
	t minimock.Tester

	funcCloseSend          func() (err error)
	inspectFuncCloseSend   func()
	afterCloseSendCounter  uint64
	beforeCloseSendCounter uint64
	CloseSendMock          mImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSend

	funcContext          func() (c1 context.Context)
	inspectFuncContext   func()
	afterContextCounter  uint64
	beforeContextCounter uint64
	ContextMock          mImapConcentrator_SubscribeToAllNotificationsV1ClientMockContext

	funcHeader          func() (m1 metadata.MD, err error)
	inspectFuncHeader   func()
	afterHeaderCounter  uint64
	beforeHeaderCounter uint64
	HeaderMock          mImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeader

	funcRecv          func() (np1 *NotificationV1, err error)
	inspectFuncRecv   func()
	afterRecvCounter  uint64
	beforeRecvCounter uint64
	RecvMock          mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecv

	funcRecvMsg          func(m interface{}) (err error)
	inspectFuncRecvMsg   func(m interface{})
	afterRecvMsgCounter  uint64
	beforeRecvMsgCounter uint64
	RecvMsgMock          mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsg

	funcSendMsg          func(m interface{}) (err error)
	inspectFuncSendMsg   func(m interface{})
	afterSendMsgCounter  uint64
	beforeSendMsgCounter uint64
	SendMsgMock          mImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsg

	funcTrailer          func() (m1 metadata.MD)
	inspectFuncTrailer   func()
	afterTrailerCounter  uint64
	beforeTrailerCounter uint64
	TrailerMock          mImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailer
}

// NewImapConcentrator_SubscribeToAllNotificationsV1ClientMock returns a mock for ImapConcentrator_SubscribeToAllNotificationsV1Client
func NewImapConcentrator_SubscribeToAllNotificationsV1ClientMock(t minimock.Tester) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	m := &ImapConcentrator_SubscribeToAllNotificationsV1ClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CloseSendMock = mImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSend{mock: m}

	m.ContextMock = mImapConcentrator_SubscribeToAllNotificationsV1ClientMockContext{mock: m}

	m.HeaderMock = mImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeader{mock: m}

	m.RecvMock = mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecv{mock: m}

	m.RecvMsgMock = mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsg{mock: m}
	m.RecvMsgMock.callArgs = []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgParams{}

	m.SendMsgMock = mImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsg{mock: m}
	m.SendMsgMock.callArgs = []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgParams{}

	m.TrailerMock = mImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailer{mock: m}

	return m
}

type mImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSend struct {
	mock               *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock
	defaultExpectation *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSendExpectation
	expectations       []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSendExpectation
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSendExpectation specifies expectation struct of the ImapConcentrator_SubscribeToAllNotificationsV1Client.CloseSend
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSendExpectation struct {
	mock *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock

	results *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSendResults
	Counter uint64
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSendResults contains results of the ImapConcentrator_SubscribeToAllNotificationsV1Client.CloseSend
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSendResults struct {
	err error
}

// Expect sets up expected params for ImapConcentrator_SubscribeToAllNotificationsV1Client.CloseSend
func (mmCloseSend *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSend) Expect() *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSend {
	if mmCloseSend.mock.funcCloseSend != nil {
		mmCloseSend.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.CloseSend mock is already set by Set")
	}

	if mmCloseSend.defaultExpectation == nil {
		mmCloseSend.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSendExpectation{}
	}

	return mmCloseSend
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToAllNotificationsV1Client.CloseSend
func (mmCloseSend *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSend) Inspect(f func()) *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSend {
	if mmCloseSend.mock.inspectFuncCloseSend != nil {
		mmCloseSend.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.CloseSend")
	}

	mmCloseSend.mock.inspectFuncCloseSend = f

	return mmCloseSend
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToAllNotificationsV1Client.CloseSend
func (mmCloseSend *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSend) Return(err error) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmCloseSend.mock.funcCloseSend != nil {
		mmCloseSend.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.CloseSend mock is already set by Set")
	}

	if mmCloseSend.defaultExpectation == nil {
		mmCloseSend.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSendExpectation{mock: mmCloseSend.mock}
	}
	mmCloseSend.defaultExpectation.results = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSendResults{err}
	return mmCloseSend.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToAllNotificationsV1Client.CloseSend method
func (mmCloseSend *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockCloseSend) Set(f func() (err error)) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmCloseSend.defaultExpectation != nil {
		mmCloseSend.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.CloseSend method")
	}

	if len(mmCloseSend.expectations) > 0 {
		mmCloseSend.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.CloseSend method")
	}

	mmCloseSend.mock.funcCloseSend = f
	return mmCloseSend.mock
}

// CloseSend implements ImapConcentrator_SubscribeToAllNotificationsV1Client
func (mmCloseSend *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) CloseSend() (err error) {
	mm_atomic.AddUint64(&mmCloseSend.beforeCloseSendCounter, 1)
	defer mm_atomic.AddUint64(&mmCloseSend.afterCloseSendCounter, 1)

	if mmCloseSend.inspectFuncCloseSend != nil {
		mmCloseSend.inspectFuncCloseSend()
	}

	if mmCloseSend.CloseSendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCloseSend.CloseSendMock.defaultExpectation.Counter, 1)

		mm_results := mmCloseSend.CloseSendMock.defaultExpectation.results
		if mm_results == nil {
			mmCloseSend.t.Fatal("No results are set for the ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.CloseSend")
		}
		return (*mm_results).err
	}
	if mmCloseSend.funcCloseSend != nil {
		return mmCloseSend.funcCloseSend()
	}
	mmCloseSend.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.CloseSend.")
	return
}

// CloseSendAfterCounter returns a count of finished ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.CloseSend invocations
func (mmCloseSend *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) CloseSendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseSend.afterCloseSendCounter)
}

// CloseSendBeforeCounter returns a count of ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.CloseSend invocations
func (mmCloseSend *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) CloseSendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCloseSend.beforeCloseSendCounter)
}

// MinimockCloseSendDone returns true if the count of the CloseSend invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockCloseSendDone() bool {
	for _, e := range m.CloseSendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseSendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseSendCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseSend != nil && mm_atomic.LoadUint64(&m.afterCloseSendCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseSendInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockCloseSendInspect() {
	for _, e := range m.CloseSendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.CloseSend")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseSendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseSendCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.CloseSend")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCloseSend != nil && mm_atomic.LoadUint64(&m.afterCloseSendCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.CloseSend")
	}
}

type mImapConcentrator_SubscribeToAllNotificationsV1ClientMockContext struct {
	mock               *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock
	defaultExpectation *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockContextExpectation
	expectations       []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockContextExpectation
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockContextExpectation specifies expectation struct of the ImapConcentrator_SubscribeToAllNotificationsV1Client.Context
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockContextExpectation struct {
	mock *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock

	results *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockContextResults
	Counter uint64
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockContextResults contains results of the ImapConcentrator_SubscribeToAllNotificationsV1Client.Context
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockContextResults struct {
	c1 context.Context
}

// Expect sets up expected params for ImapConcentrator_SubscribeToAllNotificationsV1Client.Context
func (mmContext *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockContext) Expect() *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockContext {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Context mock is already set by Set")
	}

	if mmContext.defaultExpectation == nil {
		mmContext.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockContextExpectation{}
	}

	return mmContext
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToAllNotificationsV1Client.Context
func (mmContext *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockContext) Inspect(f func()) *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockContext {
	if mmContext.mock.inspectFuncContext != nil {
		mmContext.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Context")
	}

	mmContext.mock.inspectFuncContext = f

	return mmContext
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToAllNotificationsV1Client.Context
func (mmContext *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockContext) Return(c1 context.Context) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Context mock is already set by Set")
	}

	if mmContext.defaultExpectation == nil {
		mmContext.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockContextExpectation{mock: mmContext.mock}
	}
	mmContext.defaultExpectation.results = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockContextResults{c1}
	return mmContext.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToAllNotificationsV1Client.Context method
func (mmContext *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockContext) Set(f func() (c1 context.Context)) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmContext.defaultExpectation != nil {
		mmContext.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.Context method")
	}

	if len(mmContext.expectations) > 0 {
		mmContext.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.Context method")
	}

	mmContext.mock.funcContext = f
	return mmContext.mock
}

// Context implements ImapConcentrator_SubscribeToAllNotificationsV1Client
func (mmContext *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) Context() (c1 context.Context) {
	mm_atomic.AddUint64(&mmContext.beforeContextCounter, 1)
	defer mm_atomic.AddUint64(&mmContext.afterContextCounter, 1)

	if mmContext.inspectFuncContext != nil {
		mmContext.inspectFuncContext()
	}

	if mmContext.ContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContext.ContextMock.defaultExpectation.Counter, 1)

		mm_results := mmContext.ContextMock.defaultExpectation.results
		if mm_results == nil {
			mmContext.t.Fatal("No results are set for the ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Context")
		}
		return (*mm_results).c1
	}
	if mmContext.funcContext != nil {
		return mmContext.funcContext()
	}
	mmContext.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Context.")
	return
}

// ContextAfterCounter returns a count of finished ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Context invocations
func (mmContext *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) ContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContext.afterContextCounter)
}

// ContextBeforeCounter returns a count of ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Context invocations
func (mmContext *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) ContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContext.beforeContextCounter)
}

// MinimockContextDone returns true if the count of the Context invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockContextDone() bool {
	for _, e := range m.ContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContext != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockContextInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockContextInspect() {
	for _, e := range m.ContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Context")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Context")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContext != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Context")
	}
}

type mImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeader struct {
	mock               *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock
	defaultExpectation *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeaderExpectation
	expectations       []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeaderExpectation
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeaderExpectation specifies expectation struct of the ImapConcentrator_SubscribeToAllNotificationsV1Client.Header
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeaderExpectation struct {
	mock *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock

	results *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeaderResults
	Counter uint64
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeaderResults contains results of the ImapConcentrator_SubscribeToAllNotificationsV1Client.Header
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeaderResults struct {
	m1  metadata.MD
	err error
}

// Expect sets up expected params for ImapConcentrator_SubscribeToAllNotificationsV1Client.Header
func (mmHeader *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeader) Expect() *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeader {
	if mmHeader.mock.funcHeader != nil {
		mmHeader.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Header mock is already set by Set")
	}

	if mmHeader.defaultExpectation == nil {
		mmHeader.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeaderExpectation{}
	}

	return mmHeader
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToAllNotificationsV1Client.Header
func (mmHeader *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeader) Inspect(f func()) *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeader {
	if mmHeader.mock.inspectFuncHeader != nil {
		mmHeader.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Header")
	}

	mmHeader.mock.inspectFuncHeader = f

	return mmHeader
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToAllNotificationsV1Client.Header
func (mmHeader *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeader) Return(m1 metadata.MD, err error) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmHeader.mock.funcHeader != nil {
		mmHeader.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Header mock is already set by Set")
	}

	if mmHeader.defaultExpectation == nil {
		mmHeader.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeaderExpectation{mock: mmHeader.mock}
	}
	mmHeader.defaultExpectation.results = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeaderResults{m1, err}
	return mmHeader.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToAllNotificationsV1Client.Header method
func (mmHeader *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockHeader) Set(f func() (m1 metadata.MD, err error)) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmHeader.defaultExpectation != nil {
		mmHeader.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.Header method")
	}

	if len(mmHeader.expectations) > 0 {
		mmHeader.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.Header method")
	}

	mmHeader.mock.funcHeader = f
	return mmHeader.mock
}

// Header implements ImapConcentrator_SubscribeToAllNotificationsV1Client
func (mmHeader *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) Header() (m1 metadata.MD, err error) {
	mm_atomic.AddUint64(&mmHeader.beforeHeaderCounter, 1)
	defer mm_atomic.AddUint64(&mmHeader.afterHeaderCounter, 1)

	if mmHeader.inspectFuncHeader != nil {
		mmHeader.inspectFuncHeader()
	}

	if mmHeader.HeaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHeader.HeaderMock.defaultExpectation.Counter, 1)

		mm_results := mmHeader.HeaderMock.defaultExpectation.results
		if mm_results == nil {
			mmHeader.t.Fatal("No results are set for the ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Header")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmHeader.funcHeader != nil {
		return mmHeader.funcHeader()
	}
	mmHeader.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Header.")
	return
}

// HeaderAfterCounter returns a count of finished ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Header invocations
func (mmHeader *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) HeaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHeader.afterHeaderCounter)
}

// HeaderBeforeCounter returns a count of ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Header invocations
func (mmHeader *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) HeaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHeader.beforeHeaderCounter)
}

// MinimockHeaderDone returns true if the count of the Header invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockHeaderDone() bool {
	for _, e := range m.HeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHeaderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHeader != nil && mm_atomic.LoadUint64(&m.afterHeaderCounter) < 1 {
		return false
	}
	return true
}

// MinimockHeaderInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockHeaderInspect() {
	for _, e := range m.HeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Header")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHeaderCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Header")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHeader != nil && mm_atomic.LoadUint64(&m.afterHeaderCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Header")
	}
}

type mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecv struct {
	mock               *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock
	defaultExpectation *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvExpectation
	expectations       []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvExpectation
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvExpectation specifies expectation struct of the ImapConcentrator_SubscribeToAllNotificationsV1Client.Recv
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvExpectation struct {
	mock *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock

	results *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvResults
	Counter uint64
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvResults contains results of the ImapConcentrator_SubscribeToAllNotificationsV1Client.Recv
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvResults struct {
	np1 *NotificationV1
	err error
}

// Expect sets up expected params for ImapConcentrator_SubscribeToAllNotificationsV1Client.Recv
func (mmRecv *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecv) Expect() *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecv {
	if mmRecv.mock.funcRecv != nil {
		mmRecv.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Recv mock is already set by Set")
	}

	if mmRecv.defaultExpectation == nil {
		mmRecv.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvExpectation{}
	}

	return mmRecv
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToAllNotificationsV1Client.Recv
func (mmRecv *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecv) Inspect(f func()) *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecv {
	if mmRecv.mock.inspectFuncRecv != nil {
		mmRecv.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Recv")
	}

	mmRecv.mock.inspectFuncRecv = f

	return mmRecv
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToAllNotificationsV1Client.Recv
func (mmRecv *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecv) Return(np1 *NotificationV1, err error) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmRecv.mock.funcRecv != nil {
		mmRecv.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Recv mock is already set by Set")
	}

	if mmRecv.defaultExpectation == nil {
		mmRecv.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvExpectation{mock: mmRecv.mock}
	}
	mmRecv.defaultExpectation.results = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvResults{np1, err}
	return mmRecv.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToAllNotificationsV1Client.Recv method
func (mmRecv *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecv) Set(f func() (np1 *NotificationV1, err error)) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmRecv.defaultExpectation != nil {
		mmRecv.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.Recv method")
	}

	if len(mmRecv.expectations) > 0 {
		mmRecv.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.Recv method")
	}

	mmRecv.mock.funcRecv = f
	return mmRecv.mock
}

// Recv implements ImapConcentrator_SubscribeToAllNotificationsV1Client
func (mmRecv *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) Recv() (np1 *NotificationV1, err error) {
	mm_atomic.AddUint64(&mmRecv.beforeRecvCounter, 1)
	defer mm_atomic.AddUint64(&mmRecv.afterRecvCounter, 1)

	if mmRecv.inspectFuncRecv != nil {
		mmRecv.inspectFuncRecv()
	}

	if mmRecv.RecvMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecv.RecvMock.defaultExpectation.Counter, 1)

		mm_results := mmRecv.RecvMock.defaultExpectation.results
		if mm_results == nil {
			mmRecv.t.Fatal("No results are set for the ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Recv")
		}
		return (*mm_results).np1, (*mm_results).err
	}
	if mmRecv.funcRecv != nil {
		return mmRecv.funcRecv()
	}
	mmRecv.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Recv.")
	return
}

// RecvAfterCounter returns a count of finished ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Recv invocations
func (mmRecv *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) RecvAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecv.afterRecvCounter)
}

// RecvBeforeCounter returns a count of ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Recv invocations
func (mmRecv *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) RecvBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecv.beforeRecvCounter)
}

// MinimockRecvDone returns true if the count of the Recv invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockRecvDone() bool {
	for _, e := range m.RecvMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecvMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecvCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecv != nil && mm_atomic.LoadUint64(&m.afterRecvCounter) < 1 {
		return false
	}
	return true
}

// MinimockRecvInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockRecvInspect() {
	for _, e := range m.RecvMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Recv")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecvMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecvCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Recv")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecv != nil && mm_atomic.LoadUint64(&m.afterRecvCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Recv")
	}
}

type mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsg struct {
	mock               *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock
	defaultExpectation *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgExpectation
	expectations       []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgExpectation

	callArgs []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgParams
	mutex    sync.RWMutex
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgExpectation specifies expectation struct of the ImapConcentrator_SubscribeToAllNotificationsV1Client.RecvMsg
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgExpectation struct {
	mock    *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock
	params  *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgParams
	results *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgResults
	Counter uint64
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgParams contains parameters of the ImapConcentrator_SubscribeToAllNotificationsV1Client.RecvMsg
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgParams struct {
	m interface{}
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgResults contains results of the ImapConcentrator_SubscribeToAllNotificationsV1Client.RecvMsg
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgResults struct {
	err error
}

// Expect sets up expected params for ImapConcentrator_SubscribeToAllNotificationsV1Client.RecvMsg
func (mmRecvMsg *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsg) Expect(m interface{}) *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsg {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg mock is already set by Set")
	}

	if mmRecvMsg.defaultExpectation == nil {
		mmRecvMsg.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgExpectation{}
	}

	mmRecvMsg.defaultExpectation.params = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgParams{m}
	for _, e := range mmRecvMsg.expectations {
		if minimock.Equal(e.params, mmRecvMsg.defaultExpectation.params) {
			mmRecvMsg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRecvMsg.defaultExpectation.params)
		}
	}

	return mmRecvMsg
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToAllNotificationsV1Client.RecvMsg
func (mmRecvMsg *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsg) Inspect(f func(m interface{})) *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsg {
	if mmRecvMsg.mock.inspectFuncRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg")
	}

	mmRecvMsg.mock.inspectFuncRecvMsg = f

	return mmRecvMsg
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToAllNotificationsV1Client.RecvMsg
func (mmRecvMsg *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsg) Return(err error) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg mock is already set by Set")
	}

	if mmRecvMsg.defaultExpectation == nil {
		mmRecvMsg.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgExpectation{mock: mmRecvMsg.mock}
	}
	mmRecvMsg.defaultExpectation.results = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgResults{err}
	return mmRecvMsg.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToAllNotificationsV1Client.RecvMsg method
func (mmRecvMsg *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsg) Set(f func(m interface{}) (err error)) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmRecvMsg.defaultExpectation != nil {
		mmRecvMsg.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.RecvMsg method")
	}

	if len(mmRecvMsg.expectations) > 0 {
		mmRecvMsg.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.RecvMsg method")
	}

	mmRecvMsg.mock.funcRecvMsg = f
	return mmRecvMsg.mock
}

// When sets expectation for the ImapConcentrator_SubscribeToAllNotificationsV1Client.RecvMsg which will trigger the result defined by the following
// Then helper
func (mmRecvMsg *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsg) When(m interface{}) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgExpectation {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg mock is already set by Set")
	}

	expectation := &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgExpectation{
		mock:   mmRecvMsg.mock,
		params: &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgParams{m},
	}
	mmRecvMsg.expectations = append(mmRecvMsg.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentrator_SubscribeToAllNotificationsV1Client.RecvMsg return parameters for the expectation previously defined by the When method
func (e *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgExpectation) Then(err error) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	e.results = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgResults{err}
	return e.mock
}

// RecvMsg implements ImapConcentrator_SubscribeToAllNotificationsV1Client
func (mmRecvMsg *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) RecvMsg(m interface{}) (err error) {
	mm_atomic.AddUint64(&mmRecvMsg.beforeRecvMsgCounter, 1)
	defer mm_atomic.AddUint64(&mmRecvMsg.afterRecvMsgCounter, 1)

	if mmRecvMsg.inspectFuncRecvMsg != nil {
		mmRecvMsg.inspectFuncRecvMsg(m)
	}

	mm_params := &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgParams{m}

	// Record call args
	mmRecvMsg.RecvMsgMock.mutex.Lock()
	mmRecvMsg.RecvMsgMock.callArgs = append(mmRecvMsg.RecvMsgMock.callArgs, mm_params)
	mmRecvMsg.RecvMsgMock.mutex.Unlock()

	for _, e := range mmRecvMsg.RecvMsgMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRecvMsg.RecvMsgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecvMsg.RecvMsgMock.defaultExpectation.Counter, 1)
		mm_want := mmRecvMsg.RecvMsgMock.defaultExpectation.params
		mm_got := ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgParams{m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRecvMsg.t.Errorf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRecvMsg.RecvMsgMock.defaultExpectation.results
		if mm_results == nil {
			mmRecvMsg.t.Fatal("No results are set for the ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg")
		}
		return (*mm_results).err
	}
	if mmRecvMsg.funcRecvMsg != nil {
		return mmRecvMsg.funcRecvMsg(m)
	}
	mmRecvMsg.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg. %v", m)
	return
}

// RecvMsgAfterCounter returns a count of finished ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg invocations
func (mmRecvMsg *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) RecvMsgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecvMsg.afterRecvMsgCounter)
}

// RecvMsgBeforeCounter returns a count of ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg invocations
func (mmRecvMsg *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) RecvMsgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecvMsg.beforeRecvMsgCounter)
}

// Calls returns a list of arguments used in each call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRecvMsg *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsg) Calls() []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgParams {
	mmRecvMsg.mutex.RLock()

	argCopy := make([]*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockRecvMsgParams, len(mmRecvMsg.callArgs))
	copy(argCopy, mmRecvMsg.callArgs)

	mmRecvMsg.mutex.RUnlock()

	return argCopy
}

// MinimockRecvMsgDone returns true if the count of the RecvMsg invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockRecvMsgDone() bool {
	for _, e := range m.RecvMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecvMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecvMsg != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		return false
	}
	return true
}

// MinimockRecvMsgInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockRecvMsgInspect() {
	for _, e := range m.RecvMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecvMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		if m.RecvMsgMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg")
		} else {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg with params: %#v", *m.RecvMsgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecvMsg != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.RecvMsg")
	}
}

type mImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsg struct {
	mock               *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock
	defaultExpectation *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgExpectation
	expectations       []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgExpectation

	callArgs []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgParams
	mutex    sync.RWMutex
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgExpectation specifies expectation struct of the ImapConcentrator_SubscribeToAllNotificationsV1Client.SendMsg
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgExpectation struct {
	mock    *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock
	params  *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgParams
	results *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgResults
	Counter uint64
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgParams contains parameters of the ImapConcentrator_SubscribeToAllNotificationsV1Client.SendMsg
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgParams struct {
	m interface{}
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgResults contains results of the ImapConcentrator_SubscribeToAllNotificationsV1Client.SendMsg
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgResults struct {
	err error
}

// Expect sets up expected params for ImapConcentrator_SubscribeToAllNotificationsV1Client.SendMsg
func (mmSendMsg *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsg) Expect(m interface{}) *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsg {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgExpectation{}
	}

	mmSendMsg.defaultExpectation.params = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgParams{m}
	for _, e := range mmSendMsg.expectations {
		if minimock.Equal(e.params, mmSendMsg.defaultExpectation.params) {
			mmSendMsg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMsg.defaultExpectation.params)
		}
	}

	return mmSendMsg
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToAllNotificationsV1Client.SendMsg
func (mmSendMsg *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsg) Inspect(f func(m interface{})) *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsg {
	if mmSendMsg.mock.inspectFuncSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg")
	}

	mmSendMsg.mock.inspectFuncSendMsg = f

	return mmSendMsg
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToAllNotificationsV1Client.SendMsg
func (mmSendMsg *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsg) Return(err error) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgExpectation{mock: mmSendMsg.mock}
	}
	mmSendMsg.defaultExpectation.results = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgResults{err}
	return mmSendMsg.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToAllNotificationsV1Client.SendMsg method
func (mmSendMsg *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsg) Set(f func(m interface{}) (err error)) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmSendMsg.defaultExpectation != nil {
		mmSendMsg.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.SendMsg method")
	}

	if len(mmSendMsg.expectations) > 0 {
		mmSendMsg.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.SendMsg method")
	}

	mmSendMsg.mock.funcSendMsg = f
	return mmSendMsg.mock
}

// When sets expectation for the ImapConcentrator_SubscribeToAllNotificationsV1Client.SendMsg which will trigger the result defined by the following
// Then helper
func (mmSendMsg *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsg) When(m interface{}) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgExpectation {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg mock is already set by Set")
	}

	expectation := &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgExpectation{
		mock:   mmSendMsg.mock,
		params: &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgParams{m},
	}
	mmSendMsg.expectations = append(mmSendMsg.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentrator_SubscribeToAllNotificationsV1Client.SendMsg return parameters for the expectation previously defined by the When method
func (e *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgExpectation) Then(err error) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	e.results = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgResults{err}
	return e.mock
}

// SendMsg implements ImapConcentrator_SubscribeToAllNotificationsV1Client
func (mmSendMsg *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) SendMsg(m interface{}) (err error) {
	mm_atomic.AddUint64(&mmSendMsg.beforeSendMsgCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMsg.afterSendMsgCounter, 1)

	if mmSendMsg.inspectFuncSendMsg != nil {
		mmSendMsg.inspectFuncSendMsg(m)
	}

	mm_params := &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgParams{m}

	// Record call args
	mmSendMsg.SendMsgMock.mutex.Lock()
	mmSendMsg.SendMsgMock.callArgs = append(mmSendMsg.SendMsgMock.callArgs, mm_params)
	mmSendMsg.SendMsgMock.mutex.Unlock()

	for _, e := range mmSendMsg.SendMsgMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMsg.SendMsgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMsg.SendMsgMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMsg.SendMsgMock.defaultExpectation.params
		mm_got := ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgParams{m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMsg.t.Errorf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMsg.SendMsgMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMsg.t.Fatal("No results are set for the ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg")
		}
		return (*mm_results).err
	}
	if mmSendMsg.funcSendMsg != nil {
		return mmSendMsg.funcSendMsg(m)
	}
	mmSendMsg.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg. %v", m)
	return
}

// SendMsgAfterCounter returns a count of finished ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg invocations
func (mmSendMsg *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) SendMsgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMsg.afterSendMsgCounter)
}

// SendMsgBeforeCounter returns a count of ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg invocations
func (mmSendMsg *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) SendMsgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMsg.beforeSendMsgCounter)
}

// Calls returns a list of arguments used in each call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMsg *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsg) Calls() []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgParams {
	mmSendMsg.mutex.RLock()

	argCopy := make([]*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockSendMsgParams, len(mmSendMsg.callArgs))
	copy(argCopy, mmSendMsg.callArgs)

	mmSendMsg.mutex.RUnlock()

	return argCopy
}

// MinimockSendMsgDone returns true if the count of the SendMsg invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockSendMsgDone() bool {
	for _, e := range m.SendMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMsg != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMsgInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockSendMsgInspect() {
	for _, e := range m.SendMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		if m.SendMsgMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg")
		} else {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg with params: %#v", *m.SendMsgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMsg != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.SendMsg")
	}
}

type mImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailer struct {
	mock               *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock
	defaultExpectation *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailerExpectation
	expectations       []*ImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailerExpectation
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailerExpectation specifies expectation struct of the ImapConcentrator_SubscribeToAllNotificationsV1Client.Trailer
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailerExpectation struct {
	mock *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock

	results *ImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailerResults
	Counter uint64
}

// ImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailerResults contains results of the ImapConcentrator_SubscribeToAllNotificationsV1Client.Trailer
type ImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailerResults struct {
	m1 metadata.MD
}

// Expect sets up expected params for ImapConcentrator_SubscribeToAllNotificationsV1Client.Trailer
func (mmTrailer *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailer) Expect() *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailer {
	if mmTrailer.mock.funcTrailer != nil {
		mmTrailer.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Trailer mock is already set by Set")
	}

	if mmTrailer.defaultExpectation == nil {
		mmTrailer.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailerExpectation{}
	}

	return mmTrailer
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToAllNotificationsV1Client.Trailer
func (mmTrailer *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailer) Inspect(f func()) *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailer {
	if mmTrailer.mock.inspectFuncTrailer != nil {
		mmTrailer.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Trailer")
	}

	mmTrailer.mock.inspectFuncTrailer = f

	return mmTrailer
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToAllNotificationsV1Client.Trailer
func (mmTrailer *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailer) Return(m1 metadata.MD) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmTrailer.mock.funcTrailer != nil {
		mmTrailer.mock.t.Fatalf("ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Trailer mock is already set by Set")
	}

	if mmTrailer.defaultExpectation == nil {
		mmTrailer.defaultExpectation = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailerExpectation{mock: mmTrailer.mock}
	}
	mmTrailer.defaultExpectation.results = &ImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailerResults{m1}
	return mmTrailer.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToAllNotificationsV1Client.Trailer method
func (mmTrailer *mImapConcentrator_SubscribeToAllNotificationsV1ClientMockTrailer) Set(f func() (m1 metadata.MD)) *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock {
	if mmTrailer.defaultExpectation != nil {
		mmTrailer.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.Trailer method")
	}

	if len(mmTrailer.expectations) > 0 {
		mmTrailer.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToAllNotificationsV1Client.Trailer method")
	}

	mmTrailer.mock.funcTrailer = f
	return mmTrailer.mock
}

// Trailer implements ImapConcentrator_SubscribeToAllNotificationsV1Client
func (mmTrailer *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) Trailer() (m1 metadata.MD) {
	mm_atomic.AddUint64(&mmTrailer.beforeTrailerCounter, 1)
	defer mm_atomic.AddUint64(&mmTrailer.afterTrailerCounter, 1)

	if mmTrailer.inspectFuncTrailer != nil {
		mmTrailer.inspectFuncTrailer()
	}

	if mmTrailer.TrailerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTrailer.TrailerMock.defaultExpectation.Counter, 1)

		mm_results := mmTrailer.TrailerMock.defaultExpectation.results
		if mm_results == nil {
			mmTrailer.t.Fatal("No results are set for the ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Trailer")
		}
		return (*mm_results).m1
	}
	if mmTrailer.funcTrailer != nil {
		return mmTrailer.funcTrailer()
	}
	mmTrailer.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Trailer.")
	return
}

// TrailerAfterCounter returns a count of finished ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Trailer invocations
func (mmTrailer *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) TrailerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTrailer.afterTrailerCounter)
}

// TrailerBeforeCounter returns a count of ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Trailer invocations
func (mmTrailer *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) TrailerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTrailer.beforeTrailerCounter)
}

// MinimockTrailerDone returns true if the count of the Trailer invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockTrailerDone() bool {
	for _, e := range m.TrailerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TrailerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTrailerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTrailer != nil && mm_atomic.LoadUint64(&m.afterTrailerCounter) < 1 {
		return false
	}
	return true
}

// MinimockTrailerInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockTrailerInspect() {
	for _, e := range m.TrailerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Trailer")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TrailerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTrailerCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Trailer")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTrailer != nil && mm_atomic.LoadUint64(&m.afterTrailerCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToAllNotificationsV1ClientMock.Trailer")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCloseSendInspect()

		m.MinimockContextInspect()

		m.MinimockHeaderInspect()

		m.MinimockRecvInspect()

		m.MinimockRecvMsgInspect()

		m.MinimockSendMsgInspect()

		m.MinimockTrailerInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ImapConcentrator_SubscribeToAllNotificationsV1ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCloseSendDone() &&
		m.MinimockContextDone() &&
		m.MinimockHeaderDone() &&
		m.MinimockRecvDone() &&
		m.MinimockRecvMsgDone() &&
		m.MinimockSendMsgDone() &&
		m.MinimockTrailerDone()
}
