package imap_concentrator

// Code generated by http://github.com/gojuno/minimock (3.0.10). DO NOT EDIT.

//go:generate minimock -i github.com/aveplen/silicon-funnel/pkg/imap_concentrator/v1.ImapConcentratorServer -o ./imap_concentrator_server_mock_test.go -n ImapConcentratorServerMock

import (
	context "context"
	sync "sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ImapConcentratorServerMock implements ImapConcentratorServer
type ImapConcentratorServerMock struct {
	t minimock.Tester

	funcAssignUniqueClientID          func(ctx context.Context, ap1 *AssignUniqueClientIDRequest) (ap2 *AssignUniqueClientIDResponse, err error)
	inspectFuncAssignUniqueClientID   func(ctx context.Context, ap1 *AssignUniqueClientIDRequest)
	afterAssignUniqueClientIDCounter  uint64
	beforeAssignUniqueClientIDCounter uint64
	AssignUniqueClientIDMock          mImapConcentratorServerMockAssignUniqueClientID

	funcDeleteMailboxV1          func(ctx context.Context, dp1 *DeleteMailboxV1Request) (ap1 *Ack, err error)
	inspectFuncDeleteMailboxV1   func(ctx context.Context, dp1 *DeleteMailboxV1Request)
	afterDeleteMailboxV1Counter  uint64
	beforeDeleteMailboxV1Counter uint64
	DeleteMailboxV1Mock          mImapConcentratorServerMockDeleteMailboxV1

	funcGetMailboxV1          func(ctx context.Context, gp1 *GetMailboxV1Request) (gp2 *GetMailboxV1Response, err error)
	inspectFuncGetMailboxV1   func(ctx context.Context, gp1 *GetMailboxV1Request)
	afterGetMailboxV1Counter  uint64
	beforeGetMailboxV1Counter uint64
	GetMailboxV1Mock          mImapConcentratorServerMockGetMailboxV1

	funcInsertChatV1          func(ctx context.Context, ip1 *InsertChatV1Request) (ap1 *Ack, err error)
	inspectFuncInsertChatV1   func(ctx context.Context, ip1 *InsertChatV1Request)
	afterInsertChatV1Counter  uint64
	beforeInsertChatV1Counter uint64
	InsertChatV1Mock          mImapConcentratorServerMockInsertChatV1

	funcInsertMailboxV1          func(ctx context.Context, ip1 *InsertMailboxV1Request) (ap1 *Ack, err error)
	inspectFuncInsertMailboxV1   func(ctx context.Context, ip1 *InsertMailboxV1Request)
	afterInsertMailboxV1Counter  uint64
	beforeInsertMailboxV1Counter uint64
	InsertMailboxV1Mock          mImapConcentratorServerMockInsertMailboxV1

	funcListMailboxesV1          func(ctx context.Context, lp1 *ListMailboxesV1Request) (lp2 *ListMailboxesV1Response, err error)
	inspectFuncListMailboxesV1   func(ctx context.Context, lp1 *ListMailboxesV1Request)
	afterListMailboxesV1Counter  uint64
	beforeListMailboxesV1Counter uint64
	ListMailboxesV1Mock          mImapConcentratorServerMockListMailboxesV1

	funcPollV1          func(ctx context.Context, pp1 *PollV1Request) (ap1 *Ack, err error)
	inspectFuncPollV1   func(ctx context.Context, pp1 *PollV1Request)
	afterPollV1Counter  uint64
	beforePollV1Counter uint64
	PollV1Mock          mImapConcentratorServerMockPollV1

	funcSubscribeToAllNotificationsV1          func(sp1 *SubscribeToAllNotificationsV1Request, i1 ImapConcentrator_SubscribeToAllNotificationsV1Server) (err error)
	inspectFuncSubscribeToAllNotificationsV1   func(sp1 *SubscribeToAllNotificationsV1Request, i1 ImapConcentrator_SubscribeToAllNotificationsV1Server)
	afterSubscribeToAllNotificationsV1Counter  uint64
	beforeSubscribeToAllNotificationsV1Counter uint64
	SubscribeToAllNotificationsV1Mock          mImapConcentratorServerMockSubscribeToAllNotificationsV1

	funcSubscribeToChatNotificationsV1          func(sp1 *SubscribeToChatNotificationsV1Request, i1 ImapConcentrator_SubscribeToChatNotificationsV1Server) (err error)
	inspectFuncSubscribeToChatNotificationsV1   func(sp1 *SubscribeToChatNotificationsV1Request, i1 ImapConcentrator_SubscribeToChatNotificationsV1Server)
	afterSubscribeToChatNotificationsV1Counter  uint64
	beforeSubscribeToChatNotificationsV1Counter uint64
	SubscribeToChatNotificationsV1Mock          mImapConcentratorServerMockSubscribeToChatNotificationsV1

	funcUnsubscribeFromNotificationsV1          func(ctx context.Context, up1 *UnsubscribeFromNotificationsV1Request) (ap1 *Ack, err error)
	inspectFuncUnsubscribeFromNotificationsV1   func(ctx context.Context, up1 *UnsubscribeFromNotificationsV1Request)
	afterUnsubscribeFromNotificationsV1Counter  uint64
	beforeUnsubscribeFromNotificationsV1Counter uint64
	UnsubscribeFromNotificationsV1Mock          mImapConcentratorServerMockUnsubscribeFromNotificationsV1

	funcUpdateMailboxV1          func(ctx context.Context, up1 *UpdateMailboxV1Request) (ap1 *Ack, err error)
	inspectFuncUpdateMailboxV1   func(ctx context.Context, up1 *UpdateMailboxV1Request)
	afterUpdateMailboxV1Counter  uint64
	beforeUpdateMailboxV1Counter uint64
	UpdateMailboxV1Mock          mImapConcentratorServerMockUpdateMailboxV1

	funcmustEmbedUnimplementedImapConcentratorServer          func()
	inspectFuncmustEmbedUnimplementedImapConcentratorServer   func()
	aftermustEmbedUnimplementedImapConcentratorServerCounter  uint64
	beforemustEmbedUnimplementedImapConcentratorServerCounter uint64
	mustEmbedUnimplementedImapConcentratorServerMock          mImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServer
}

// NewImapConcentratorServerMock returns a mock for ImapConcentratorServer
func NewImapConcentratorServerMock(t minimock.Tester) *ImapConcentratorServerMock {
	m := &ImapConcentratorServerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AssignUniqueClientIDMock = mImapConcentratorServerMockAssignUniqueClientID{mock: m}
	m.AssignUniqueClientIDMock.callArgs = []*ImapConcentratorServerMockAssignUniqueClientIDParams{}

	m.DeleteMailboxV1Mock = mImapConcentratorServerMockDeleteMailboxV1{mock: m}
	m.DeleteMailboxV1Mock.callArgs = []*ImapConcentratorServerMockDeleteMailboxV1Params{}

	m.GetMailboxV1Mock = mImapConcentratorServerMockGetMailboxV1{mock: m}
	m.GetMailboxV1Mock.callArgs = []*ImapConcentratorServerMockGetMailboxV1Params{}

	m.InsertChatV1Mock = mImapConcentratorServerMockInsertChatV1{mock: m}
	m.InsertChatV1Mock.callArgs = []*ImapConcentratorServerMockInsertChatV1Params{}

	m.InsertMailboxV1Mock = mImapConcentratorServerMockInsertMailboxV1{mock: m}
	m.InsertMailboxV1Mock.callArgs = []*ImapConcentratorServerMockInsertMailboxV1Params{}

	m.ListMailboxesV1Mock = mImapConcentratorServerMockListMailboxesV1{mock: m}
	m.ListMailboxesV1Mock.callArgs = []*ImapConcentratorServerMockListMailboxesV1Params{}

	m.PollV1Mock = mImapConcentratorServerMockPollV1{mock: m}
	m.PollV1Mock.callArgs = []*ImapConcentratorServerMockPollV1Params{}

	m.SubscribeToAllNotificationsV1Mock = mImapConcentratorServerMockSubscribeToAllNotificationsV1{mock: m}
	m.SubscribeToAllNotificationsV1Mock.callArgs = []*ImapConcentratorServerMockSubscribeToAllNotificationsV1Params{}

	m.SubscribeToChatNotificationsV1Mock = mImapConcentratorServerMockSubscribeToChatNotificationsV1{mock: m}
	m.SubscribeToChatNotificationsV1Mock.callArgs = []*ImapConcentratorServerMockSubscribeToChatNotificationsV1Params{}

	m.UnsubscribeFromNotificationsV1Mock = mImapConcentratorServerMockUnsubscribeFromNotificationsV1{mock: m}
	m.UnsubscribeFromNotificationsV1Mock.callArgs = []*ImapConcentratorServerMockUnsubscribeFromNotificationsV1Params{}

	m.UpdateMailboxV1Mock = mImapConcentratorServerMockUpdateMailboxV1{mock: m}
	m.UpdateMailboxV1Mock.callArgs = []*ImapConcentratorServerMockUpdateMailboxV1Params{}

	m.mustEmbedUnimplementedImapConcentratorServerMock = mImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServer{mock: m}

	return m
}

type mImapConcentratorServerMockAssignUniqueClientID struct {
	mock               *ImapConcentratorServerMock
	defaultExpectation *ImapConcentratorServerMockAssignUniqueClientIDExpectation
	expectations       []*ImapConcentratorServerMockAssignUniqueClientIDExpectation

	callArgs []*ImapConcentratorServerMockAssignUniqueClientIDParams
	mutex    sync.RWMutex
}

// ImapConcentratorServerMockAssignUniqueClientIDExpectation specifies expectation struct of the ImapConcentratorServer.AssignUniqueClientID
type ImapConcentratorServerMockAssignUniqueClientIDExpectation struct {
	mock    *ImapConcentratorServerMock
	params  *ImapConcentratorServerMockAssignUniqueClientIDParams
	results *ImapConcentratorServerMockAssignUniqueClientIDResults
	Counter uint64
}

// ImapConcentratorServerMockAssignUniqueClientIDParams contains parameters of the ImapConcentratorServer.AssignUniqueClientID
type ImapConcentratorServerMockAssignUniqueClientIDParams struct {
	ctx context.Context
	ap1 *AssignUniqueClientIDRequest
}

// ImapConcentratorServerMockAssignUniqueClientIDResults contains results of the ImapConcentratorServer.AssignUniqueClientID
type ImapConcentratorServerMockAssignUniqueClientIDResults struct {
	ap2 *AssignUniqueClientIDResponse
	err error
}

// Expect sets up expected params for ImapConcentratorServer.AssignUniqueClientID
func (mmAssignUniqueClientID *mImapConcentratorServerMockAssignUniqueClientID) Expect(ctx context.Context, ap1 *AssignUniqueClientIDRequest) *mImapConcentratorServerMockAssignUniqueClientID {
	if mmAssignUniqueClientID.mock.funcAssignUniqueClientID != nil {
		mmAssignUniqueClientID.mock.t.Fatalf("ImapConcentratorServerMock.AssignUniqueClientID mock is already set by Set")
	}

	if mmAssignUniqueClientID.defaultExpectation == nil {
		mmAssignUniqueClientID.defaultExpectation = &ImapConcentratorServerMockAssignUniqueClientIDExpectation{}
	}

	mmAssignUniqueClientID.defaultExpectation.params = &ImapConcentratorServerMockAssignUniqueClientIDParams{ctx, ap1}
	for _, e := range mmAssignUniqueClientID.expectations {
		if minimock.Equal(e.params, mmAssignUniqueClientID.defaultExpectation.params) {
			mmAssignUniqueClientID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAssignUniqueClientID.defaultExpectation.params)
		}
	}

	return mmAssignUniqueClientID
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorServer.AssignUniqueClientID
func (mmAssignUniqueClientID *mImapConcentratorServerMockAssignUniqueClientID) Inspect(f func(ctx context.Context, ap1 *AssignUniqueClientIDRequest)) *mImapConcentratorServerMockAssignUniqueClientID {
	if mmAssignUniqueClientID.mock.inspectFuncAssignUniqueClientID != nil {
		mmAssignUniqueClientID.mock.t.Fatalf("Inspect function is already set for ImapConcentratorServerMock.AssignUniqueClientID")
	}

	mmAssignUniqueClientID.mock.inspectFuncAssignUniqueClientID = f

	return mmAssignUniqueClientID
}

// Return sets up results that will be returned by ImapConcentratorServer.AssignUniqueClientID
func (mmAssignUniqueClientID *mImapConcentratorServerMockAssignUniqueClientID) Return(ap2 *AssignUniqueClientIDResponse, err error) *ImapConcentratorServerMock {
	if mmAssignUniqueClientID.mock.funcAssignUniqueClientID != nil {
		mmAssignUniqueClientID.mock.t.Fatalf("ImapConcentratorServerMock.AssignUniqueClientID mock is already set by Set")
	}

	if mmAssignUniqueClientID.defaultExpectation == nil {
		mmAssignUniqueClientID.defaultExpectation = &ImapConcentratorServerMockAssignUniqueClientIDExpectation{mock: mmAssignUniqueClientID.mock}
	}
	mmAssignUniqueClientID.defaultExpectation.results = &ImapConcentratorServerMockAssignUniqueClientIDResults{ap2, err}
	return mmAssignUniqueClientID.mock
}

//Set uses given function f to mock the ImapConcentratorServer.AssignUniqueClientID method
func (mmAssignUniqueClientID *mImapConcentratorServerMockAssignUniqueClientID) Set(f func(ctx context.Context, ap1 *AssignUniqueClientIDRequest) (ap2 *AssignUniqueClientIDResponse, err error)) *ImapConcentratorServerMock {
	if mmAssignUniqueClientID.defaultExpectation != nil {
		mmAssignUniqueClientID.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorServer.AssignUniqueClientID method")
	}

	if len(mmAssignUniqueClientID.expectations) > 0 {
		mmAssignUniqueClientID.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorServer.AssignUniqueClientID method")
	}

	mmAssignUniqueClientID.mock.funcAssignUniqueClientID = f
	return mmAssignUniqueClientID.mock
}

// When sets expectation for the ImapConcentratorServer.AssignUniqueClientID which will trigger the result defined by the following
// Then helper
func (mmAssignUniqueClientID *mImapConcentratorServerMockAssignUniqueClientID) When(ctx context.Context, ap1 *AssignUniqueClientIDRequest) *ImapConcentratorServerMockAssignUniqueClientIDExpectation {
	if mmAssignUniqueClientID.mock.funcAssignUniqueClientID != nil {
		mmAssignUniqueClientID.mock.t.Fatalf("ImapConcentratorServerMock.AssignUniqueClientID mock is already set by Set")
	}

	expectation := &ImapConcentratorServerMockAssignUniqueClientIDExpectation{
		mock:   mmAssignUniqueClientID.mock,
		params: &ImapConcentratorServerMockAssignUniqueClientIDParams{ctx, ap1},
	}
	mmAssignUniqueClientID.expectations = append(mmAssignUniqueClientID.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorServer.AssignUniqueClientID return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorServerMockAssignUniqueClientIDExpectation) Then(ap2 *AssignUniqueClientIDResponse, err error) *ImapConcentratorServerMock {
	e.results = &ImapConcentratorServerMockAssignUniqueClientIDResults{ap2, err}
	return e.mock
}

// AssignUniqueClientID implements ImapConcentratorServer
func (mmAssignUniqueClientID *ImapConcentratorServerMock) AssignUniqueClientID(ctx context.Context, ap1 *AssignUniqueClientIDRequest) (ap2 *AssignUniqueClientIDResponse, err error) {
	mm_atomic.AddUint64(&mmAssignUniqueClientID.beforeAssignUniqueClientIDCounter, 1)
	defer mm_atomic.AddUint64(&mmAssignUniqueClientID.afterAssignUniqueClientIDCounter, 1)

	if mmAssignUniqueClientID.inspectFuncAssignUniqueClientID != nil {
		mmAssignUniqueClientID.inspectFuncAssignUniqueClientID(ctx, ap1)
	}

	mm_params := &ImapConcentratorServerMockAssignUniqueClientIDParams{ctx, ap1}

	// Record call args
	mmAssignUniqueClientID.AssignUniqueClientIDMock.mutex.Lock()
	mmAssignUniqueClientID.AssignUniqueClientIDMock.callArgs = append(mmAssignUniqueClientID.AssignUniqueClientIDMock.callArgs, mm_params)
	mmAssignUniqueClientID.AssignUniqueClientIDMock.mutex.Unlock()

	for _, e := range mmAssignUniqueClientID.AssignUniqueClientIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap2, e.results.err
		}
	}

	if mmAssignUniqueClientID.AssignUniqueClientIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAssignUniqueClientID.AssignUniqueClientIDMock.defaultExpectation.Counter, 1)
		mm_want := mmAssignUniqueClientID.AssignUniqueClientIDMock.defaultExpectation.params
		mm_got := ImapConcentratorServerMockAssignUniqueClientIDParams{ctx, ap1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAssignUniqueClientID.t.Errorf("ImapConcentratorServerMock.AssignUniqueClientID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAssignUniqueClientID.AssignUniqueClientIDMock.defaultExpectation.results
		if mm_results == nil {
			mmAssignUniqueClientID.t.Fatal("No results are set for the ImapConcentratorServerMock.AssignUniqueClientID")
		}
		return (*mm_results).ap2, (*mm_results).err
	}
	if mmAssignUniqueClientID.funcAssignUniqueClientID != nil {
		return mmAssignUniqueClientID.funcAssignUniqueClientID(ctx, ap1)
	}
	mmAssignUniqueClientID.t.Fatalf("Unexpected call to ImapConcentratorServerMock.AssignUniqueClientID. %v %v", ctx, ap1)
	return
}

// AssignUniqueClientIDAfterCounter returns a count of finished ImapConcentratorServerMock.AssignUniqueClientID invocations
func (mmAssignUniqueClientID *ImapConcentratorServerMock) AssignUniqueClientIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAssignUniqueClientID.afterAssignUniqueClientIDCounter)
}

// AssignUniqueClientIDBeforeCounter returns a count of ImapConcentratorServerMock.AssignUniqueClientID invocations
func (mmAssignUniqueClientID *ImapConcentratorServerMock) AssignUniqueClientIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAssignUniqueClientID.beforeAssignUniqueClientIDCounter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorServerMock.AssignUniqueClientID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAssignUniqueClientID *mImapConcentratorServerMockAssignUniqueClientID) Calls() []*ImapConcentratorServerMockAssignUniqueClientIDParams {
	mmAssignUniqueClientID.mutex.RLock()

	argCopy := make([]*ImapConcentratorServerMockAssignUniqueClientIDParams, len(mmAssignUniqueClientID.callArgs))
	copy(argCopy, mmAssignUniqueClientID.callArgs)

	mmAssignUniqueClientID.mutex.RUnlock()

	return argCopy
}

// MinimockAssignUniqueClientIDDone returns true if the count of the AssignUniqueClientID invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorServerMock) MinimockAssignUniqueClientIDDone() bool {
	for _, e := range m.AssignUniqueClientIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AssignUniqueClientIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAssignUniqueClientIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAssignUniqueClientID != nil && mm_atomic.LoadUint64(&m.afterAssignUniqueClientIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockAssignUniqueClientIDInspect logs each unmet expectation
func (m *ImapConcentratorServerMock) MinimockAssignUniqueClientIDInspect() {
	for _, e := range m.AssignUniqueClientIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.AssignUniqueClientID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AssignUniqueClientIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAssignUniqueClientIDCounter) < 1 {
		if m.AssignUniqueClientIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorServerMock.AssignUniqueClientID")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.AssignUniqueClientID with params: %#v", *m.AssignUniqueClientIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAssignUniqueClientID != nil && mm_atomic.LoadUint64(&m.afterAssignUniqueClientIDCounter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.AssignUniqueClientID")
	}
}

type mImapConcentratorServerMockDeleteMailboxV1 struct {
	mock               *ImapConcentratorServerMock
	defaultExpectation *ImapConcentratorServerMockDeleteMailboxV1Expectation
	expectations       []*ImapConcentratorServerMockDeleteMailboxV1Expectation

	callArgs []*ImapConcentratorServerMockDeleteMailboxV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorServerMockDeleteMailboxV1Expectation specifies expectation struct of the ImapConcentratorServer.DeleteMailboxV1
type ImapConcentratorServerMockDeleteMailboxV1Expectation struct {
	mock    *ImapConcentratorServerMock
	params  *ImapConcentratorServerMockDeleteMailboxV1Params
	results *ImapConcentratorServerMockDeleteMailboxV1Results
	Counter uint64
}

// ImapConcentratorServerMockDeleteMailboxV1Params contains parameters of the ImapConcentratorServer.DeleteMailboxV1
type ImapConcentratorServerMockDeleteMailboxV1Params struct {
	ctx context.Context
	dp1 *DeleteMailboxV1Request
}

// ImapConcentratorServerMockDeleteMailboxV1Results contains results of the ImapConcentratorServer.DeleteMailboxV1
type ImapConcentratorServerMockDeleteMailboxV1Results struct {
	ap1 *Ack
	err error
}

// Expect sets up expected params for ImapConcentratorServer.DeleteMailboxV1
func (mmDeleteMailboxV1 *mImapConcentratorServerMockDeleteMailboxV1) Expect(ctx context.Context, dp1 *DeleteMailboxV1Request) *mImapConcentratorServerMockDeleteMailboxV1 {
	if mmDeleteMailboxV1.mock.funcDeleteMailboxV1 != nil {
		mmDeleteMailboxV1.mock.t.Fatalf("ImapConcentratorServerMock.DeleteMailboxV1 mock is already set by Set")
	}

	if mmDeleteMailboxV1.defaultExpectation == nil {
		mmDeleteMailboxV1.defaultExpectation = &ImapConcentratorServerMockDeleteMailboxV1Expectation{}
	}

	mmDeleteMailboxV1.defaultExpectation.params = &ImapConcentratorServerMockDeleteMailboxV1Params{ctx, dp1}
	for _, e := range mmDeleteMailboxV1.expectations {
		if minimock.Equal(e.params, mmDeleteMailboxV1.defaultExpectation.params) {
			mmDeleteMailboxV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteMailboxV1.defaultExpectation.params)
		}
	}

	return mmDeleteMailboxV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorServer.DeleteMailboxV1
func (mmDeleteMailboxV1 *mImapConcentratorServerMockDeleteMailboxV1) Inspect(f func(ctx context.Context, dp1 *DeleteMailboxV1Request)) *mImapConcentratorServerMockDeleteMailboxV1 {
	if mmDeleteMailboxV1.mock.inspectFuncDeleteMailboxV1 != nil {
		mmDeleteMailboxV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorServerMock.DeleteMailboxV1")
	}

	mmDeleteMailboxV1.mock.inspectFuncDeleteMailboxV1 = f

	return mmDeleteMailboxV1
}

// Return sets up results that will be returned by ImapConcentratorServer.DeleteMailboxV1
func (mmDeleteMailboxV1 *mImapConcentratorServerMockDeleteMailboxV1) Return(ap1 *Ack, err error) *ImapConcentratorServerMock {
	if mmDeleteMailboxV1.mock.funcDeleteMailboxV1 != nil {
		mmDeleteMailboxV1.mock.t.Fatalf("ImapConcentratorServerMock.DeleteMailboxV1 mock is already set by Set")
	}

	if mmDeleteMailboxV1.defaultExpectation == nil {
		mmDeleteMailboxV1.defaultExpectation = &ImapConcentratorServerMockDeleteMailboxV1Expectation{mock: mmDeleteMailboxV1.mock}
	}
	mmDeleteMailboxV1.defaultExpectation.results = &ImapConcentratorServerMockDeleteMailboxV1Results{ap1, err}
	return mmDeleteMailboxV1.mock
}

//Set uses given function f to mock the ImapConcentratorServer.DeleteMailboxV1 method
func (mmDeleteMailboxV1 *mImapConcentratorServerMockDeleteMailboxV1) Set(f func(ctx context.Context, dp1 *DeleteMailboxV1Request) (ap1 *Ack, err error)) *ImapConcentratorServerMock {
	if mmDeleteMailboxV1.defaultExpectation != nil {
		mmDeleteMailboxV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorServer.DeleteMailboxV1 method")
	}

	if len(mmDeleteMailboxV1.expectations) > 0 {
		mmDeleteMailboxV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorServer.DeleteMailboxV1 method")
	}

	mmDeleteMailboxV1.mock.funcDeleteMailboxV1 = f
	return mmDeleteMailboxV1.mock
}

// When sets expectation for the ImapConcentratorServer.DeleteMailboxV1 which will trigger the result defined by the following
// Then helper
func (mmDeleteMailboxV1 *mImapConcentratorServerMockDeleteMailboxV1) When(ctx context.Context, dp1 *DeleteMailboxV1Request) *ImapConcentratorServerMockDeleteMailboxV1Expectation {
	if mmDeleteMailboxV1.mock.funcDeleteMailboxV1 != nil {
		mmDeleteMailboxV1.mock.t.Fatalf("ImapConcentratorServerMock.DeleteMailboxV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorServerMockDeleteMailboxV1Expectation{
		mock:   mmDeleteMailboxV1.mock,
		params: &ImapConcentratorServerMockDeleteMailboxV1Params{ctx, dp1},
	}
	mmDeleteMailboxV1.expectations = append(mmDeleteMailboxV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorServer.DeleteMailboxV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorServerMockDeleteMailboxV1Expectation) Then(ap1 *Ack, err error) *ImapConcentratorServerMock {
	e.results = &ImapConcentratorServerMockDeleteMailboxV1Results{ap1, err}
	return e.mock
}

// DeleteMailboxV1 implements ImapConcentratorServer
func (mmDeleteMailboxV1 *ImapConcentratorServerMock) DeleteMailboxV1(ctx context.Context, dp1 *DeleteMailboxV1Request) (ap1 *Ack, err error) {
	mm_atomic.AddUint64(&mmDeleteMailboxV1.beforeDeleteMailboxV1Counter, 1)
	defer mm_atomic.AddUint64(&mmDeleteMailboxV1.afterDeleteMailboxV1Counter, 1)

	if mmDeleteMailboxV1.inspectFuncDeleteMailboxV1 != nil {
		mmDeleteMailboxV1.inspectFuncDeleteMailboxV1(ctx, dp1)
	}

	mm_params := &ImapConcentratorServerMockDeleteMailboxV1Params{ctx, dp1}

	// Record call args
	mmDeleteMailboxV1.DeleteMailboxV1Mock.mutex.Lock()
	mmDeleteMailboxV1.DeleteMailboxV1Mock.callArgs = append(mmDeleteMailboxV1.DeleteMailboxV1Mock.callArgs, mm_params)
	mmDeleteMailboxV1.DeleteMailboxV1Mock.mutex.Unlock()

	for _, e := range mmDeleteMailboxV1.DeleteMailboxV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmDeleteMailboxV1.DeleteMailboxV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteMailboxV1.DeleteMailboxV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteMailboxV1.DeleteMailboxV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorServerMockDeleteMailboxV1Params{ctx, dp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteMailboxV1.t.Errorf("ImapConcentratorServerMock.DeleteMailboxV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteMailboxV1.DeleteMailboxV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteMailboxV1.t.Fatal("No results are set for the ImapConcentratorServerMock.DeleteMailboxV1")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmDeleteMailboxV1.funcDeleteMailboxV1 != nil {
		return mmDeleteMailboxV1.funcDeleteMailboxV1(ctx, dp1)
	}
	mmDeleteMailboxV1.t.Fatalf("Unexpected call to ImapConcentratorServerMock.DeleteMailboxV1. %v %v", ctx, dp1)
	return
}

// DeleteMailboxV1AfterCounter returns a count of finished ImapConcentratorServerMock.DeleteMailboxV1 invocations
func (mmDeleteMailboxV1 *ImapConcentratorServerMock) DeleteMailboxV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMailboxV1.afterDeleteMailboxV1Counter)
}

// DeleteMailboxV1BeforeCounter returns a count of ImapConcentratorServerMock.DeleteMailboxV1 invocations
func (mmDeleteMailboxV1 *ImapConcentratorServerMock) DeleteMailboxV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMailboxV1.beforeDeleteMailboxV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorServerMock.DeleteMailboxV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteMailboxV1 *mImapConcentratorServerMockDeleteMailboxV1) Calls() []*ImapConcentratorServerMockDeleteMailboxV1Params {
	mmDeleteMailboxV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorServerMockDeleteMailboxV1Params, len(mmDeleteMailboxV1.callArgs))
	copy(argCopy, mmDeleteMailboxV1.callArgs)

	mmDeleteMailboxV1.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteMailboxV1Done returns true if the count of the DeleteMailboxV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorServerMock) MinimockDeleteMailboxV1Done() bool {
	for _, e := range m.DeleteMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteMailboxV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterDeleteMailboxV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteMailboxV1Inspect logs each unmet expectation
func (m *ImapConcentratorServerMock) MinimockDeleteMailboxV1Inspect() {
	for _, e := range m.DeleteMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.DeleteMailboxV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteMailboxV1Counter) < 1 {
		if m.DeleteMailboxV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorServerMock.DeleteMailboxV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.DeleteMailboxV1 with params: %#v", *m.DeleteMailboxV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterDeleteMailboxV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.DeleteMailboxV1")
	}
}

type mImapConcentratorServerMockGetMailboxV1 struct {
	mock               *ImapConcentratorServerMock
	defaultExpectation *ImapConcentratorServerMockGetMailboxV1Expectation
	expectations       []*ImapConcentratorServerMockGetMailboxV1Expectation

	callArgs []*ImapConcentratorServerMockGetMailboxV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorServerMockGetMailboxV1Expectation specifies expectation struct of the ImapConcentratorServer.GetMailboxV1
type ImapConcentratorServerMockGetMailboxV1Expectation struct {
	mock    *ImapConcentratorServerMock
	params  *ImapConcentratorServerMockGetMailboxV1Params
	results *ImapConcentratorServerMockGetMailboxV1Results
	Counter uint64
}

// ImapConcentratorServerMockGetMailboxV1Params contains parameters of the ImapConcentratorServer.GetMailboxV1
type ImapConcentratorServerMockGetMailboxV1Params struct {
	ctx context.Context
	gp1 *GetMailboxV1Request
}

// ImapConcentratorServerMockGetMailboxV1Results contains results of the ImapConcentratorServer.GetMailboxV1
type ImapConcentratorServerMockGetMailboxV1Results struct {
	gp2 *GetMailboxV1Response
	err error
}

// Expect sets up expected params for ImapConcentratorServer.GetMailboxV1
func (mmGetMailboxV1 *mImapConcentratorServerMockGetMailboxV1) Expect(ctx context.Context, gp1 *GetMailboxV1Request) *mImapConcentratorServerMockGetMailboxV1 {
	if mmGetMailboxV1.mock.funcGetMailboxV1 != nil {
		mmGetMailboxV1.mock.t.Fatalf("ImapConcentratorServerMock.GetMailboxV1 mock is already set by Set")
	}

	if mmGetMailboxV1.defaultExpectation == nil {
		mmGetMailboxV1.defaultExpectation = &ImapConcentratorServerMockGetMailboxV1Expectation{}
	}

	mmGetMailboxV1.defaultExpectation.params = &ImapConcentratorServerMockGetMailboxV1Params{ctx, gp1}
	for _, e := range mmGetMailboxV1.expectations {
		if minimock.Equal(e.params, mmGetMailboxV1.defaultExpectation.params) {
			mmGetMailboxV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetMailboxV1.defaultExpectation.params)
		}
	}

	return mmGetMailboxV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorServer.GetMailboxV1
func (mmGetMailboxV1 *mImapConcentratorServerMockGetMailboxV1) Inspect(f func(ctx context.Context, gp1 *GetMailboxV1Request)) *mImapConcentratorServerMockGetMailboxV1 {
	if mmGetMailboxV1.mock.inspectFuncGetMailboxV1 != nil {
		mmGetMailboxV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorServerMock.GetMailboxV1")
	}

	mmGetMailboxV1.mock.inspectFuncGetMailboxV1 = f

	return mmGetMailboxV1
}

// Return sets up results that will be returned by ImapConcentratorServer.GetMailboxV1
func (mmGetMailboxV1 *mImapConcentratorServerMockGetMailboxV1) Return(gp2 *GetMailboxV1Response, err error) *ImapConcentratorServerMock {
	if mmGetMailboxV1.mock.funcGetMailboxV1 != nil {
		mmGetMailboxV1.mock.t.Fatalf("ImapConcentratorServerMock.GetMailboxV1 mock is already set by Set")
	}

	if mmGetMailboxV1.defaultExpectation == nil {
		mmGetMailboxV1.defaultExpectation = &ImapConcentratorServerMockGetMailboxV1Expectation{mock: mmGetMailboxV1.mock}
	}
	mmGetMailboxV1.defaultExpectation.results = &ImapConcentratorServerMockGetMailboxV1Results{gp2, err}
	return mmGetMailboxV1.mock
}

//Set uses given function f to mock the ImapConcentratorServer.GetMailboxV1 method
func (mmGetMailboxV1 *mImapConcentratorServerMockGetMailboxV1) Set(f func(ctx context.Context, gp1 *GetMailboxV1Request) (gp2 *GetMailboxV1Response, err error)) *ImapConcentratorServerMock {
	if mmGetMailboxV1.defaultExpectation != nil {
		mmGetMailboxV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorServer.GetMailboxV1 method")
	}

	if len(mmGetMailboxV1.expectations) > 0 {
		mmGetMailboxV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorServer.GetMailboxV1 method")
	}

	mmGetMailboxV1.mock.funcGetMailboxV1 = f
	return mmGetMailboxV1.mock
}

// When sets expectation for the ImapConcentratorServer.GetMailboxV1 which will trigger the result defined by the following
// Then helper
func (mmGetMailboxV1 *mImapConcentratorServerMockGetMailboxV1) When(ctx context.Context, gp1 *GetMailboxV1Request) *ImapConcentratorServerMockGetMailboxV1Expectation {
	if mmGetMailboxV1.mock.funcGetMailboxV1 != nil {
		mmGetMailboxV1.mock.t.Fatalf("ImapConcentratorServerMock.GetMailboxV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorServerMockGetMailboxV1Expectation{
		mock:   mmGetMailboxV1.mock,
		params: &ImapConcentratorServerMockGetMailboxV1Params{ctx, gp1},
	}
	mmGetMailboxV1.expectations = append(mmGetMailboxV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorServer.GetMailboxV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorServerMockGetMailboxV1Expectation) Then(gp2 *GetMailboxV1Response, err error) *ImapConcentratorServerMock {
	e.results = &ImapConcentratorServerMockGetMailboxV1Results{gp2, err}
	return e.mock
}

// GetMailboxV1 implements ImapConcentratorServer
func (mmGetMailboxV1 *ImapConcentratorServerMock) GetMailboxV1(ctx context.Context, gp1 *GetMailboxV1Request) (gp2 *GetMailboxV1Response, err error) {
	mm_atomic.AddUint64(&mmGetMailboxV1.beforeGetMailboxV1Counter, 1)
	defer mm_atomic.AddUint64(&mmGetMailboxV1.afterGetMailboxV1Counter, 1)

	if mmGetMailboxV1.inspectFuncGetMailboxV1 != nil {
		mmGetMailboxV1.inspectFuncGetMailboxV1(ctx, gp1)
	}

	mm_params := &ImapConcentratorServerMockGetMailboxV1Params{ctx, gp1}

	// Record call args
	mmGetMailboxV1.GetMailboxV1Mock.mutex.Lock()
	mmGetMailboxV1.GetMailboxV1Mock.callArgs = append(mmGetMailboxV1.GetMailboxV1Mock.callArgs, mm_params)
	mmGetMailboxV1.GetMailboxV1Mock.mutex.Unlock()

	for _, e := range mmGetMailboxV1.GetMailboxV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp2, e.results.err
		}
	}

	if mmGetMailboxV1.GetMailboxV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMailboxV1.GetMailboxV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmGetMailboxV1.GetMailboxV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorServerMockGetMailboxV1Params{ctx, gp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetMailboxV1.t.Errorf("ImapConcentratorServerMock.GetMailboxV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetMailboxV1.GetMailboxV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmGetMailboxV1.t.Fatal("No results are set for the ImapConcentratorServerMock.GetMailboxV1")
		}
		return (*mm_results).gp2, (*mm_results).err
	}
	if mmGetMailboxV1.funcGetMailboxV1 != nil {
		return mmGetMailboxV1.funcGetMailboxV1(ctx, gp1)
	}
	mmGetMailboxV1.t.Fatalf("Unexpected call to ImapConcentratorServerMock.GetMailboxV1. %v %v", ctx, gp1)
	return
}

// GetMailboxV1AfterCounter returns a count of finished ImapConcentratorServerMock.GetMailboxV1 invocations
func (mmGetMailboxV1 *ImapConcentratorServerMock) GetMailboxV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMailboxV1.afterGetMailboxV1Counter)
}

// GetMailboxV1BeforeCounter returns a count of ImapConcentratorServerMock.GetMailboxV1 invocations
func (mmGetMailboxV1 *ImapConcentratorServerMock) GetMailboxV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMailboxV1.beforeGetMailboxV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorServerMock.GetMailboxV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetMailboxV1 *mImapConcentratorServerMockGetMailboxV1) Calls() []*ImapConcentratorServerMockGetMailboxV1Params {
	mmGetMailboxV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorServerMockGetMailboxV1Params, len(mmGetMailboxV1.callArgs))
	copy(argCopy, mmGetMailboxV1.callArgs)

	mmGetMailboxV1.mutex.RUnlock()

	return argCopy
}

// MinimockGetMailboxV1Done returns true if the count of the GetMailboxV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorServerMock) MinimockGetMailboxV1Done() bool {
	for _, e := range m.GetMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMailboxV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterGetMailboxV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockGetMailboxV1Inspect logs each unmet expectation
func (m *ImapConcentratorServerMock) MinimockGetMailboxV1Inspect() {
	for _, e := range m.GetMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.GetMailboxV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMailboxV1Counter) < 1 {
		if m.GetMailboxV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorServerMock.GetMailboxV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.GetMailboxV1 with params: %#v", *m.GetMailboxV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterGetMailboxV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.GetMailboxV1")
	}
}

type mImapConcentratorServerMockInsertChatV1 struct {
	mock               *ImapConcentratorServerMock
	defaultExpectation *ImapConcentratorServerMockInsertChatV1Expectation
	expectations       []*ImapConcentratorServerMockInsertChatV1Expectation

	callArgs []*ImapConcentratorServerMockInsertChatV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorServerMockInsertChatV1Expectation specifies expectation struct of the ImapConcentratorServer.InsertChatV1
type ImapConcentratorServerMockInsertChatV1Expectation struct {
	mock    *ImapConcentratorServerMock
	params  *ImapConcentratorServerMockInsertChatV1Params
	results *ImapConcentratorServerMockInsertChatV1Results
	Counter uint64
}

// ImapConcentratorServerMockInsertChatV1Params contains parameters of the ImapConcentratorServer.InsertChatV1
type ImapConcentratorServerMockInsertChatV1Params struct {
	ctx context.Context
	ip1 *InsertChatV1Request
}

// ImapConcentratorServerMockInsertChatV1Results contains results of the ImapConcentratorServer.InsertChatV1
type ImapConcentratorServerMockInsertChatV1Results struct {
	ap1 *Ack
	err error
}

// Expect sets up expected params for ImapConcentratorServer.InsertChatV1
func (mmInsertChatV1 *mImapConcentratorServerMockInsertChatV1) Expect(ctx context.Context, ip1 *InsertChatV1Request) *mImapConcentratorServerMockInsertChatV1 {
	if mmInsertChatV1.mock.funcInsertChatV1 != nil {
		mmInsertChatV1.mock.t.Fatalf("ImapConcentratorServerMock.InsertChatV1 mock is already set by Set")
	}

	if mmInsertChatV1.defaultExpectation == nil {
		mmInsertChatV1.defaultExpectation = &ImapConcentratorServerMockInsertChatV1Expectation{}
	}

	mmInsertChatV1.defaultExpectation.params = &ImapConcentratorServerMockInsertChatV1Params{ctx, ip1}
	for _, e := range mmInsertChatV1.expectations {
		if minimock.Equal(e.params, mmInsertChatV1.defaultExpectation.params) {
			mmInsertChatV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertChatV1.defaultExpectation.params)
		}
	}

	return mmInsertChatV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorServer.InsertChatV1
func (mmInsertChatV1 *mImapConcentratorServerMockInsertChatV1) Inspect(f func(ctx context.Context, ip1 *InsertChatV1Request)) *mImapConcentratorServerMockInsertChatV1 {
	if mmInsertChatV1.mock.inspectFuncInsertChatV1 != nil {
		mmInsertChatV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorServerMock.InsertChatV1")
	}

	mmInsertChatV1.mock.inspectFuncInsertChatV1 = f

	return mmInsertChatV1
}

// Return sets up results that will be returned by ImapConcentratorServer.InsertChatV1
func (mmInsertChatV1 *mImapConcentratorServerMockInsertChatV1) Return(ap1 *Ack, err error) *ImapConcentratorServerMock {
	if mmInsertChatV1.mock.funcInsertChatV1 != nil {
		mmInsertChatV1.mock.t.Fatalf("ImapConcentratorServerMock.InsertChatV1 mock is already set by Set")
	}

	if mmInsertChatV1.defaultExpectation == nil {
		mmInsertChatV1.defaultExpectation = &ImapConcentratorServerMockInsertChatV1Expectation{mock: mmInsertChatV1.mock}
	}
	mmInsertChatV1.defaultExpectation.results = &ImapConcentratorServerMockInsertChatV1Results{ap1, err}
	return mmInsertChatV1.mock
}

//Set uses given function f to mock the ImapConcentratorServer.InsertChatV1 method
func (mmInsertChatV1 *mImapConcentratorServerMockInsertChatV1) Set(f func(ctx context.Context, ip1 *InsertChatV1Request) (ap1 *Ack, err error)) *ImapConcentratorServerMock {
	if mmInsertChatV1.defaultExpectation != nil {
		mmInsertChatV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorServer.InsertChatV1 method")
	}

	if len(mmInsertChatV1.expectations) > 0 {
		mmInsertChatV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorServer.InsertChatV1 method")
	}

	mmInsertChatV1.mock.funcInsertChatV1 = f
	return mmInsertChatV1.mock
}

// When sets expectation for the ImapConcentratorServer.InsertChatV1 which will trigger the result defined by the following
// Then helper
func (mmInsertChatV1 *mImapConcentratorServerMockInsertChatV1) When(ctx context.Context, ip1 *InsertChatV1Request) *ImapConcentratorServerMockInsertChatV1Expectation {
	if mmInsertChatV1.mock.funcInsertChatV1 != nil {
		mmInsertChatV1.mock.t.Fatalf("ImapConcentratorServerMock.InsertChatV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorServerMockInsertChatV1Expectation{
		mock:   mmInsertChatV1.mock,
		params: &ImapConcentratorServerMockInsertChatV1Params{ctx, ip1},
	}
	mmInsertChatV1.expectations = append(mmInsertChatV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorServer.InsertChatV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorServerMockInsertChatV1Expectation) Then(ap1 *Ack, err error) *ImapConcentratorServerMock {
	e.results = &ImapConcentratorServerMockInsertChatV1Results{ap1, err}
	return e.mock
}

// InsertChatV1 implements ImapConcentratorServer
func (mmInsertChatV1 *ImapConcentratorServerMock) InsertChatV1(ctx context.Context, ip1 *InsertChatV1Request) (ap1 *Ack, err error) {
	mm_atomic.AddUint64(&mmInsertChatV1.beforeInsertChatV1Counter, 1)
	defer mm_atomic.AddUint64(&mmInsertChatV1.afterInsertChatV1Counter, 1)

	if mmInsertChatV1.inspectFuncInsertChatV1 != nil {
		mmInsertChatV1.inspectFuncInsertChatV1(ctx, ip1)
	}

	mm_params := &ImapConcentratorServerMockInsertChatV1Params{ctx, ip1}

	// Record call args
	mmInsertChatV1.InsertChatV1Mock.mutex.Lock()
	mmInsertChatV1.InsertChatV1Mock.callArgs = append(mmInsertChatV1.InsertChatV1Mock.callArgs, mm_params)
	mmInsertChatV1.InsertChatV1Mock.mutex.Unlock()

	for _, e := range mmInsertChatV1.InsertChatV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmInsertChatV1.InsertChatV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertChatV1.InsertChatV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmInsertChatV1.InsertChatV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorServerMockInsertChatV1Params{ctx, ip1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertChatV1.t.Errorf("ImapConcentratorServerMock.InsertChatV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertChatV1.InsertChatV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmInsertChatV1.t.Fatal("No results are set for the ImapConcentratorServerMock.InsertChatV1")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmInsertChatV1.funcInsertChatV1 != nil {
		return mmInsertChatV1.funcInsertChatV1(ctx, ip1)
	}
	mmInsertChatV1.t.Fatalf("Unexpected call to ImapConcentratorServerMock.InsertChatV1. %v %v", ctx, ip1)
	return
}

// InsertChatV1AfterCounter returns a count of finished ImapConcentratorServerMock.InsertChatV1 invocations
func (mmInsertChatV1 *ImapConcentratorServerMock) InsertChatV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertChatV1.afterInsertChatV1Counter)
}

// InsertChatV1BeforeCounter returns a count of ImapConcentratorServerMock.InsertChatV1 invocations
func (mmInsertChatV1 *ImapConcentratorServerMock) InsertChatV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertChatV1.beforeInsertChatV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorServerMock.InsertChatV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertChatV1 *mImapConcentratorServerMockInsertChatV1) Calls() []*ImapConcentratorServerMockInsertChatV1Params {
	mmInsertChatV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorServerMockInsertChatV1Params, len(mmInsertChatV1.callArgs))
	copy(argCopy, mmInsertChatV1.callArgs)

	mmInsertChatV1.mutex.RUnlock()

	return argCopy
}

// MinimockInsertChatV1Done returns true if the count of the InsertChatV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorServerMock) MinimockInsertChatV1Done() bool {
	for _, e := range m.InsertChatV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertChatV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertChatV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertChatV1 != nil && mm_atomic.LoadUint64(&m.afterInsertChatV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockInsertChatV1Inspect logs each unmet expectation
func (m *ImapConcentratorServerMock) MinimockInsertChatV1Inspect() {
	for _, e := range m.InsertChatV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.InsertChatV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertChatV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertChatV1Counter) < 1 {
		if m.InsertChatV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorServerMock.InsertChatV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.InsertChatV1 with params: %#v", *m.InsertChatV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertChatV1 != nil && mm_atomic.LoadUint64(&m.afterInsertChatV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.InsertChatV1")
	}
}

type mImapConcentratorServerMockInsertMailboxV1 struct {
	mock               *ImapConcentratorServerMock
	defaultExpectation *ImapConcentratorServerMockInsertMailboxV1Expectation
	expectations       []*ImapConcentratorServerMockInsertMailboxV1Expectation

	callArgs []*ImapConcentratorServerMockInsertMailboxV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorServerMockInsertMailboxV1Expectation specifies expectation struct of the ImapConcentratorServer.InsertMailboxV1
type ImapConcentratorServerMockInsertMailboxV1Expectation struct {
	mock    *ImapConcentratorServerMock
	params  *ImapConcentratorServerMockInsertMailboxV1Params
	results *ImapConcentratorServerMockInsertMailboxV1Results
	Counter uint64
}

// ImapConcentratorServerMockInsertMailboxV1Params contains parameters of the ImapConcentratorServer.InsertMailboxV1
type ImapConcentratorServerMockInsertMailboxV1Params struct {
	ctx context.Context
	ip1 *InsertMailboxV1Request
}

// ImapConcentratorServerMockInsertMailboxV1Results contains results of the ImapConcentratorServer.InsertMailboxV1
type ImapConcentratorServerMockInsertMailboxV1Results struct {
	ap1 *Ack
	err error
}

// Expect sets up expected params for ImapConcentratorServer.InsertMailboxV1
func (mmInsertMailboxV1 *mImapConcentratorServerMockInsertMailboxV1) Expect(ctx context.Context, ip1 *InsertMailboxV1Request) *mImapConcentratorServerMockInsertMailboxV1 {
	if mmInsertMailboxV1.mock.funcInsertMailboxV1 != nil {
		mmInsertMailboxV1.mock.t.Fatalf("ImapConcentratorServerMock.InsertMailboxV1 mock is already set by Set")
	}

	if mmInsertMailboxV1.defaultExpectation == nil {
		mmInsertMailboxV1.defaultExpectation = &ImapConcentratorServerMockInsertMailboxV1Expectation{}
	}

	mmInsertMailboxV1.defaultExpectation.params = &ImapConcentratorServerMockInsertMailboxV1Params{ctx, ip1}
	for _, e := range mmInsertMailboxV1.expectations {
		if minimock.Equal(e.params, mmInsertMailboxV1.defaultExpectation.params) {
			mmInsertMailboxV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertMailboxV1.defaultExpectation.params)
		}
	}

	return mmInsertMailboxV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorServer.InsertMailboxV1
func (mmInsertMailboxV1 *mImapConcentratorServerMockInsertMailboxV1) Inspect(f func(ctx context.Context, ip1 *InsertMailboxV1Request)) *mImapConcentratorServerMockInsertMailboxV1 {
	if mmInsertMailboxV1.mock.inspectFuncInsertMailboxV1 != nil {
		mmInsertMailboxV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorServerMock.InsertMailboxV1")
	}

	mmInsertMailboxV1.mock.inspectFuncInsertMailboxV1 = f

	return mmInsertMailboxV1
}

// Return sets up results that will be returned by ImapConcentratorServer.InsertMailboxV1
func (mmInsertMailboxV1 *mImapConcentratorServerMockInsertMailboxV1) Return(ap1 *Ack, err error) *ImapConcentratorServerMock {
	if mmInsertMailboxV1.mock.funcInsertMailboxV1 != nil {
		mmInsertMailboxV1.mock.t.Fatalf("ImapConcentratorServerMock.InsertMailboxV1 mock is already set by Set")
	}

	if mmInsertMailboxV1.defaultExpectation == nil {
		mmInsertMailboxV1.defaultExpectation = &ImapConcentratorServerMockInsertMailboxV1Expectation{mock: mmInsertMailboxV1.mock}
	}
	mmInsertMailboxV1.defaultExpectation.results = &ImapConcentratorServerMockInsertMailboxV1Results{ap1, err}
	return mmInsertMailboxV1.mock
}

//Set uses given function f to mock the ImapConcentratorServer.InsertMailboxV1 method
func (mmInsertMailboxV1 *mImapConcentratorServerMockInsertMailboxV1) Set(f func(ctx context.Context, ip1 *InsertMailboxV1Request) (ap1 *Ack, err error)) *ImapConcentratorServerMock {
	if mmInsertMailboxV1.defaultExpectation != nil {
		mmInsertMailboxV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorServer.InsertMailboxV1 method")
	}

	if len(mmInsertMailboxV1.expectations) > 0 {
		mmInsertMailboxV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorServer.InsertMailboxV1 method")
	}

	mmInsertMailboxV1.mock.funcInsertMailboxV1 = f
	return mmInsertMailboxV1.mock
}

// When sets expectation for the ImapConcentratorServer.InsertMailboxV1 which will trigger the result defined by the following
// Then helper
func (mmInsertMailboxV1 *mImapConcentratorServerMockInsertMailboxV1) When(ctx context.Context, ip1 *InsertMailboxV1Request) *ImapConcentratorServerMockInsertMailboxV1Expectation {
	if mmInsertMailboxV1.mock.funcInsertMailboxV1 != nil {
		mmInsertMailboxV1.mock.t.Fatalf("ImapConcentratorServerMock.InsertMailboxV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorServerMockInsertMailboxV1Expectation{
		mock:   mmInsertMailboxV1.mock,
		params: &ImapConcentratorServerMockInsertMailboxV1Params{ctx, ip1},
	}
	mmInsertMailboxV1.expectations = append(mmInsertMailboxV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorServer.InsertMailboxV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorServerMockInsertMailboxV1Expectation) Then(ap1 *Ack, err error) *ImapConcentratorServerMock {
	e.results = &ImapConcentratorServerMockInsertMailboxV1Results{ap1, err}
	return e.mock
}

// InsertMailboxV1 implements ImapConcentratorServer
func (mmInsertMailboxV1 *ImapConcentratorServerMock) InsertMailboxV1(ctx context.Context, ip1 *InsertMailboxV1Request) (ap1 *Ack, err error) {
	mm_atomic.AddUint64(&mmInsertMailboxV1.beforeInsertMailboxV1Counter, 1)
	defer mm_atomic.AddUint64(&mmInsertMailboxV1.afterInsertMailboxV1Counter, 1)

	if mmInsertMailboxV1.inspectFuncInsertMailboxV1 != nil {
		mmInsertMailboxV1.inspectFuncInsertMailboxV1(ctx, ip1)
	}

	mm_params := &ImapConcentratorServerMockInsertMailboxV1Params{ctx, ip1}

	// Record call args
	mmInsertMailboxV1.InsertMailboxV1Mock.mutex.Lock()
	mmInsertMailboxV1.InsertMailboxV1Mock.callArgs = append(mmInsertMailboxV1.InsertMailboxV1Mock.callArgs, mm_params)
	mmInsertMailboxV1.InsertMailboxV1Mock.mutex.Unlock()

	for _, e := range mmInsertMailboxV1.InsertMailboxV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmInsertMailboxV1.InsertMailboxV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertMailboxV1.InsertMailboxV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmInsertMailboxV1.InsertMailboxV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorServerMockInsertMailboxV1Params{ctx, ip1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertMailboxV1.t.Errorf("ImapConcentratorServerMock.InsertMailboxV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertMailboxV1.InsertMailboxV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmInsertMailboxV1.t.Fatal("No results are set for the ImapConcentratorServerMock.InsertMailboxV1")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmInsertMailboxV1.funcInsertMailboxV1 != nil {
		return mmInsertMailboxV1.funcInsertMailboxV1(ctx, ip1)
	}
	mmInsertMailboxV1.t.Fatalf("Unexpected call to ImapConcentratorServerMock.InsertMailboxV1. %v %v", ctx, ip1)
	return
}

// InsertMailboxV1AfterCounter returns a count of finished ImapConcentratorServerMock.InsertMailboxV1 invocations
func (mmInsertMailboxV1 *ImapConcentratorServerMock) InsertMailboxV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertMailboxV1.afterInsertMailboxV1Counter)
}

// InsertMailboxV1BeforeCounter returns a count of ImapConcentratorServerMock.InsertMailboxV1 invocations
func (mmInsertMailboxV1 *ImapConcentratorServerMock) InsertMailboxV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertMailboxV1.beforeInsertMailboxV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorServerMock.InsertMailboxV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertMailboxV1 *mImapConcentratorServerMockInsertMailboxV1) Calls() []*ImapConcentratorServerMockInsertMailboxV1Params {
	mmInsertMailboxV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorServerMockInsertMailboxV1Params, len(mmInsertMailboxV1.callArgs))
	copy(argCopy, mmInsertMailboxV1.callArgs)

	mmInsertMailboxV1.mutex.RUnlock()

	return argCopy
}

// MinimockInsertMailboxV1Done returns true if the count of the InsertMailboxV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorServerMock) MinimockInsertMailboxV1Done() bool {
	for _, e := range m.InsertMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertMailboxV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterInsertMailboxV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockInsertMailboxV1Inspect logs each unmet expectation
func (m *ImapConcentratorServerMock) MinimockInsertMailboxV1Inspect() {
	for _, e := range m.InsertMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.InsertMailboxV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertMailboxV1Counter) < 1 {
		if m.InsertMailboxV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorServerMock.InsertMailboxV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.InsertMailboxV1 with params: %#v", *m.InsertMailboxV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterInsertMailboxV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.InsertMailboxV1")
	}
}

type mImapConcentratorServerMockListMailboxesV1 struct {
	mock               *ImapConcentratorServerMock
	defaultExpectation *ImapConcentratorServerMockListMailboxesV1Expectation
	expectations       []*ImapConcentratorServerMockListMailboxesV1Expectation

	callArgs []*ImapConcentratorServerMockListMailboxesV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorServerMockListMailboxesV1Expectation specifies expectation struct of the ImapConcentratorServer.ListMailboxesV1
type ImapConcentratorServerMockListMailboxesV1Expectation struct {
	mock    *ImapConcentratorServerMock
	params  *ImapConcentratorServerMockListMailboxesV1Params
	results *ImapConcentratorServerMockListMailboxesV1Results
	Counter uint64
}

// ImapConcentratorServerMockListMailboxesV1Params contains parameters of the ImapConcentratorServer.ListMailboxesV1
type ImapConcentratorServerMockListMailboxesV1Params struct {
	ctx context.Context
	lp1 *ListMailboxesV1Request
}

// ImapConcentratorServerMockListMailboxesV1Results contains results of the ImapConcentratorServer.ListMailboxesV1
type ImapConcentratorServerMockListMailboxesV1Results struct {
	lp2 *ListMailboxesV1Response
	err error
}

// Expect sets up expected params for ImapConcentratorServer.ListMailboxesV1
func (mmListMailboxesV1 *mImapConcentratorServerMockListMailboxesV1) Expect(ctx context.Context, lp1 *ListMailboxesV1Request) *mImapConcentratorServerMockListMailboxesV1 {
	if mmListMailboxesV1.mock.funcListMailboxesV1 != nil {
		mmListMailboxesV1.mock.t.Fatalf("ImapConcentratorServerMock.ListMailboxesV1 mock is already set by Set")
	}

	if mmListMailboxesV1.defaultExpectation == nil {
		mmListMailboxesV1.defaultExpectation = &ImapConcentratorServerMockListMailboxesV1Expectation{}
	}

	mmListMailboxesV1.defaultExpectation.params = &ImapConcentratorServerMockListMailboxesV1Params{ctx, lp1}
	for _, e := range mmListMailboxesV1.expectations {
		if minimock.Equal(e.params, mmListMailboxesV1.defaultExpectation.params) {
			mmListMailboxesV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListMailboxesV1.defaultExpectation.params)
		}
	}

	return mmListMailboxesV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorServer.ListMailboxesV1
func (mmListMailboxesV1 *mImapConcentratorServerMockListMailboxesV1) Inspect(f func(ctx context.Context, lp1 *ListMailboxesV1Request)) *mImapConcentratorServerMockListMailboxesV1 {
	if mmListMailboxesV1.mock.inspectFuncListMailboxesV1 != nil {
		mmListMailboxesV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorServerMock.ListMailboxesV1")
	}

	mmListMailboxesV1.mock.inspectFuncListMailboxesV1 = f

	return mmListMailboxesV1
}

// Return sets up results that will be returned by ImapConcentratorServer.ListMailboxesV1
func (mmListMailboxesV1 *mImapConcentratorServerMockListMailboxesV1) Return(lp2 *ListMailboxesV1Response, err error) *ImapConcentratorServerMock {
	if mmListMailboxesV1.mock.funcListMailboxesV1 != nil {
		mmListMailboxesV1.mock.t.Fatalf("ImapConcentratorServerMock.ListMailboxesV1 mock is already set by Set")
	}

	if mmListMailboxesV1.defaultExpectation == nil {
		mmListMailboxesV1.defaultExpectation = &ImapConcentratorServerMockListMailboxesV1Expectation{mock: mmListMailboxesV1.mock}
	}
	mmListMailboxesV1.defaultExpectation.results = &ImapConcentratorServerMockListMailboxesV1Results{lp2, err}
	return mmListMailboxesV1.mock
}

//Set uses given function f to mock the ImapConcentratorServer.ListMailboxesV1 method
func (mmListMailboxesV1 *mImapConcentratorServerMockListMailboxesV1) Set(f func(ctx context.Context, lp1 *ListMailboxesV1Request) (lp2 *ListMailboxesV1Response, err error)) *ImapConcentratorServerMock {
	if mmListMailboxesV1.defaultExpectation != nil {
		mmListMailboxesV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorServer.ListMailboxesV1 method")
	}

	if len(mmListMailboxesV1.expectations) > 0 {
		mmListMailboxesV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorServer.ListMailboxesV1 method")
	}

	mmListMailboxesV1.mock.funcListMailboxesV1 = f
	return mmListMailboxesV1.mock
}

// When sets expectation for the ImapConcentratorServer.ListMailboxesV1 which will trigger the result defined by the following
// Then helper
func (mmListMailboxesV1 *mImapConcentratorServerMockListMailboxesV1) When(ctx context.Context, lp1 *ListMailboxesV1Request) *ImapConcentratorServerMockListMailboxesV1Expectation {
	if mmListMailboxesV1.mock.funcListMailboxesV1 != nil {
		mmListMailboxesV1.mock.t.Fatalf("ImapConcentratorServerMock.ListMailboxesV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorServerMockListMailboxesV1Expectation{
		mock:   mmListMailboxesV1.mock,
		params: &ImapConcentratorServerMockListMailboxesV1Params{ctx, lp1},
	}
	mmListMailboxesV1.expectations = append(mmListMailboxesV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorServer.ListMailboxesV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorServerMockListMailboxesV1Expectation) Then(lp2 *ListMailboxesV1Response, err error) *ImapConcentratorServerMock {
	e.results = &ImapConcentratorServerMockListMailboxesV1Results{lp2, err}
	return e.mock
}

// ListMailboxesV1 implements ImapConcentratorServer
func (mmListMailboxesV1 *ImapConcentratorServerMock) ListMailboxesV1(ctx context.Context, lp1 *ListMailboxesV1Request) (lp2 *ListMailboxesV1Response, err error) {
	mm_atomic.AddUint64(&mmListMailboxesV1.beforeListMailboxesV1Counter, 1)
	defer mm_atomic.AddUint64(&mmListMailboxesV1.afterListMailboxesV1Counter, 1)

	if mmListMailboxesV1.inspectFuncListMailboxesV1 != nil {
		mmListMailboxesV1.inspectFuncListMailboxesV1(ctx, lp1)
	}

	mm_params := &ImapConcentratorServerMockListMailboxesV1Params{ctx, lp1}

	// Record call args
	mmListMailboxesV1.ListMailboxesV1Mock.mutex.Lock()
	mmListMailboxesV1.ListMailboxesV1Mock.callArgs = append(mmListMailboxesV1.ListMailboxesV1Mock.callArgs, mm_params)
	mmListMailboxesV1.ListMailboxesV1Mock.mutex.Unlock()

	for _, e := range mmListMailboxesV1.ListMailboxesV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp2, e.results.err
		}
	}

	if mmListMailboxesV1.ListMailboxesV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListMailboxesV1.ListMailboxesV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmListMailboxesV1.ListMailboxesV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorServerMockListMailboxesV1Params{ctx, lp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListMailboxesV1.t.Errorf("ImapConcentratorServerMock.ListMailboxesV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListMailboxesV1.ListMailboxesV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmListMailboxesV1.t.Fatal("No results are set for the ImapConcentratorServerMock.ListMailboxesV1")
		}
		return (*mm_results).lp2, (*mm_results).err
	}
	if mmListMailboxesV1.funcListMailboxesV1 != nil {
		return mmListMailboxesV1.funcListMailboxesV1(ctx, lp1)
	}
	mmListMailboxesV1.t.Fatalf("Unexpected call to ImapConcentratorServerMock.ListMailboxesV1. %v %v", ctx, lp1)
	return
}

// ListMailboxesV1AfterCounter returns a count of finished ImapConcentratorServerMock.ListMailboxesV1 invocations
func (mmListMailboxesV1 *ImapConcentratorServerMock) ListMailboxesV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListMailboxesV1.afterListMailboxesV1Counter)
}

// ListMailboxesV1BeforeCounter returns a count of ImapConcentratorServerMock.ListMailboxesV1 invocations
func (mmListMailboxesV1 *ImapConcentratorServerMock) ListMailboxesV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListMailboxesV1.beforeListMailboxesV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorServerMock.ListMailboxesV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListMailboxesV1 *mImapConcentratorServerMockListMailboxesV1) Calls() []*ImapConcentratorServerMockListMailboxesV1Params {
	mmListMailboxesV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorServerMockListMailboxesV1Params, len(mmListMailboxesV1.callArgs))
	copy(argCopy, mmListMailboxesV1.callArgs)

	mmListMailboxesV1.mutex.RUnlock()

	return argCopy
}

// MinimockListMailboxesV1Done returns true if the count of the ListMailboxesV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorServerMock) MinimockListMailboxesV1Done() bool {
	for _, e := range m.ListMailboxesV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMailboxesV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListMailboxesV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListMailboxesV1 != nil && mm_atomic.LoadUint64(&m.afterListMailboxesV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockListMailboxesV1Inspect logs each unmet expectation
func (m *ImapConcentratorServerMock) MinimockListMailboxesV1Inspect() {
	for _, e := range m.ListMailboxesV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.ListMailboxesV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMailboxesV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListMailboxesV1Counter) < 1 {
		if m.ListMailboxesV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorServerMock.ListMailboxesV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.ListMailboxesV1 with params: %#v", *m.ListMailboxesV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListMailboxesV1 != nil && mm_atomic.LoadUint64(&m.afterListMailboxesV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.ListMailboxesV1")
	}
}

type mImapConcentratorServerMockPollV1 struct {
	mock               *ImapConcentratorServerMock
	defaultExpectation *ImapConcentratorServerMockPollV1Expectation
	expectations       []*ImapConcentratorServerMockPollV1Expectation

	callArgs []*ImapConcentratorServerMockPollV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorServerMockPollV1Expectation specifies expectation struct of the ImapConcentratorServer.PollV1
type ImapConcentratorServerMockPollV1Expectation struct {
	mock    *ImapConcentratorServerMock
	params  *ImapConcentratorServerMockPollV1Params
	results *ImapConcentratorServerMockPollV1Results
	Counter uint64
}

// ImapConcentratorServerMockPollV1Params contains parameters of the ImapConcentratorServer.PollV1
type ImapConcentratorServerMockPollV1Params struct {
	ctx context.Context
	pp1 *PollV1Request
}

// ImapConcentratorServerMockPollV1Results contains results of the ImapConcentratorServer.PollV1
type ImapConcentratorServerMockPollV1Results struct {
	ap1 *Ack
	err error
}

// Expect sets up expected params for ImapConcentratorServer.PollV1
func (mmPollV1 *mImapConcentratorServerMockPollV1) Expect(ctx context.Context, pp1 *PollV1Request) *mImapConcentratorServerMockPollV1 {
	if mmPollV1.mock.funcPollV1 != nil {
		mmPollV1.mock.t.Fatalf("ImapConcentratorServerMock.PollV1 mock is already set by Set")
	}

	if mmPollV1.defaultExpectation == nil {
		mmPollV1.defaultExpectation = &ImapConcentratorServerMockPollV1Expectation{}
	}

	mmPollV1.defaultExpectation.params = &ImapConcentratorServerMockPollV1Params{ctx, pp1}
	for _, e := range mmPollV1.expectations {
		if minimock.Equal(e.params, mmPollV1.defaultExpectation.params) {
			mmPollV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPollV1.defaultExpectation.params)
		}
	}

	return mmPollV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorServer.PollV1
func (mmPollV1 *mImapConcentratorServerMockPollV1) Inspect(f func(ctx context.Context, pp1 *PollV1Request)) *mImapConcentratorServerMockPollV1 {
	if mmPollV1.mock.inspectFuncPollV1 != nil {
		mmPollV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorServerMock.PollV1")
	}

	mmPollV1.mock.inspectFuncPollV1 = f

	return mmPollV1
}

// Return sets up results that will be returned by ImapConcentratorServer.PollV1
func (mmPollV1 *mImapConcentratorServerMockPollV1) Return(ap1 *Ack, err error) *ImapConcentratorServerMock {
	if mmPollV1.mock.funcPollV1 != nil {
		mmPollV1.mock.t.Fatalf("ImapConcentratorServerMock.PollV1 mock is already set by Set")
	}

	if mmPollV1.defaultExpectation == nil {
		mmPollV1.defaultExpectation = &ImapConcentratorServerMockPollV1Expectation{mock: mmPollV1.mock}
	}
	mmPollV1.defaultExpectation.results = &ImapConcentratorServerMockPollV1Results{ap1, err}
	return mmPollV1.mock
}

//Set uses given function f to mock the ImapConcentratorServer.PollV1 method
func (mmPollV1 *mImapConcentratorServerMockPollV1) Set(f func(ctx context.Context, pp1 *PollV1Request) (ap1 *Ack, err error)) *ImapConcentratorServerMock {
	if mmPollV1.defaultExpectation != nil {
		mmPollV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorServer.PollV1 method")
	}

	if len(mmPollV1.expectations) > 0 {
		mmPollV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorServer.PollV1 method")
	}

	mmPollV1.mock.funcPollV1 = f
	return mmPollV1.mock
}

// When sets expectation for the ImapConcentratorServer.PollV1 which will trigger the result defined by the following
// Then helper
func (mmPollV1 *mImapConcentratorServerMockPollV1) When(ctx context.Context, pp1 *PollV1Request) *ImapConcentratorServerMockPollV1Expectation {
	if mmPollV1.mock.funcPollV1 != nil {
		mmPollV1.mock.t.Fatalf("ImapConcentratorServerMock.PollV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorServerMockPollV1Expectation{
		mock:   mmPollV1.mock,
		params: &ImapConcentratorServerMockPollV1Params{ctx, pp1},
	}
	mmPollV1.expectations = append(mmPollV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorServer.PollV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorServerMockPollV1Expectation) Then(ap1 *Ack, err error) *ImapConcentratorServerMock {
	e.results = &ImapConcentratorServerMockPollV1Results{ap1, err}
	return e.mock
}

// PollV1 implements ImapConcentratorServer
func (mmPollV1 *ImapConcentratorServerMock) PollV1(ctx context.Context, pp1 *PollV1Request) (ap1 *Ack, err error) {
	mm_atomic.AddUint64(&mmPollV1.beforePollV1Counter, 1)
	defer mm_atomic.AddUint64(&mmPollV1.afterPollV1Counter, 1)

	if mmPollV1.inspectFuncPollV1 != nil {
		mmPollV1.inspectFuncPollV1(ctx, pp1)
	}

	mm_params := &ImapConcentratorServerMockPollV1Params{ctx, pp1}

	// Record call args
	mmPollV1.PollV1Mock.mutex.Lock()
	mmPollV1.PollV1Mock.callArgs = append(mmPollV1.PollV1Mock.callArgs, mm_params)
	mmPollV1.PollV1Mock.mutex.Unlock()

	for _, e := range mmPollV1.PollV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmPollV1.PollV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPollV1.PollV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmPollV1.PollV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorServerMockPollV1Params{ctx, pp1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPollV1.t.Errorf("ImapConcentratorServerMock.PollV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPollV1.PollV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmPollV1.t.Fatal("No results are set for the ImapConcentratorServerMock.PollV1")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmPollV1.funcPollV1 != nil {
		return mmPollV1.funcPollV1(ctx, pp1)
	}
	mmPollV1.t.Fatalf("Unexpected call to ImapConcentratorServerMock.PollV1. %v %v", ctx, pp1)
	return
}

// PollV1AfterCounter returns a count of finished ImapConcentratorServerMock.PollV1 invocations
func (mmPollV1 *ImapConcentratorServerMock) PollV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPollV1.afterPollV1Counter)
}

// PollV1BeforeCounter returns a count of ImapConcentratorServerMock.PollV1 invocations
func (mmPollV1 *ImapConcentratorServerMock) PollV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPollV1.beforePollV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorServerMock.PollV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPollV1 *mImapConcentratorServerMockPollV1) Calls() []*ImapConcentratorServerMockPollV1Params {
	mmPollV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorServerMockPollV1Params, len(mmPollV1.callArgs))
	copy(argCopy, mmPollV1.callArgs)

	mmPollV1.mutex.RUnlock()

	return argCopy
}

// MinimockPollV1Done returns true if the count of the PollV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorServerMock) MinimockPollV1Done() bool {
	for _, e := range m.PollV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PollV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPollV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPollV1 != nil && mm_atomic.LoadUint64(&m.afterPollV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockPollV1Inspect logs each unmet expectation
func (m *ImapConcentratorServerMock) MinimockPollV1Inspect() {
	for _, e := range m.PollV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.PollV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PollV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPollV1Counter) < 1 {
		if m.PollV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorServerMock.PollV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.PollV1 with params: %#v", *m.PollV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPollV1 != nil && mm_atomic.LoadUint64(&m.afterPollV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.PollV1")
	}
}

type mImapConcentratorServerMockSubscribeToAllNotificationsV1 struct {
	mock               *ImapConcentratorServerMock
	defaultExpectation *ImapConcentratorServerMockSubscribeToAllNotificationsV1Expectation
	expectations       []*ImapConcentratorServerMockSubscribeToAllNotificationsV1Expectation

	callArgs []*ImapConcentratorServerMockSubscribeToAllNotificationsV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorServerMockSubscribeToAllNotificationsV1Expectation specifies expectation struct of the ImapConcentratorServer.SubscribeToAllNotificationsV1
type ImapConcentratorServerMockSubscribeToAllNotificationsV1Expectation struct {
	mock    *ImapConcentratorServerMock
	params  *ImapConcentratorServerMockSubscribeToAllNotificationsV1Params
	results *ImapConcentratorServerMockSubscribeToAllNotificationsV1Results
	Counter uint64
}

// ImapConcentratorServerMockSubscribeToAllNotificationsV1Params contains parameters of the ImapConcentratorServer.SubscribeToAllNotificationsV1
type ImapConcentratorServerMockSubscribeToAllNotificationsV1Params struct {
	sp1 *SubscribeToAllNotificationsV1Request
	i1  ImapConcentrator_SubscribeToAllNotificationsV1Server
}

// ImapConcentratorServerMockSubscribeToAllNotificationsV1Results contains results of the ImapConcentratorServer.SubscribeToAllNotificationsV1
type ImapConcentratorServerMockSubscribeToAllNotificationsV1Results struct {
	err error
}

// Expect sets up expected params for ImapConcentratorServer.SubscribeToAllNotificationsV1
func (mmSubscribeToAllNotificationsV1 *mImapConcentratorServerMockSubscribeToAllNotificationsV1) Expect(sp1 *SubscribeToAllNotificationsV1Request, i1 ImapConcentrator_SubscribeToAllNotificationsV1Server) *mImapConcentratorServerMockSubscribeToAllNotificationsV1 {
	if mmSubscribeToAllNotificationsV1.mock.funcSubscribeToAllNotificationsV1 != nil {
		mmSubscribeToAllNotificationsV1.mock.t.Fatalf("ImapConcentratorServerMock.SubscribeToAllNotificationsV1 mock is already set by Set")
	}

	if mmSubscribeToAllNotificationsV1.defaultExpectation == nil {
		mmSubscribeToAllNotificationsV1.defaultExpectation = &ImapConcentratorServerMockSubscribeToAllNotificationsV1Expectation{}
	}

	mmSubscribeToAllNotificationsV1.defaultExpectation.params = &ImapConcentratorServerMockSubscribeToAllNotificationsV1Params{sp1, i1}
	for _, e := range mmSubscribeToAllNotificationsV1.expectations {
		if minimock.Equal(e.params, mmSubscribeToAllNotificationsV1.defaultExpectation.params) {
			mmSubscribeToAllNotificationsV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubscribeToAllNotificationsV1.defaultExpectation.params)
		}
	}

	return mmSubscribeToAllNotificationsV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorServer.SubscribeToAllNotificationsV1
func (mmSubscribeToAllNotificationsV1 *mImapConcentratorServerMockSubscribeToAllNotificationsV1) Inspect(f func(sp1 *SubscribeToAllNotificationsV1Request, i1 ImapConcentrator_SubscribeToAllNotificationsV1Server)) *mImapConcentratorServerMockSubscribeToAllNotificationsV1 {
	if mmSubscribeToAllNotificationsV1.mock.inspectFuncSubscribeToAllNotificationsV1 != nil {
		mmSubscribeToAllNotificationsV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorServerMock.SubscribeToAllNotificationsV1")
	}

	mmSubscribeToAllNotificationsV1.mock.inspectFuncSubscribeToAllNotificationsV1 = f

	return mmSubscribeToAllNotificationsV1
}

// Return sets up results that will be returned by ImapConcentratorServer.SubscribeToAllNotificationsV1
func (mmSubscribeToAllNotificationsV1 *mImapConcentratorServerMockSubscribeToAllNotificationsV1) Return(err error) *ImapConcentratorServerMock {
	if mmSubscribeToAllNotificationsV1.mock.funcSubscribeToAllNotificationsV1 != nil {
		mmSubscribeToAllNotificationsV1.mock.t.Fatalf("ImapConcentratorServerMock.SubscribeToAllNotificationsV1 mock is already set by Set")
	}

	if mmSubscribeToAllNotificationsV1.defaultExpectation == nil {
		mmSubscribeToAllNotificationsV1.defaultExpectation = &ImapConcentratorServerMockSubscribeToAllNotificationsV1Expectation{mock: mmSubscribeToAllNotificationsV1.mock}
	}
	mmSubscribeToAllNotificationsV1.defaultExpectation.results = &ImapConcentratorServerMockSubscribeToAllNotificationsV1Results{err}
	return mmSubscribeToAllNotificationsV1.mock
}

//Set uses given function f to mock the ImapConcentratorServer.SubscribeToAllNotificationsV1 method
func (mmSubscribeToAllNotificationsV1 *mImapConcentratorServerMockSubscribeToAllNotificationsV1) Set(f func(sp1 *SubscribeToAllNotificationsV1Request, i1 ImapConcentrator_SubscribeToAllNotificationsV1Server) (err error)) *ImapConcentratorServerMock {
	if mmSubscribeToAllNotificationsV1.defaultExpectation != nil {
		mmSubscribeToAllNotificationsV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorServer.SubscribeToAllNotificationsV1 method")
	}

	if len(mmSubscribeToAllNotificationsV1.expectations) > 0 {
		mmSubscribeToAllNotificationsV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorServer.SubscribeToAllNotificationsV1 method")
	}

	mmSubscribeToAllNotificationsV1.mock.funcSubscribeToAllNotificationsV1 = f
	return mmSubscribeToAllNotificationsV1.mock
}

// When sets expectation for the ImapConcentratorServer.SubscribeToAllNotificationsV1 which will trigger the result defined by the following
// Then helper
func (mmSubscribeToAllNotificationsV1 *mImapConcentratorServerMockSubscribeToAllNotificationsV1) When(sp1 *SubscribeToAllNotificationsV1Request, i1 ImapConcentrator_SubscribeToAllNotificationsV1Server) *ImapConcentratorServerMockSubscribeToAllNotificationsV1Expectation {
	if mmSubscribeToAllNotificationsV1.mock.funcSubscribeToAllNotificationsV1 != nil {
		mmSubscribeToAllNotificationsV1.mock.t.Fatalf("ImapConcentratorServerMock.SubscribeToAllNotificationsV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorServerMockSubscribeToAllNotificationsV1Expectation{
		mock:   mmSubscribeToAllNotificationsV1.mock,
		params: &ImapConcentratorServerMockSubscribeToAllNotificationsV1Params{sp1, i1},
	}
	mmSubscribeToAllNotificationsV1.expectations = append(mmSubscribeToAllNotificationsV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorServer.SubscribeToAllNotificationsV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorServerMockSubscribeToAllNotificationsV1Expectation) Then(err error) *ImapConcentratorServerMock {
	e.results = &ImapConcentratorServerMockSubscribeToAllNotificationsV1Results{err}
	return e.mock
}

// SubscribeToAllNotificationsV1 implements ImapConcentratorServer
func (mmSubscribeToAllNotificationsV1 *ImapConcentratorServerMock) SubscribeToAllNotificationsV1(sp1 *SubscribeToAllNotificationsV1Request, i1 ImapConcentrator_SubscribeToAllNotificationsV1Server) (err error) {
	mm_atomic.AddUint64(&mmSubscribeToAllNotificationsV1.beforeSubscribeToAllNotificationsV1Counter, 1)
	defer mm_atomic.AddUint64(&mmSubscribeToAllNotificationsV1.afterSubscribeToAllNotificationsV1Counter, 1)

	if mmSubscribeToAllNotificationsV1.inspectFuncSubscribeToAllNotificationsV1 != nil {
		mmSubscribeToAllNotificationsV1.inspectFuncSubscribeToAllNotificationsV1(sp1, i1)
	}

	mm_params := &ImapConcentratorServerMockSubscribeToAllNotificationsV1Params{sp1, i1}

	// Record call args
	mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.mutex.Lock()
	mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.callArgs = append(mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.callArgs, mm_params)
	mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.mutex.Unlock()

	for _, e := range mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorServerMockSubscribeToAllNotificationsV1Params{sp1, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubscribeToAllNotificationsV1.t.Errorf("ImapConcentratorServerMock.SubscribeToAllNotificationsV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmSubscribeToAllNotificationsV1.t.Fatal("No results are set for the ImapConcentratorServerMock.SubscribeToAllNotificationsV1")
		}
		return (*mm_results).err
	}
	if mmSubscribeToAllNotificationsV1.funcSubscribeToAllNotificationsV1 != nil {
		return mmSubscribeToAllNotificationsV1.funcSubscribeToAllNotificationsV1(sp1, i1)
	}
	mmSubscribeToAllNotificationsV1.t.Fatalf("Unexpected call to ImapConcentratorServerMock.SubscribeToAllNotificationsV1. %v %v", sp1, i1)
	return
}

// SubscribeToAllNotificationsV1AfterCounter returns a count of finished ImapConcentratorServerMock.SubscribeToAllNotificationsV1 invocations
func (mmSubscribeToAllNotificationsV1 *ImapConcentratorServerMock) SubscribeToAllNotificationsV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribeToAllNotificationsV1.afterSubscribeToAllNotificationsV1Counter)
}

// SubscribeToAllNotificationsV1BeforeCounter returns a count of ImapConcentratorServerMock.SubscribeToAllNotificationsV1 invocations
func (mmSubscribeToAllNotificationsV1 *ImapConcentratorServerMock) SubscribeToAllNotificationsV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribeToAllNotificationsV1.beforeSubscribeToAllNotificationsV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorServerMock.SubscribeToAllNotificationsV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubscribeToAllNotificationsV1 *mImapConcentratorServerMockSubscribeToAllNotificationsV1) Calls() []*ImapConcentratorServerMockSubscribeToAllNotificationsV1Params {
	mmSubscribeToAllNotificationsV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorServerMockSubscribeToAllNotificationsV1Params, len(mmSubscribeToAllNotificationsV1.callArgs))
	copy(argCopy, mmSubscribeToAllNotificationsV1.callArgs)

	mmSubscribeToAllNotificationsV1.mutex.RUnlock()

	return argCopy
}

// MinimockSubscribeToAllNotificationsV1Done returns true if the count of the SubscribeToAllNotificationsV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorServerMock) MinimockSubscribeToAllNotificationsV1Done() bool {
	for _, e := range m.SubscribeToAllNotificationsV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeToAllNotificationsV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeToAllNotificationsV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribeToAllNotificationsV1 != nil && mm_atomic.LoadUint64(&m.afterSubscribeToAllNotificationsV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockSubscribeToAllNotificationsV1Inspect logs each unmet expectation
func (m *ImapConcentratorServerMock) MinimockSubscribeToAllNotificationsV1Inspect() {
	for _, e := range m.SubscribeToAllNotificationsV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.SubscribeToAllNotificationsV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeToAllNotificationsV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeToAllNotificationsV1Counter) < 1 {
		if m.SubscribeToAllNotificationsV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorServerMock.SubscribeToAllNotificationsV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.SubscribeToAllNotificationsV1 with params: %#v", *m.SubscribeToAllNotificationsV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribeToAllNotificationsV1 != nil && mm_atomic.LoadUint64(&m.afterSubscribeToAllNotificationsV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.SubscribeToAllNotificationsV1")
	}
}

type mImapConcentratorServerMockSubscribeToChatNotificationsV1 struct {
	mock               *ImapConcentratorServerMock
	defaultExpectation *ImapConcentratorServerMockSubscribeToChatNotificationsV1Expectation
	expectations       []*ImapConcentratorServerMockSubscribeToChatNotificationsV1Expectation

	callArgs []*ImapConcentratorServerMockSubscribeToChatNotificationsV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorServerMockSubscribeToChatNotificationsV1Expectation specifies expectation struct of the ImapConcentratorServer.SubscribeToChatNotificationsV1
type ImapConcentratorServerMockSubscribeToChatNotificationsV1Expectation struct {
	mock    *ImapConcentratorServerMock
	params  *ImapConcentratorServerMockSubscribeToChatNotificationsV1Params
	results *ImapConcentratorServerMockSubscribeToChatNotificationsV1Results
	Counter uint64
}

// ImapConcentratorServerMockSubscribeToChatNotificationsV1Params contains parameters of the ImapConcentratorServer.SubscribeToChatNotificationsV1
type ImapConcentratorServerMockSubscribeToChatNotificationsV1Params struct {
	sp1 *SubscribeToChatNotificationsV1Request
	i1  ImapConcentrator_SubscribeToChatNotificationsV1Server
}

// ImapConcentratorServerMockSubscribeToChatNotificationsV1Results contains results of the ImapConcentratorServer.SubscribeToChatNotificationsV1
type ImapConcentratorServerMockSubscribeToChatNotificationsV1Results struct {
	err error
}

// Expect sets up expected params for ImapConcentratorServer.SubscribeToChatNotificationsV1
func (mmSubscribeToChatNotificationsV1 *mImapConcentratorServerMockSubscribeToChatNotificationsV1) Expect(sp1 *SubscribeToChatNotificationsV1Request, i1 ImapConcentrator_SubscribeToChatNotificationsV1Server) *mImapConcentratorServerMockSubscribeToChatNotificationsV1 {
	if mmSubscribeToChatNotificationsV1.mock.funcSubscribeToChatNotificationsV1 != nil {
		mmSubscribeToChatNotificationsV1.mock.t.Fatalf("ImapConcentratorServerMock.SubscribeToChatNotificationsV1 mock is already set by Set")
	}

	if mmSubscribeToChatNotificationsV1.defaultExpectation == nil {
		mmSubscribeToChatNotificationsV1.defaultExpectation = &ImapConcentratorServerMockSubscribeToChatNotificationsV1Expectation{}
	}

	mmSubscribeToChatNotificationsV1.defaultExpectation.params = &ImapConcentratorServerMockSubscribeToChatNotificationsV1Params{sp1, i1}
	for _, e := range mmSubscribeToChatNotificationsV1.expectations {
		if minimock.Equal(e.params, mmSubscribeToChatNotificationsV1.defaultExpectation.params) {
			mmSubscribeToChatNotificationsV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubscribeToChatNotificationsV1.defaultExpectation.params)
		}
	}

	return mmSubscribeToChatNotificationsV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorServer.SubscribeToChatNotificationsV1
func (mmSubscribeToChatNotificationsV1 *mImapConcentratorServerMockSubscribeToChatNotificationsV1) Inspect(f func(sp1 *SubscribeToChatNotificationsV1Request, i1 ImapConcentrator_SubscribeToChatNotificationsV1Server)) *mImapConcentratorServerMockSubscribeToChatNotificationsV1 {
	if mmSubscribeToChatNotificationsV1.mock.inspectFuncSubscribeToChatNotificationsV1 != nil {
		mmSubscribeToChatNotificationsV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorServerMock.SubscribeToChatNotificationsV1")
	}

	mmSubscribeToChatNotificationsV1.mock.inspectFuncSubscribeToChatNotificationsV1 = f

	return mmSubscribeToChatNotificationsV1
}

// Return sets up results that will be returned by ImapConcentratorServer.SubscribeToChatNotificationsV1
func (mmSubscribeToChatNotificationsV1 *mImapConcentratorServerMockSubscribeToChatNotificationsV1) Return(err error) *ImapConcentratorServerMock {
	if mmSubscribeToChatNotificationsV1.mock.funcSubscribeToChatNotificationsV1 != nil {
		mmSubscribeToChatNotificationsV1.mock.t.Fatalf("ImapConcentratorServerMock.SubscribeToChatNotificationsV1 mock is already set by Set")
	}

	if mmSubscribeToChatNotificationsV1.defaultExpectation == nil {
		mmSubscribeToChatNotificationsV1.defaultExpectation = &ImapConcentratorServerMockSubscribeToChatNotificationsV1Expectation{mock: mmSubscribeToChatNotificationsV1.mock}
	}
	mmSubscribeToChatNotificationsV1.defaultExpectation.results = &ImapConcentratorServerMockSubscribeToChatNotificationsV1Results{err}
	return mmSubscribeToChatNotificationsV1.mock
}

//Set uses given function f to mock the ImapConcentratorServer.SubscribeToChatNotificationsV1 method
func (mmSubscribeToChatNotificationsV1 *mImapConcentratorServerMockSubscribeToChatNotificationsV1) Set(f func(sp1 *SubscribeToChatNotificationsV1Request, i1 ImapConcentrator_SubscribeToChatNotificationsV1Server) (err error)) *ImapConcentratorServerMock {
	if mmSubscribeToChatNotificationsV1.defaultExpectation != nil {
		mmSubscribeToChatNotificationsV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorServer.SubscribeToChatNotificationsV1 method")
	}

	if len(mmSubscribeToChatNotificationsV1.expectations) > 0 {
		mmSubscribeToChatNotificationsV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorServer.SubscribeToChatNotificationsV1 method")
	}

	mmSubscribeToChatNotificationsV1.mock.funcSubscribeToChatNotificationsV1 = f
	return mmSubscribeToChatNotificationsV1.mock
}

// When sets expectation for the ImapConcentratorServer.SubscribeToChatNotificationsV1 which will trigger the result defined by the following
// Then helper
func (mmSubscribeToChatNotificationsV1 *mImapConcentratorServerMockSubscribeToChatNotificationsV1) When(sp1 *SubscribeToChatNotificationsV1Request, i1 ImapConcentrator_SubscribeToChatNotificationsV1Server) *ImapConcentratorServerMockSubscribeToChatNotificationsV1Expectation {
	if mmSubscribeToChatNotificationsV1.mock.funcSubscribeToChatNotificationsV1 != nil {
		mmSubscribeToChatNotificationsV1.mock.t.Fatalf("ImapConcentratorServerMock.SubscribeToChatNotificationsV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorServerMockSubscribeToChatNotificationsV1Expectation{
		mock:   mmSubscribeToChatNotificationsV1.mock,
		params: &ImapConcentratorServerMockSubscribeToChatNotificationsV1Params{sp1, i1},
	}
	mmSubscribeToChatNotificationsV1.expectations = append(mmSubscribeToChatNotificationsV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorServer.SubscribeToChatNotificationsV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorServerMockSubscribeToChatNotificationsV1Expectation) Then(err error) *ImapConcentratorServerMock {
	e.results = &ImapConcentratorServerMockSubscribeToChatNotificationsV1Results{err}
	return e.mock
}

// SubscribeToChatNotificationsV1 implements ImapConcentratorServer
func (mmSubscribeToChatNotificationsV1 *ImapConcentratorServerMock) SubscribeToChatNotificationsV1(sp1 *SubscribeToChatNotificationsV1Request, i1 ImapConcentrator_SubscribeToChatNotificationsV1Server) (err error) {
	mm_atomic.AddUint64(&mmSubscribeToChatNotificationsV1.beforeSubscribeToChatNotificationsV1Counter, 1)
	defer mm_atomic.AddUint64(&mmSubscribeToChatNotificationsV1.afterSubscribeToChatNotificationsV1Counter, 1)

	if mmSubscribeToChatNotificationsV1.inspectFuncSubscribeToChatNotificationsV1 != nil {
		mmSubscribeToChatNotificationsV1.inspectFuncSubscribeToChatNotificationsV1(sp1, i1)
	}

	mm_params := &ImapConcentratorServerMockSubscribeToChatNotificationsV1Params{sp1, i1}

	// Record call args
	mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.mutex.Lock()
	mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.callArgs = append(mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.callArgs, mm_params)
	mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.mutex.Unlock()

	for _, e := range mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorServerMockSubscribeToChatNotificationsV1Params{sp1, i1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubscribeToChatNotificationsV1.t.Errorf("ImapConcentratorServerMock.SubscribeToChatNotificationsV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmSubscribeToChatNotificationsV1.t.Fatal("No results are set for the ImapConcentratorServerMock.SubscribeToChatNotificationsV1")
		}
		return (*mm_results).err
	}
	if mmSubscribeToChatNotificationsV1.funcSubscribeToChatNotificationsV1 != nil {
		return mmSubscribeToChatNotificationsV1.funcSubscribeToChatNotificationsV1(sp1, i1)
	}
	mmSubscribeToChatNotificationsV1.t.Fatalf("Unexpected call to ImapConcentratorServerMock.SubscribeToChatNotificationsV1. %v %v", sp1, i1)
	return
}

// SubscribeToChatNotificationsV1AfterCounter returns a count of finished ImapConcentratorServerMock.SubscribeToChatNotificationsV1 invocations
func (mmSubscribeToChatNotificationsV1 *ImapConcentratorServerMock) SubscribeToChatNotificationsV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribeToChatNotificationsV1.afterSubscribeToChatNotificationsV1Counter)
}

// SubscribeToChatNotificationsV1BeforeCounter returns a count of ImapConcentratorServerMock.SubscribeToChatNotificationsV1 invocations
func (mmSubscribeToChatNotificationsV1 *ImapConcentratorServerMock) SubscribeToChatNotificationsV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribeToChatNotificationsV1.beforeSubscribeToChatNotificationsV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorServerMock.SubscribeToChatNotificationsV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubscribeToChatNotificationsV1 *mImapConcentratorServerMockSubscribeToChatNotificationsV1) Calls() []*ImapConcentratorServerMockSubscribeToChatNotificationsV1Params {
	mmSubscribeToChatNotificationsV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorServerMockSubscribeToChatNotificationsV1Params, len(mmSubscribeToChatNotificationsV1.callArgs))
	copy(argCopy, mmSubscribeToChatNotificationsV1.callArgs)

	mmSubscribeToChatNotificationsV1.mutex.RUnlock()

	return argCopy
}

// MinimockSubscribeToChatNotificationsV1Done returns true if the count of the SubscribeToChatNotificationsV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorServerMock) MinimockSubscribeToChatNotificationsV1Done() bool {
	for _, e := range m.SubscribeToChatNotificationsV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeToChatNotificationsV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeToChatNotificationsV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribeToChatNotificationsV1 != nil && mm_atomic.LoadUint64(&m.afterSubscribeToChatNotificationsV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockSubscribeToChatNotificationsV1Inspect logs each unmet expectation
func (m *ImapConcentratorServerMock) MinimockSubscribeToChatNotificationsV1Inspect() {
	for _, e := range m.SubscribeToChatNotificationsV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.SubscribeToChatNotificationsV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeToChatNotificationsV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeToChatNotificationsV1Counter) < 1 {
		if m.SubscribeToChatNotificationsV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorServerMock.SubscribeToChatNotificationsV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.SubscribeToChatNotificationsV1 with params: %#v", *m.SubscribeToChatNotificationsV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribeToChatNotificationsV1 != nil && mm_atomic.LoadUint64(&m.afterSubscribeToChatNotificationsV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.SubscribeToChatNotificationsV1")
	}
}

type mImapConcentratorServerMockUnsubscribeFromNotificationsV1 struct {
	mock               *ImapConcentratorServerMock
	defaultExpectation *ImapConcentratorServerMockUnsubscribeFromNotificationsV1Expectation
	expectations       []*ImapConcentratorServerMockUnsubscribeFromNotificationsV1Expectation

	callArgs []*ImapConcentratorServerMockUnsubscribeFromNotificationsV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorServerMockUnsubscribeFromNotificationsV1Expectation specifies expectation struct of the ImapConcentratorServer.UnsubscribeFromNotificationsV1
type ImapConcentratorServerMockUnsubscribeFromNotificationsV1Expectation struct {
	mock    *ImapConcentratorServerMock
	params  *ImapConcentratorServerMockUnsubscribeFromNotificationsV1Params
	results *ImapConcentratorServerMockUnsubscribeFromNotificationsV1Results
	Counter uint64
}

// ImapConcentratorServerMockUnsubscribeFromNotificationsV1Params contains parameters of the ImapConcentratorServer.UnsubscribeFromNotificationsV1
type ImapConcentratorServerMockUnsubscribeFromNotificationsV1Params struct {
	ctx context.Context
	up1 *UnsubscribeFromNotificationsV1Request
}

// ImapConcentratorServerMockUnsubscribeFromNotificationsV1Results contains results of the ImapConcentratorServer.UnsubscribeFromNotificationsV1
type ImapConcentratorServerMockUnsubscribeFromNotificationsV1Results struct {
	ap1 *Ack
	err error
}

// Expect sets up expected params for ImapConcentratorServer.UnsubscribeFromNotificationsV1
func (mmUnsubscribeFromNotificationsV1 *mImapConcentratorServerMockUnsubscribeFromNotificationsV1) Expect(ctx context.Context, up1 *UnsubscribeFromNotificationsV1Request) *mImapConcentratorServerMockUnsubscribeFromNotificationsV1 {
	if mmUnsubscribeFromNotificationsV1.mock.funcUnsubscribeFromNotificationsV1 != nil {
		mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("ImapConcentratorServerMock.UnsubscribeFromNotificationsV1 mock is already set by Set")
	}

	if mmUnsubscribeFromNotificationsV1.defaultExpectation == nil {
		mmUnsubscribeFromNotificationsV1.defaultExpectation = &ImapConcentratorServerMockUnsubscribeFromNotificationsV1Expectation{}
	}

	mmUnsubscribeFromNotificationsV1.defaultExpectation.params = &ImapConcentratorServerMockUnsubscribeFromNotificationsV1Params{ctx, up1}
	for _, e := range mmUnsubscribeFromNotificationsV1.expectations {
		if minimock.Equal(e.params, mmUnsubscribeFromNotificationsV1.defaultExpectation.params) {
			mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnsubscribeFromNotificationsV1.defaultExpectation.params)
		}
	}

	return mmUnsubscribeFromNotificationsV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorServer.UnsubscribeFromNotificationsV1
func (mmUnsubscribeFromNotificationsV1 *mImapConcentratorServerMockUnsubscribeFromNotificationsV1) Inspect(f func(ctx context.Context, up1 *UnsubscribeFromNotificationsV1Request)) *mImapConcentratorServerMockUnsubscribeFromNotificationsV1 {
	if mmUnsubscribeFromNotificationsV1.mock.inspectFuncUnsubscribeFromNotificationsV1 != nil {
		mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorServerMock.UnsubscribeFromNotificationsV1")
	}

	mmUnsubscribeFromNotificationsV1.mock.inspectFuncUnsubscribeFromNotificationsV1 = f

	return mmUnsubscribeFromNotificationsV1
}

// Return sets up results that will be returned by ImapConcentratorServer.UnsubscribeFromNotificationsV1
func (mmUnsubscribeFromNotificationsV1 *mImapConcentratorServerMockUnsubscribeFromNotificationsV1) Return(ap1 *Ack, err error) *ImapConcentratorServerMock {
	if mmUnsubscribeFromNotificationsV1.mock.funcUnsubscribeFromNotificationsV1 != nil {
		mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("ImapConcentratorServerMock.UnsubscribeFromNotificationsV1 mock is already set by Set")
	}

	if mmUnsubscribeFromNotificationsV1.defaultExpectation == nil {
		mmUnsubscribeFromNotificationsV1.defaultExpectation = &ImapConcentratorServerMockUnsubscribeFromNotificationsV1Expectation{mock: mmUnsubscribeFromNotificationsV1.mock}
	}
	mmUnsubscribeFromNotificationsV1.defaultExpectation.results = &ImapConcentratorServerMockUnsubscribeFromNotificationsV1Results{ap1, err}
	return mmUnsubscribeFromNotificationsV1.mock
}

//Set uses given function f to mock the ImapConcentratorServer.UnsubscribeFromNotificationsV1 method
func (mmUnsubscribeFromNotificationsV1 *mImapConcentratorServerMockUnsubscribeFromNotificationsV1) Set(f func(ctx context.Context, up1 *UnsubscribeFromNotificationsV1Request) (ap1 *Ack, err error)) *ImapConcentratorServerMock {
	if mmUnsubscribeFromNotificationsV1.defaultExpectation != nil {
		mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorServer.UnsubscribeFromNotificationsV1 method")
	}

	if len(mmUnsubscribeFromNotificationsV1.expectations) > 0 {
		mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorServer.UnsubscribeFromNotificationsV1 method")
	}

	mmUnsubscribeFromNotificationsV1.mock.funcUnsubscribeFromNotificationsV1 = f
	return mmUnsubscribeFromNotificationsV1.mock
}

// When sets expectation for the ImapConcentratorServer.UnsubscribeFromNotificationsV1 which will trigger the result defined by the following
// Then helper
func (mmUnsubscribeFromNotificationsV1 *mImapConcentratorServerMockUnsubscribeFromNotificationsV1) When(ctx context.Context, up1 *UnsubscribeFromNotificationsV1Request) *ImapConcentratorServerMockUnsubscribeFromNotificationsV1Expectation {
	if mmUnsubscribeFromNotificationsV1.mock.funcUnsubscribeFromNotificationsV1 != nil {
		mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("ImapConcentratorServerMock.UnsubscribeFromNotificationsV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorServerMockUnsubscribeFromNotificationsV1Expectation{
		mock:   mmUnsubscribeFromNotificationsV1.mock,
		params: &ImapConcentratorServerMockUnsubscribeFromNotificationsV1Params{ctx, up1},
	}
	mmUnsubscribeFromNotificationsV1.expectations = append(mmUnsubscribeFromNotificationsV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorServer.UnsubscribeFromNotificationsV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorServerMockUnsubscribeFromNotificationsV1Expectation) Then(ap1 *Ack, err error) *ImapConcentratorServerMock {
	e.results = &ImapConcentratorServerMockUnsubscribeFromNotificationsV1Results{ap1, err}
	return e.mock
}

// UnsubscribeFromNotificationsV1 implements ImapConcentratorServer
func (mmUnsubscribeFromNotificationsV1 *ImapConcentratorServerMock) UnsubscribeFromNotificationsV1(ctx context.Context, up1 *UnsubscribeFromNotificationsV1Request) (ap1 *Ack, err error) {
	mm_atomic.AddUint64(&mmUnsubscribeFromNotificationsV1.beforeUnsubscribeFromNotificationsV1Counter, 1)
	defer mm_atomic.AddUint64(&mmUnsubscribeFromNotificationsV1.afterUnsubscribeFromNotificationsV1Counter, 1)

	if mmUnsubscribeFromNotificationsV1.inspectFuncUnsubscribeFromNotificationsV1 != nil {
		mmUnsubscribeFromNotificationsV1.inspectFuncUnsubscribeFromNotificationsV1(ctx, up1)
	}

	mm_params := &ImapConcentratorServerMockUnsubscribeFromNotificationsV1Params{ctx, up1}

	// Record call args
	mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.mutex.Lock()
	mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.callArgs = append(mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.callArgs, mm_params)
	mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.mutex.Unlock()

	for _, e := range mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorServerMockUnsubscribeFromNotificationsV1Params{ctx, up1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnsubscribeFromNotificationsV1.t.Errorf("ImapConcentratorServerMock.UnsubscribeFromNotificationsV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmUnsubscribeFromNotificationsV1.t.Fatal("No results are set for the ImapConcentratorServerMock.UnsubscribeFromNotificationsV1")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmUnsubscribeFromNotificationsV1.funcUnsubscribeFromNotificationsV1 != nil {
		return mmUnsubscribeFromNotificationsV1.funcUnsubscribeFromNotificationsV1(ctx, up1)
	}
	mmUnsubscribeFromNotificationsV1.t.Fatalf("Unexpected call to ImapConcentratorServerMock.UnsubscribeFromNotificationsV1. %v %v", ctx, up1)
	return
}

// UnsubscribeFromNotificationsV1AfterCounter returns a count of finished ImapConcentratorServerMock.UnsubscribeFromNotificationsV1 invocations
func (mmUnsubscribeFromNotificationsV1 *ImapConcentratorServerMock) UnsubscribeFromNotificationsV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnsubscribeFromNotificationsV1.afterUnsubscribeFromNotificationsV1Counter)
}

// UnsubscribeFromNotificationsV1BeforeCounter returns a count of ImapConcentratorServerMock.UnsubscribeFromNotificationsV1 invocations
func (mmUnsubscribeFromNotificationsV1 *ImapConcentratorServerMock) UnsubscribeFromNotificationsV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnsubscribeFromNotificationsV1.beforeUnsubscribeFromNotificationsV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorServerMock.UnsubscribeFromNotificationsV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnsubscribeFromNotificationsV1 *mImapConcentratorServerMockUnsubscribeFromNotificationsV1) Calls() []*ImapConcentratorServerMockUnsubscribeFromNotificationsV1Params {
	mmUnsubscribeFromNotificationsV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorServerMockUnsubscribeFromNotificationsV1Params, len(mmUnsubscribeFromNotificationsV1.callArgs))
	copy(argCopy, mmUnsubscribeFromNotificationsV1.callArgs)

	mmUnsubscribeFromNotificationsV1.mutex.RUnlock()

	return argCopy
}

// MinimockUnsubscribeFromNotificationsV1Done returns true if the count of the UnsubscribeFromNotificationsV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorServerMock) MinimockUnsubscribeFromNotificationsV1Done() bool {
	for _, e := range m.UnsubscribeFromNotificationsV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnsubscribeFromNotificationsV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeFromNotificationsV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnsubscribeFromNotificationsV1 != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeFromNotificationsV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockUnsubscribeFromNotificationsV1Inspect logs each unmet expectation
func (m *ImapConcentratorServerMock) MinimockUnsubscribeFromNotificationsV1Inspect() {
	for _, e := range m.UnsubscribeFromNotificationsV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.UnsubscribeFromNotificationsV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnsubscribeFromNotificationsV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeFromNotificationsV1Counter) < 1 {
		if m.UnsubscribeFromNotificationsV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorServerMock.UnsubscribeFromNotificationsV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.UnsubscribeFromNotificationsV1 with params: %#v", *m.UnsubscribeFromNotificationsV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnsubscribeFromNotificationsV1 != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeFromNotificationsV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.UnsubscribeFromNotificationsV1")
	}
}

type mImapConcentratorServerMockUpdateMailboxV1 struct {
	mock               *ImapConcentratorServerMock
	defaultExpectation *ImapConcentratorServerMockUpdateMailboxV1Expectation
	expectations       []*ImapConcentratorServerMockUpdateMailboxV1Expectation

	callArgs []*ImapConcentratorServerMockUpdateMailboxV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorServerMockUpdateMailboxV1Expectation specifies expectation struct of the ImapConcentratorServer.UpdateMailboxV1
type ImapConcentratorServerMockUpdateMailboxV1Expectation struct {
	mock    *ImapConcentratorServerMock
	params  *ImapConcentratorServerMockUpdateMailboxV1Params
	results *ImapConcentratorServerMockUpdateMailboxV1Results
	Counter uint64
}

// ImapConcentratorServerMockUpdateMailboxV1Params contains parameters of the ImapConcentratorServer.UpdateMailboxV1
type ImapConcentratorServerMockUpdateMailboxV1Params struct {
	ctx context.Context
	up1 *UpdateMailboxV1Request
}

// ImapConcentratorServerMockUpdateMailboxV1Results contains results of the ImapConcentratorServer.UpdateMailboxV1
type ImapConcentratorServerMockUpdateMailboxV1Results struct {
	ap1 *Ack
	err error
}

// Expect sets up expected params for ImapConcentratorServer.UpdateMailboxV1
func (mmUpdateMailboxV1 *mImapConcentratorServerMockUpdateMailboxV1) Expect(ctx context.Context, up1 *UpdateMailboxV1Request) *mImapConcentratorServerMockUpdateMailboxV1 {
	if mmUpdateMailboxV1.mock.funcUpdateMailboxV1 != nil {
		mmUpdateMailboxV1.mock.t.Fatalf("ImapConcentratorServerMock.UpdateMailboxV1 mock is already set by Set")
	}

	if mmUpdateMailboxV1.defaultExpectation == nil {
		mmUpdateMailboxV1.defaultExpectation = &ImapConcentratorServerMockUpdateMailboxV1Expectation{}
	}

	mmUpdateMailboxV1.defaultExpectation.params = &ImapConcentratorServerMockUpdateMailboxV1Params{ctx, up1}
	for _, e := range mmUpdateMailboxV1.expectations {
		if minimock.Equal(e.params, mmUpdateMailboxV1.defaultExpectation.params) {
			mmUpdateMailboxV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateMailboxV1.defaultExpectation.params)
		}
	}

	return mmUpdateMailboxV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorServer.UpdateMailboxV1
func (mmUpdateMailboxV1 *mImapConcentratorServerMockUpdateMailboxV1) Inspect(f func(ctx context.Context, up1 *UpdateMailboxV1Request)) *mImapConcentratorServerMockUpdateMailboxV1 {
	if mmUpdateMailboxV1.mock.inspectFuncUpdateMailboxV1 != nil {
		mmUpdateMailboxV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorServerMock.UpdateMailboxV1")
	}

	mmUpdateMailboxV1.mock.inspectFuncUpdateMailboxV1 = f

	return mmUpdateMailboxV1
}

// Return sets up results that will be returned by ImapConcentratorServer.UpdateMailboxV1
func (mmUpdateMailboxV1 *mImapConcentratorServerMockUpdateMailboxV1) Return(ap1 *Ack, err error) *ImapConcentratorServerMock {
	if mmUpdateMailboxV1.mock.funcUpdateMailboxV1 != nil {
		mmUpdateMailboxV1.mock.t.Fatalf("ImapConcentratorServerMock.UpdateMailboxV1 mock is already set by Set")
	}

	if mmUpdateMailboxV1.defaultExpectation == nil {
		mmUpdateMailboxV1.defaultExpectation = &ImapConcentratorServerMockUpdateMailboxV1Expectation{mock: mmUpdateMailboxV1.mock}
	}
	mmUpdateMailboxV1.defaultExpectation.results = &ImapConcentratorServerMockUpdateMailboxV1Results{ap1, err}
	return mmUpdateMailboxV1.mock
}

//Set uses given function f to mock the ImapConcentratorServer.UpdateMailboxV1 method
func (mmUpdateMailboxV1 *mImapConcentratorServerMockUpdateMailboxV1) Set(f func(ctx context.Context, up1 *UpdateMailboxV1Request) (ap1 *Ack, err error)) *ImapConcentratorServerMock {
	if mmUpdateMailboxV1.defaultExpectation != nil {
		mmUpdateMailboxV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorServer.UpdateMailboxV1 method")
	}

	if len(mmUpdateMailboxV1.expectations) > 0 {
		mmUpdateMailboxV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorServer.UpdateMailboxV1 method")
	}

	mmUpdateMailboxV1.mock.funcUpdateMailboxV1 = f
	return mmUpdateMailboxV1.mock
}

// When sets expectation for the ImapConcentratorServer.UpdateMailboxV1 which will trigger the result defined by the following
// Then helper
func (mmUpdateMailboxV1 *mImapConcentratorServerMockUpdateMailboxV1) When(ctx context.Context, up1 *UpdateMailboxV1Request) *ImapConcentratorServerMockUpdateMailboxV1Expectation {
	if mmUpdateMailboxV1.mock.funcUpdateMailboxV1 != nil {
		mmUpdateMailboxV1.mock.t.Fatalf("ImapConcentratorServerMock.UpdateMailboxV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorServerMockUpdateMailboxV1Expectation{
		mock:   mmUpdateMailboxV1.mock,
		params: &ImapConcentratorServerMockUpdateMailboxV1Params{ctx, up1},
	}
	mmUpdateMailboxV1.expectations = append(mmUpdateMailboxV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorServer.UpdateMailboxV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorServerMockUpdateMailboxV1Expectation) Then(ap1 *Ack, err error) *ImapConcentratorServerMock {
	e.results = &ImapConcentratorServerMockUpdateMailboxV1Results{ap1, err}
	return e.mock
}

// UpdateMailboxV1 implements ImapConcentratorServer
func (mmUpdateMailboxV1 *ImapConcentratorServerMock) UpdateMailboxV1(ctx context.Context, up1 *UpdateMailboxV1Request) (ap1 *Ack, err error) {
	mm_atomic.AddUint64(&mmUpdateMailboxV1.beforeUpdateMailboxV1Counter, 1)
	defer mm_atomic.AddUint64(&mmUpdateMailboxV1.afterUpdateMailboxV1Counter, 1)

	if mmUpdateMailboxV1.inspectFuncUpdateMailboxV1 != nil {
		mmUpdateMailboxV1.inspectFuncUpdateMailboxV1(ctx, up1)
	}

	mm_params := &ImapConcentratorServerMockUpdateMailboxV1Params{ctx, up1}

	// Record call args
	mmUpdateMailboxV1.UpdateMailboxV1Mock.mutex.Lock()
	mmUpdateMailboxV1.UpdateMailboxV1Mock.callArgs = append(mmUpdateMailboxV1.UpdateMailboxV1Mock.callArgs, mm_params)
	mmUpdateMailboxV1.UpdateMailboxV1Mock.mutex.Unlock()

	for _, e := range mmUpdateMailboxV1.UpdateMailboxV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmUpdateMailboxV1.UpdateMailboxV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateMailboxV1.UpdateMailboxV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateMailboxV1.UpdateMailboxV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorServerMockUpdateMailboxV1Params{ctx, up1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateMailboxV1.t.Errorf("ImapConcentratorServerMock.UpdateMailboxV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateMailboxV1.UpdateMailboxV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateMailboxV1.t.Fatal("No results are set for the ImapConcentratorServerMock.UpdateMailboxV1")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmUpdateMailboxV1.funcUpdateMailboxV1 != nil {
		return mmUpdateMailboxV1.funcUpdateMailboxV1(ctx, up1)
	}
	mmUpdateMailboxV1.t.Fatalf("Unexpected call to ImapConcentratorServerMock.UpdateMailboxV1. %v %v", ctx, up1)
	return
}

// UpdateMailboxV1AfterCounter returns a count of finished ImapConcentratorServerMock.UpdateMailboxV1 invocations
func (mmUpdateMailboxV1 *ImapConcentratorServerMock) UpdateMailboxV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMailboxV1.afterUpdateMailboxV1Counter)
}

// UpdateMailboxV1BeforeCounter returns a count of ImapConcentratorServerMock.UpdateMailboxV1 invocations
func (mmUpdateMailboxV1 *ImapConcentratorServerMock) UpdateMailboxV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMailboxV1.beforeUpdateMailboxV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorServerMock.UpdateMailboxV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateMailboxV1 *mImapConcentratorServerMockUpdateMailboxV1) Calls() []*ImapConcentratorServerMockUpdateMailboxV1Params {
	mmUpdateMailboxV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorServerMockUpdateMailboxV1Params, len(mmUpdateMailboxV1.callArgs))
	copy(argCopy, mmUpdateMailboxV1.callArgs)

	mmUpdateMailboxV1.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateMailboxV1Done returns true if the count of the UpdateMailboxV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorServerMock) MinimockUpdateMailboxV1Done() bool {
	for _, e := range m.UpdateMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateMailboxV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterUpdateMailboxV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateMailboxV1Inspect logs each unmet expectation
func (m *ImapConcentratorServerMock) MinimockUpdateMailboxV1Inspect() {
	for _, e := range m.UpdateMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.UpdateMailboxV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateMailboxV1Counter) < 1 {
		if m.UpdateMailboxV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorServerMock.UpdateMailboxV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorServerMock.UpdateMailboxV1 with params: %#v", *m.UpdateMailboxV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterUpdateMailboxV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.UpdateMailboxV1")
	}
}

type mImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServer struct {
	mock               *ImapConcentratorServerMock
	defaultExpectation *ImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServerExpectation
	expectations       []*ImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServerExpectation
}

// ImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServerExpectation specifies expectation struct of the ImapConcentratorServer.mustEmbedUnimplementedImapConcentratorServer
type ImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServerExpectation struct {
	mock *ImapConcentratorServerMock

	Counter uint64
}

// Expect sets up expected params for ImapConcentratorServer.mustEmbedUnimplementedImapConcentratorServer
func (mmmustEmbedUnimplementedImapConcentratorServer *mImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServer) Expect() *mImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServer {
	if mmmustEmbedUnimplementedImapConcentratorServer.mock.funcmustEmbedUnimplementedImapConcentratorServer != nil {
		mmmustEmbedUnimplementedImapConcentratorServer.mock.t.Fatalf("ImapConcentratorServerMock.mustEmbedUnimplementedImapConcentratorServer mock is already set by Set")
	}

	if mmmustEmbedUnimplementedImapConcentratorServer.defaultExpectation == nil {
		mmmustEmbedUnimplementedImapConcentratorServer.defaultExpectation = &ImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServerExpectation{}
	}

	return mmmustEmbedUnimplementedImapConcentratorServer
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorServer.mustEmbedUnimplementedImapConcentratorServer
func (mmmustEmbedUnimplementedImapConcentratorServer *mImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServer) Inspect(f func()) *mImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServer {
	if mmmustEmbedUnimplementedImapConcentratorServer.mock.inspectFuncmustEmbedUnimplementedImapConcentratorServer != nil {
		mmmustEmbedUnimplementedImapConcentratorServer.mock.t.Fatalf("Inspect function is already set for ImapConcentratorServerMock.mustEmbedUnimplementedImapConcentratorServer")
	}

	mmmustEmbedUnimplementedImapConcentratorServer.mock.inspectFuncmustEmbedUnimplementedImapConcentratorServer = f

	return mmmustEmbedUnimplementedImapConcentratorServer
}

// Return sets up results that will be returned by ImapConcentratorServer.mustEmbedUnimplementedImapConcentratorServer
func (mmmustEmbedUnimplementedImapConcentratorServer *mImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServer) Return() *ImapConcentratorServerMock {
	if mmmustEmbedUnimplementedImapConcentratorServer.mock.funcmustEmbedUnimplementedImapConcentratorServer != nil {
		mmmustEmbedUnimplementedImapConcentratorServer.mock.t.Fatalf("ImapConcentratorServerMock.mustEmbedUnimplementedImapConcentratorServer mock is already set by Set")
	}

	if mmmustEmbedUnimplementedImapConcentratorServer.defaultExpectation == nil {
		mmmustEmbedUnimplementedImapConcentratorServer.defaultExpectation = &ImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServerExpectation{mock: mmmustEmbedUnimplementedImapConcentratorServer.mock}
	}

	return mmmustEmbedUnimplementedImapConcentratorServer.mock
}

//Set uses given function f to mock the ImapConcentratorServer.mustEmbedUnimplementedImapConcentratorServer method
func (mmmustEmbedUnimplementedImapConcentratorServer *mImapConcentratorServerMockmustEmbedUnimplementedImapConcentratorServer) Set(f func()) *ImapConcentratorServerMock {
	if mmmustEmbedUnimplementedImapConcentratorServer.defaultExpectation != nil {
		mmmustEmbedUnimplementedImapConcentratorServer.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorServer.mustEmbedUnimplementedImapConcentratorServer method")
	}

	if len(mmmustEmbedUnimplementedImapConcentratorServer.expectations) > 0 {
		mmmustEmbedUnimplementedImapConcentratorServer.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorServer.mustEmbedUnimplementedImapConcentratorServer method")
	}

	mmmustEmbedUnimplementedImapConcentratorServer.mock.funcmustEmbedUnimplementedImapConcentratorServer = f
	return mmmustEmbedUnimplementedImapConcentratorServer.mock
}

// mustEmbedUnimplementedImapConcentratorServer implements ImapConcentratorServer
func (mmmustEmbedUnimplementedImapConcentratorServer *ImapConcentratorServerMock) mustEmbedUnimplementedImapConcentratorServer() {
	mm_atomic.AddUint64(&mmmustEmbedUnimplementedImapConcentratorServer.beforemustEmbedUnimplementedImapConcentratorServerCounter, 1)
	defer mm_atomic.AddUint64(&mmmustEmbedUnimplementedImapConcentratorServer.aftermustEmbedUnimplementedImapConcentratorServerCounter, 1)

	if mmmustEmbedUnimplementedImapConcentratorServer.inspectFuncmustEmbedUnimplementedImapConcentratorServer != nil {
		mmmustEmbedUnimplementedImapConcentratorServer.inspectFuncmustEmbedUnimplementedImapConcentratorServer()
	}

	if mmmustEmbedUnimplementedImapConcentratorServer.mustEmbedUnimplementedImapConcentratorServerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmmustEmbedUnimplementedImapConcentratorServer.mustEmbedUnimplementedImapConcentratorServerMock.defaultExpectation.Counter, 1)

		return

	}
	if mmmustEmbedUnimplementedImapConcentratorServer.funcmustEmbedUnimplementedImapConcentratorServer != nil {
		mmmustEmbedUnimplementedImapConcentratorServer.funcmustEmbedUnimplementedImapConcentratorServer()
		return
	}
	mmmustEmbedUnimplementedImapConcentratorServer.t.Fatalf("Unexpected call to ImapConcentratorServerMock.mustEmbedUnimplementedImapConcentratorServer.")

}

// mustEmbedUnimplementedImapConcentratorServerAfterCounter returns a count of finished ImapConcentratorServerMock.mustEmbedUnimplementedImapConcentratorServer invocations
func (mmmustEmbedUnimplementedImapConcentratorServer *ImapConcentratorServerMock) mustEmbedUnimplementedImapConcentratorServerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmmustEmbedUnimplementedImapConcentratorServer.aftermustEmbedUnimplementedImapConcentratorServerCounter)
}

// mustEmbedUnimplementedImapConcentratorServerBeforeCounter returns a count of ImapConcentratorServerMock.mustEmbedUnimplementedImapConcentratorServer invocations
func (mmmustEmbedUnimplementedImapConcentratorServer *ImapConcentratorServerMock) mustEmbedUnimplementedImapConcentratorServerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmmustEmbedUnimplementedImapConcentratorServer.beforemustEmbedUnimplementedImapConcentratorServerCounter)
}

// MinimockmustEmbedUnimplementedImapConcentratorServerDone returns true if the count of the mustEmbedUnimplementedImapConcentratorServer invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorServerMock) MinimockmustEmbedUnimplementedImapConcentratorServerDone() bool {
	for _, e := range m.mustEmbedUnimplementedImapConcentratorServerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.mustEmbedUnimplementedImapConcentratorServerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftermustEmbedUnimplementedImapConcentratorServerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcmustEmbedUnimplementedImapConcentratorServer != nil && mm_atomic.LoadUint64(&m.aftermustEmbedUnimplementedImapConcentratorServerCounter) < 1 {
		return false
	}
	return true
}

// MinimockmustEmbedUnimplementedImapConcentratorServerInspect logs each unmet expectation
func (m *ImapConcentratorServerMock) MinimockmustEmbedUnimplementedImapConcentratorServerInspect() {
	for _, e := range m.mustEmbedUnimplementedImapConcentratorServerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ImapConcentratorServerMock.mustEmbedUnimplementedImapConcentratorServer")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.mustEmbedUnimplementedImapConcentratorServerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.aftermustEmbedUnimplementedImapConcentratorServerCounter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.mustEmbedUnimplementedImapConcentratorServer")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcmustEmbedUnimplementedImapConcentratorServer != nil && mm_atomic.LoadUint64(&m.aftermustEmbedUnimplementedImapConcentratorServerCounter) < 1 {
		m.t.Error("Expected call to ImapConcentratorServerMock.mustEmbedUnimplementedImapConcentratorServer")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ImapConcentratorServerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAssignUniqueClientIDInspect()

		m.MinimockDeleteMailboxV1Inspect()

		m.MinimockGetMailboxV1Inspect()

		m.MinimockInsertChatV1Inspect()

		m.MinimockInsertMailboxV1Inspect()

		m.MinimockListMailboxesV1Inspect()

		m.MinimockPollV1Inspect()

		m.MinimockSubscribeToAllNotificationsV1Inspect()

		m.MinimockSubscribeToChatNotificationsV1Inspect()

		m.MinimockUnsubscribeFromNotificationsV1Inspect()

		m.MinimockUpdateMailboxV1Inspect()

		m.MinimockmustEmbedUnimplementedImapConcentratorServerInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ImapConcentratorServerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ImapConcentratorServerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAssignUniqueClientIDDone() &&
		m.MinimockDeleteMailboxV1Done() &&
		m.MinimockGetMailboxV1Done() &&
		m.MinimockInsertChatV1Done() &&
		m.MinimockInsertMailboxV1Done() &&
		m.MinimockListMailboxesV1Done() &&
		m.MinimockPollV1Done() &&
		m.MinimockSubscribeToAllNotificationsV1Done() &&
		m.MinimockSubscribeToChatNotificationsV1Done() &&
		m.MinimockUnsubscribeFromNotificationsV1Done() &&
		m.MinimockUpdateMailboxV1Done() &&
		m.MinimockmustEmbedUnimplementedImapConcentratorServerDone()
}
