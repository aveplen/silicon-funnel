package imap_concentrator

// Code generated by http://github.com/gojuno/minimock (3.0.10). DO NOT EDIT.

//go:generate minimock -i github.com/aveplen/silicon-funnel/pkg/imap_concentrator/v1.ImapConcentratorClient -o ./imap_concentrator_client_mock_test.go -n ImapConcentratorClientMock

import (
	context "context"
	sync "sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	grpc "google.golang.org/grpc"
)

// ImapConcentratorClientMock implements ImapConcentratorClient
type ImapConcentratorClientMock struct {
	t minimock.Tester

	funcAssignUniqueClientID          func(ctx context.Context, in *AssignUniqueClientIDRequest, opts ...grpc.CallOption) (ap1 *AssignUniqueClientIDResponse, err error)
	inspectFuncAssignUniqueClientID   func(ctx context.Context, in *AssignUniqueClientIDRequest, opts ...grpc.CallOption)
	afterAssignUniqueClientIDCounter  uint64
	beforeAssignUniqueClientIDCounter uint64
	AssignUniqueClientIDMock          mImapConcentratorClientMockAssignUniqueClientID

	funcDeleteMailboxV1          func(ctx context.Context, in *DeleteMailboxV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error)
	inspectFuncDeleteMailboxV1   func(ctx context.Context, in *DeleteMailboxV1Request, opts ...grpc.CallOption)
	afterDeleteMailboxV1Counter  uint64
	beforeDeleteMailboxV1Counter uint64
	DeleteMailboxV1Mock          mImapConcentratorClientMockDeleteMailboxV1

	funcGetMailboxV1          func(ctx context.Context, in *GetMailboxV1Request, opts ...grpc.CallOption) (gp1 *GetMailboxV1Response, err error)
	inspectFuncGetMailboxV1   func(ctx context.Context, in *GetMailboxV1Request, opts ...grpc.CallOption)
	afterGetMailboxV1Counter  uint64
	beforeGetMailboxV1Counter uint64
	GetMailboxV1Mock          mImapConcentratorClientMockGetMailboxV1

	funcInsertChatV1          func(ctx context.Context, in *InsertChatV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error)
	inspectFuncInsertChatV1   func(ctx context.Context, in *InsertChatV1Request, opts ...grpc.CallOption)
	afterInsertChatV1Counter  uint64
	beforeInsertChatV1Counter uint64
	InsertChatV1Mock          mImapConcentratorClientMockInsertChatV1

	funcInsertMailboxV1          func(ctx context.Context, in *InsertMailboxV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error)
	inspectFuncInsertMailboxV1   func(ctx context.Context, in *InsertMailboxV1Request, opts ...grpc.CallOption)
	afterInsertMailboxV1Counter  uint64
	beforeInsertMailboxV1Counter uint64
	InsertMailboxV1Mock          mImapConcentratorClientMockInsertMailboxV1

	funcListMailboxesV1          func(ctx context.Context, in *ListMailboxesV1Request, opts ...grpc.CallOption) (lp1 *ListMailboxesV1Response, err error)
	inspectFuncListMailboxesV1   func(ctx context.Context, in *ListMailboxesV1Request, opts ...grpc.CallOption)
	afterListMailboxesV1Counter  uint64
	beforeListMailboxesV1Counter uint64
	ListMailboxesV1Mock          mImapConcentratorClientMockListMailboxesV1

	funcPollV1          func(ctx context.Context, in *PollV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error)
	inspectFuncPollV1   func(ctx context.Context, in *PollV1Request, opts ...grpc.CallOption)
	afterPollV1Counter  uint64
	beforePollV1Counter uint64
	PollV1Mock          mImapConcentratorClientMockPollV1

	funcSubscribeToAllNotificationsV1          func(ctx context.Context, in *SubscribeToAllNotificationsV1Request, opts ...grpc.CallOption) (i1 ImapConcentrator_SubscribeToAllNotificationsV1Client, err error)
	inspectFuncSubscribeToAllNotificationsV1   func(ctx context.Context, in *SubscribeToAllNotificationsV1Request, opts ...grpc.CallOption)
	afterSubscribeToAllNotificationsV1Counter  uint64
	beforeSubscribeToAllNotificationsV1Counter uint64
	SubscribeToAllNotificationsV1Mock          mImapConcentratorClientMockSubscribeToAllNotificationsV1

	funcSubscribeToChatNotificationsV1          func(ctx context.Context, in *SubscribeToChatNotificationsV1Request, opts ...grpc.CallOption) (i1 ImapConcentrator_SubscribeToChatNotificationsV1Client, err error)
	inspectFuncSubscribeToChatNotificationsV1   func(ctx context.Context, in *SubscribeToChatNotificationsV1Request, opts ...grpc.CallOption)
	afterSubscribeToChatNotificationsV1Counter  uint64
	beforeSubscribeToChatNotificationsV1Counter uint64
	SubscribeToChatNotificationsV1Mock          mImapConcentratorClientMockSubscribeToChatNotificationsV1

	funcUnsubscribeFromNotificationsV1          func(ctx context.Context, in *UnsubscribeFromNotificationsV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error)
	inspectFuncUnsubscribeFromNotificationsV1   func(ctx context.Context, in *UnsubscribeFromNotificationsV1Request, opts ...grpc.CallOption)
	afterUnsubscribeFromNotificationsV1Counter  uint64
	beforeUnsubscribeFromNotificationsV1Counter uint64
	UnsubscribeFromNotificationsV1Mock          mImapConcentratorClientMockUnsubscribeFromNotificationsV1

	funcUpdateMailboxV1          func(ctx context.Context, in *UpdateMailboxV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error)
	inspectFuncUpdateMailboxV1   func(ctx context.Context, in *UpdateMailboxV1Request, opts ...grpc.CallOption)
	afterUpdateMailboxV1Counter  uint64
	beforeUpdateMailboxV1Counter uint64
	UpdateMailboxV1Mock          mImapConcentratorClientMockUpdateMailboxV1
}

// NewImapConcentratorClientMock returns a mock for ImapConcentratorClient
func NewImapConcentratorClientMock(t minimock.Tester) *ImapConcentratorClientMock {
	m := &ImapConcentratorClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AssignUniqueClientIDMock = mImapConcentratorClientMockAssignUniqueClientID{mock: m}
	m.AssignUniqueClientIDMock.callArgs = []*ImapConcentratorClientMockAssignUniqueClientIDParams{}

	m.DeleteMailboxV1Mock = mImapConcentratorClientMockDeleteMailboxV1{mock: m}
	m.DeleteMailboxV1Mock.callArgs = []*ImapConcentratorClientMockDeleteMailboxV1Params{}

	m.GetMailboxV1Mock = mImapConcentratorClientMockGetMailboxV1{mock: m}
	m.GetMailboxV1Mock.callArgs = []*ImapConcentratorClientMockGetMailboxV1Params{}

	m.InsertChatV1Mock = mImapConcentratorClientMockInsertChatV1{mock: m}
	m.InsertChatV1Mock.callArgs = []*ImapConcentratorClientMockInsertChatV1Params{}

	m.InsertMailboxV1Mock = mImapConcentratorClientMockInsertMailboxV1{mock: m}
	m.InsertMailboxV1Mock.callArgs = []*ImapConcentratorClientMockInsertMailboxV1Params{}

	m.ListMailboxesV1Mock = mImapConcentratorClientMockListMailboxesV1{mock: m}
	m.ListMailboxesV1Mock.callArgs = []*ImapConcentratorClientMockListMailboxesV1Params{}

	m.PollV1Mock = mImapConcentratorClientMockPollV1{mock: m}
	m.PollV1Mock.callArgs = []*ImapConcentratorClientMockPollV1Params{}

	m.SubscribeToAllNotificationsV1Mock = mImapConcentratorClientMockSubscribeToAllNotificationsV1{mock: m}
	m.SubscribeToAllNotificationsV1Mock.callArgs = []*ImapConcentratorClientMockSubscribeToAllNotificationsV1Params{}

	m.SubscribeToChatNotificationsV1Mock = mImapConcentratorClientMockSubscribeToChatNotificationsV1{mock: m}
	m.SubscribeToChatNotificationsV1Mock.callArgs = []*ImapConcentratorClientMockSubscribeToChatNotificationsV1Params{}

	m.UnsubscribeFromNotificationsV1Mock = mImapConcentratorClientMockUnsubscribeFromNotificationsV1{mock: m}
	m.UnsubscribeFromNotificationsV1Mock.callArgs = []*ImapConcentratorClientMockUnsubscribeFromNotificationsV1Params{}

	m.UpdateMailboxV1Mock = mImapConcentratorClientMockUpdateMailboxV1{mock: m}
	m.UpdateMailboxV1Mock.callArgs = []*ImapConcentratorClientMockUpdateMailboxV1Params{}

	return m
}

type mImapConcentratorClientMockAssignUniqueClientID struct {
	mock               *ImapConcentratorClientMock
	defaultExpectation *ImapConcentratorClientMockAssignUniqueClientIDExpectation
	expectations       []*ImapConcentratorClientMockAssignUniqueClientIDExpectation

	callArgs []*ImapConcentratorClientMockAssignUniqueClientIDParams
	mutex    sync.RWMutex
}

// ImapConcentratorClientMockAssignUniqueClientIDExpectation specifies expectation struct of the ImapConcentratorClient.AssignUniqueClientID
type ImapConcentratorClientMockAssignUniqueClientIDExpectation struct {
	mock    *ImapConcentratorClientMock
	params  *ImapConcentratorClientMockAssignUniqueClientIDParams
	results *ImapConcentratorClientMockAssignUniqueClientIDResults
	Counter uint64
}

// ImapConcentratorClientMockAssignUniqueClientIDParams contains parameters of the ImapConcentratorClient.AssignUniqueClientID
type ImapConcentratorClientMockAssignUniqueClientIDParams struct {
	ctx  context.Context
	in   *AssignUniqueClientIDRequest
	opts []grpc.CallOption
}

// ImapConcentratorClientMockAssignUniqueClientIDResults contains results of the ImapConcentratorClient.AssignUniqueClientID
type ImapConcentratorClientMockAssignUniqueClientIDResults struct {
	ap1 *AssignUniqueClientIDResponse
	err error
}

// Expect sets up expected params for ImapConcentratorClient.AssignUniqueClientID
func (mmAssignUniqueClientID *mImapConcentratorClientMockAssignUniqueClientID) Expect(ctx context.Context, in *AssignUniqueClientIDRequest, opts ...grpc.CallOption) *mImapConcentratorClientMockAssignUniqueClientID {
	if mmAssignUniqueClientID.mock.funcAssignUniqueClientID != nil {
		mmAssignUniqueClientID.mock.t.Fatalf("ImapConcentratorClientMock.AssignUniqueClientID mock is already set by Set")
	}

	if mmAssignUniqueClientID.defaultExpectation == nil {
		mmAssignUniqueClientID.defaultExpectation = &ImapConcentratorClientMockAssignUniqueClientIDExpectation{}
	}

	mmAssignUniqueClientID.defaultExpectation.params = &ImapConcentratorClientMockAssignUniqueClientIDParams{ctx, in, opts}
	for _, e := range mmAssignUniqueClientID.expectations {
		if minimock.Equal(e.params, mmAssignUniqueClientID.defaultExpectation.params) {
			mmAssignUniqueClientID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAssignUniqueClientID.defaultExpectation.params)
		}
	}

	return mmAssignUniqueClientID
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorClient.AssignUniqueClientID
func (mmAssignUniqueClientID *mImapConcentratorClientMockAssignUniqueClientID) Inspect(f func(ctx context.Context, in *AssignUniqueClientIDRequest, opts ...grpc.CallOption)) *mImapConcentratorClientMockAssignUniqueClientID {
	if mmAssignUniqueClientID.mock.inspectFuncAssignUniqueClientID != nil {
		mmAssignUniqueClientID.mock.t.Fatalf("Inspect function is already set for ImapConcentratorClientMock.AssignUniqueClientID")
	}

	mmAssignUniqueClientID.mock.inspectFuncAssignUniqueClientID = f

	return mmAssignUniqueClientID
}

// Return sets up results that will be returned by ImapConcentratorClient.AssignUniqueClientID
func (mmAssignUniqueClientID *mImapConcentratorClientMockAssignUniqueClientID) Return(ap1 *AssignUniqueClientIDResponse, err error) *ImapConcentratorClientMock {
	if mmAssignUniqueClientID.mock.funcAssignUniqueClientID != nil {
		mmAssignUniqueClientID.mock.t.Fatalf("ImapConcentratorClientMock.AssignUniqueClientID mock is already set by Set")
	}

	if mmAssignUniqueClientID.defaultExpectation == nil {
		mmAssignUniqueClientID.defaultExpectation = &ImapConcentratorClientMockAssignUniqueClientIDExpectation{mock: mmAssignUniqueClientID.mock}
	}
	mmAssignUniqueClientID.defaultExpectation.results = &ImapConcentratorClientMockAssignUniqueClientIDResults{ap1, err}
	return mmAssignUniqueClientID.mock
}

//Set uses given function f to mock the ImapConcentratorClient.AssignUniqueClientID method
func (mmAssignUniqueClientID *mImapConcentratorClientMockAssignUniqueClientID) Set(f func(ctx context.Context, in *AssignUniqueClientIDRequest, opts ...grpc.CallOption) (ap1 *AssignUniqueClientIDResponse, err error)) *ImapConcentratorClientMock {
	if mmAssignUniqueClientID.defaultExpectation != nil {
		mmAssignUniqueClientID.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorClient.AssignUniqueClientID method")
	}

	if len(mmAssignUniqueClientID.expectations) > 0 {
		mmAssignUniqueClientID.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorClient.AssignUniqueClientID method")
	}

	mmAssignUniqueClientID.mock.funcAssignUniqueClientID = f
	return mmAssignUniqueClientID.mock
}

// When sets expectation for the ImapConcentratorClient.AssignUniqueClientID which will trigger the result defined by the following
// Then helper
func (mmAssignUniqueClientID *mImapConcentratorClientMockAssignUniqueClientID) When(ctx context.Context, in *AssignUniqueClientIDRequest, opts ...grpc.CallOption) *ImapConcentratorClientMockAssignUniqueClientIDExpectation {
	if mmAssignUniqueClientID.mock.funcAssignUniqueClientID != nil {
		mmAssignUniqueClientID.mock.t.Fatalf("ImapConcentratorClientMock.AssignUniqueClientID mock is already set by Set")
	}

	expectation := &ImapConcentratorClientMockAssignUniqueClientIDExpectation{
		mock:   mmAssignUniqueClientID.mock,
		params: &ImapConcentratorClientMockAssignUniqueClientIDParams{ctx, in, opts},
	}
	mmAssignUniqueClientID.expectations = append(mmAssignUniqueClientID.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorClient.AssignUniqueClientID return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorClientMockAssignUniqueClientIDExpectation) Then(ap1 *AssignUniqueClientIDResponse, err error) *ImapConcentratorClientMock {
	e.results = &ImapConcentratorClientMockAssignUniqueClientIDResults{ap1, err}
	return e.mock
}

// AssignUniqueClientID implements ImapConcentratorClient
func (mmAssignUniqueClientID *ImapConcentratorClientMock) AssignUniqueClientID(ctx context.Context, in *AssignUniqueClientIDRequest, opts ...grpc.CallOption) (ap1 *AssignUniqueClientIDResponse, err error) {
	mm_atomic.AddUint64(&mmAssignUniqueClientID.beforeAssignUniqueClientIDCounter, 1)
	defer mm_atomic.AddUint64(&mmAssignUniqueClientID.afterAssignUniqueClientIDCounter, 1)

	if mmAssignUniqueClientID.inspectFuncAssignUniqueClientID != nil {
		mmAssignUniqueClientID.inspectFuncAssignUniqueClientID(ctx, in, opts...)
	}

	mm_params := &ImapConcentratorClientMockAssignUniqueClientIDParams{ctx, in, opts}

	// Record call args
	mmAssignUniqueClientID.AssignUniqueClientIDMock.mutex.Lock()
	mmAssignUniqueClientID.AssignUniqueClientIDMock.callArgs = append(mmAssignUniqueClientID.AssignUniqueClientIDMock.callArgs, mm_params)
	mmAssignUniqueClientID.AssignUniqueClientIDMock.mutex.Unlock()

	for _, e := range mmAssignUniqueClientID.AssignUniqueClientIDMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmAssignUniqueClientID.AssignUniqueClientIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAssignUniqueClientID.AssignUniqueClientIDMock.defaultExpectation.Counter, 1)
		mm_want := mmAssignUniqueClientID.AssignUniqueClientIDMock.defaultExpectation.params
		mm_got := ImapConcentratorClientMockAssignUniqueClientIDParams{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAssignUniqueClientID.t.Errorf("ImapConcentratorClientMock.AssignUniqueClientID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAssignUniqueClientID.AssignUniqueClientIDMock.defaultExpectation.results
		if mm_results == nil {
			mmAssignUniqueClientID.t.Fatal("No results are set for the ImapConcentratorClientMock.AssignUniqueClientID")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmAssignUniqueClientID.funcAssignUniqueClientID != nil {
		return mmAssignUniqueClientID.funcAssignUniqueClientID(ctx, in, opts...)
	}
	mmAssignUniqueClientID.t.Fatalf("Unexpected call to ImapConcentratorClientMock.AssignUniqueClientID. %v %v %v", ctx, in, opts)
	return
}

// AssignUniqueClientIDAfterCounter returns a count of finished ImapConcentratorClientMock.AssignUniqueClientID invocations
func (mmAssignUniqueClientID *ImapConcentratorClientMock) AssignUniqueClientIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAssignUniqueClientID.afterAssignUniqueClientIDCounter)
}

// AssignUniqueClientIDBeforeCounter returns a count of ImapConcentratorClientMock.AssignUniqueClientID invocations
func (mmAssignUniqueClientID *ImapConcentratorClientMock) AssignUniqueClientIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAssignUniqueClientID.beforeAssignUniqueClientIDCounter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorClientMock.AssignUniqueClientID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAssignUniqueClientID *mImapConcentratorClientMockAssignUniqueClientID) Calls() []*ImapConcentratorClientMockAssignUniqueClientIDParams {
	mmAssignUniqueClientID.mutex.RLock()

	argCopy := make([]*ImapConcentratorClientMockAssignUniqueClientIDParams, len(mmAssignUniqueClientID.callArgs))
	copy(argCopy, mmAssignUniqueClientID.callArgs)

	mmAssignUniqueClientID.mutex.RUnlock()

	return argCopy
}

// MinimockAssignUniqueClientIDDone returns true if the count of the AssignUniqueClientID invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorClientMock) MinimockAssignUniqueClientIDDone() bool {
	for _, e := range m.AssignUniqueClientIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AssignUniqueClientIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAssignUniqueClientIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAssignUniqueClientID != nil && mm_atomic.LoadUint64(&m.afterAssignUniqueClientIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockAssignUniqueClientIDInspect logs each unmet expectation
func (m *ImapConcentratorClientMock) MinimockAssignUniqueClientIDInspect() {
	for _, e := range m.AssignUniqueClientIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.AssignUniqueClientID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AssignUniqueClientIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAssignUniqueClientIDCounter) < 1 {
		if m.AssignUniqueClientIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorClientMock.AssignUniqueClientID")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.AssignUniqueClientID with params: %#v", *m.AssignUniqueClientIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAssignUniqueClientID != nil && mm_atomic.LoadUint64(&m.afterAssignUniqueClientIDCounter) < 1 {
		m.t.Error("Expected call to ImapConcentratorClientMock.AssignUniqueClientID")
	}
}

type mImapConcentratorClientMockDeleteMailboxV1 struct {
	mock               *ImapConcentratorClientMock
	defaultExpectation *ImapConcentratorClientMockDeleteMailboxV1Expectation
	expectations       []*ImapConcentratorClientMockDeleteMailboxV1Expectation

	callArgs []*ImapConcentratorClientMockDeleteMailboxV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorClientMockDeleteMailboxV1Expectation specifies expectation struct of the ImapConcentratorClient.DeleteMailboxV1
type ImapConcentratorClientMockDeleteMailboxV1Expectation struct {
	mock    *ImapConcentratorClientMock
	params  *ImapConcentratorClientMockDeleteMailboxV1Params
	results *ImapConcentratorClientMockDeleteMailboxV1Results
	Counter uint64
}

// ImapConcentratorClientMockDeleteMailboxV1Params contains parameters of the ImapConcentratorClient.DeleteMailboxV1
type ImapConcentratorClientMockDeleteMailboxV1Params struct {
	ctx  context.Context
	in   *DeleteMailboxV1Request
	opts []grpc.CallOption
}

// ImapConcentratorClientMockDeleteMailboxV1Results contains results of the ImapConcentratorClient.DeleteMailboxV1
type ImapConcentratorClientMockDeleteMailboxV1Results struct {
	ap1 *Ack
	err error
}

// Expect sets up expected params for ImapConcentratorClient.DeleteMailboxV1
func (mmDeleteMailboxV1 *mImapConcentratorClientMockDeleteMailboxV1) Expect(ctx context.Context, in *DeleteMailboxV1Request, opts ...grpc.CallOption) *mImapConcentratorClientMockDeleteMailboxV1 {
	if mmDeleteMailboxV1.mock.funcDeleteMailboxV1 != nil {
		mmDeleteMailboxV1.mock.t.Fatalf("ImapConcentratorClientMock.DeleteMailboxV1 mock is already set by Set")
	}

	if mmDeleteMailboxV1.defaultExpectation == nil {
		mmDeleteMailboxV1.defaultExpectation = &ImapConcentratorClientMockDeleteMailboxV1Expectation{}
	}

	mmDeleteMailboxV1.defaultExpectation.params = &ImapConcentratorClientMockDeleteMailboxV1Params{ctx, in, opts}
	for _, e := range mmDeleteMailboxV1.expectations {
		if minimock.Equal(e.params, mmDeleteMailboxV1.defaultExpectation.params) {
			mmDeleteMailboxV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteMailboxV1.defaultExpectation.params)
		}
	}

	return mmDeleteMailboxV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorClient.DeleteMailboxV1
func (mmDeleteMailboxV1 *mImapConcentratorClientMockDeleteMailboxV1) Inspect(f func(ctx context.Context, in *DeleteMailboxV1Request, opts ...grpc.CallOption)) *mImapConcentratorClientMockDeleteMailboxV1 {
	if mmDeleteMailboxV1.mock.inspectFuncDeleteMailboxV1 != nil {
		mmDeleteMailboxV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorClientMock.DeleteMailboxV1")
	}

	mmDeleteMailboxV1.mock.inspectFuncDeleteMailboxV1 = f

	return mmDeleteMailboxV1
}

// Return sets up results that will be returned by ImapConcentratorClient.DeleteMailboxV1
func (mmDeleteMailboxV1 *mImapConcentratorClientMockDeleteMailboxV1) Return(ap1 *Ack, err error) *ImapConcentratorClientMock {
	if mmDeleteMailboxV1.mock.funcDeleteMailboxV1 != nil {
		mmDeleteMailboxV1.mock.t.Fatalf("ImapConcentratorClientMock.DeleteMailboxV1 mock is already set by Set")
	}

	if mmDeleteMailboxV1.defaultExpectation == nil {
		mmDeleteMailboxV1.defaultExpectation = &ImapConcentratorClientMockDeleteMailboxV1Expectation{mock: mmDeleteMailboxV1.mock}
	}
	mmDeleteMailboxV1.defaultExpectation.results = &ImapConcentratorClientMockDeleteMailboxV1Results{ap1, err}
	return mmDeleteMailboxV1.mock
}

//Set uses given function f to mock the ImapConcentratorClient.DeleteMailboxV1 method
func (mmDeleteMailboxV1 *mImapConcentratorClientMockDeleteMailboxV1) Set(f func(ctx context.Context, in *DeleteMailboxV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error)) *ImapConcentratorClientMock {
	if mmDeleteMailboxV1.defaultExpectation != nil {
		mmDeleteMailboxV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorClient.DeleteMailboxV1 method")
	}

	if len(mmDeleteMailboxV1.expectations) > 0 {
		mmDeleteMailboxV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorClient.DeleteMailboxV1 method")
	}

	mmDeleteMailboxV1.mock.funcDeleteMailboxV1 = f
	return mmDeleteMailboxV1.mock
}

// When sets expectation for the ImapConcentratorClient.DeleteMailboxV1 which will trigger the result defined by the following
// Then helper
func (mmDeleteMailboxV1 *mImapConcentratorClientMockDeleteMailboxV1) When(ctx context.Context, in *DeleteMailboxV1Request, opts ...grpc.CallOption) *ImapConcentratorClientMockDeleteMailboxV1Expectation {
	if mmDeleteMailboxV1.mock.funcDeleteMailboxV1 != nil {
		mmDeleteMailboxV1.mock.t.Fatalf("ImapConcentratorClientMock.DeleteMailboxV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorClientMockDeleteMailboxV1Expectation{
		mock:   mmDeleteMailboxV1.mock,
		params: &ImapConcentratorClientMockDeleteMailboxV1Params{ctx, in, opts},
	}
	mmDeleteMailboxV1.expectations = append(mmDeleteMailboxV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorClient.DeleteMailboxV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorClientMockDeleteMailboxV1Expectation) Then(ap1 *Ack, err error) *ImapConcentratorClientMock {
	e.results = &ImapConcentratorClientMockDeleteMailboxV1Results{ap1, err}
	return e.mock
}

// DeleteMailboxV1 implements ImapConcentratorClient
func (mmDeleteMailboxV1 *ImapConcentratorClientMock) DeleteMailboxV1(ctx context.Context, in *DeleteMailboxV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error) {
	mm_atomic.AddUint64(&mmDeleteMailboxV1.beforeDeleteMailboxV1Counter, 1)
	defer mm_atomic.AddUint64(&mmDeleteMailboxV1.afterDeleteMailboxV1Counter, 1)

	if mmDeleteMailboxV1.inspectFuncDeleteMailboxV1 != nil {
		mmDeleteMailboxV1.inspectFuncDeleteMailboxV1(ctx, in, opts...)
	}

	mm_params := &ImapConcentratorClientMockDeleteMailboxV1Params{ctx, in, opts}

	// Record call args
	mmDeleteMailboxV1.DeleteMailboxV1Mock.mutex.Lock()
	mmDeleteMailboxV1.DeleteMailboxV1Mock.callArgs = append(mmDeleteMailboxV1.DeleteMailboxV1Mock.callArgs, mm_params)
	mmDeleteMailboxV1.DeleteMailboxV1Mock.mutex.Unlock()

	for _, e := range mmDeleteMailboxV1.DeleteMailboxV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmDeleteMailboxV1.DeleteMailboxV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteMailboxV1.DeleteMailboxV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteMailboxV1.DeleteMailboxV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorClientMockDeleteMailboxV1Params{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteMailboxV1.t.Errorf("ImapConcentratorClientMock.DeleteMailboxV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteMailboxV1.DeleteMailboxV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteMailboxV1.t.Fatal("No results are set for the ImapConcentratorClientMock.DeleteMailboxV1")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmDeleteMailboxV1.funcDeleteMailboxV1 != nil {
		return mmDeleteMailboxV1.funcDeleteMailboxV1(ctx, in, opts...)
	}
	mmDeleteMailboxV1.t.Fatalf("Unexpected call to ImapConcentratorClientMock.DeleteMailboxV1. %v %v %v", ctx, in, opts)
	return
}

// DeleteMailboxV1AfterCounter returns a count of finished ImapConcentratorClientMock.DeleteMailboxV1 invocations
func (mmDeleteMailboxV1 *ImapConcentratorClientMock) DeleteMailboxV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMailboxV1.afterDeleteMailboxV1Counter)
}

// DeleteMailboxV1BeforeCounter returns a count of ImapConcentratorClientMock.DeleteMailboxV1 invocations
func (mmDeleteMailboxV1 *ImapConcentratorClientMock) DeleteMailboxV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteMailboxV1.beforeDeleteMailboxV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorClientMock.DeleteMailboxV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteMailboxV1 *mImapConcentratorClientMockDeleteMailboxV1) Calls() []*ImapConcentratorClientMockDeleteMailboxV1Params {
	mmDeleteMailboxV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorClientMockDeleteMailboxV1Params, len(mmDeleteMailboxV1.callArgs))
	copy(argCopy, mmDeleteMailboxV1.callArgs)

	mmDeleteMailboxV1.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteMailboxV1Done returns true if the count of the DeleteMailboxV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorClientMock) MinimockDeleteMailboxV1Done() bool {
	for _, e := range m.DeleteMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteMailboxV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterDeleteMailboxV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteMailboxV1Inspect logs each unmet expectation
func (m *ImapConcentratorClientMock) MinimockDeleteMailboxV1Inspect() {
	for _, e := range m.DeleteMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.DeleteMailboxV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteMailboxV1Counter) < 1 {
		if m.DeleteMailboxV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorClientMock.DeleteMailboxV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.DeleteMailboxV1 with params: %#v", *m.DeleteMailboxV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterDeleteMailboxV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorClientMock.DeleteMailboxV1")
	}
}

type mImapConcentratorClientMockGetMailboxV1 struct {
	mock               *ImapConcentratorClientMock
	defaultExpectation *ImapConcentratorClientMockGetMailboxV1Expectation
	expectations       []*ImapConcentratorClientMockGetMailboxV1Expectation

	callArgs []*ImapConcentratorClientMockGetMailboxV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorClientMockGetMailboxV1Expectation specifies expectation struct of the ImapConcentratorClient.GetMailboxV1
type ImapConcentratorClientMockGetMailboxV1Expectation struct {
	mock    *ImapConcentratorClientMock
	params  *ImapConcentratorClientMockGetMailboxV1Params
	results *ImapConcentratorClientMockGetMailboxV1Results
	Counter uint64
}

// ImapConcentratorClientMockGetMailboxV1Params contains parameters of the ImapConcentratorClient.GetMailboxV1
type ImapConcentratorClientMockGetMailboxV1Params struct {
	ctx  context.Context
	in   *GetMailboxV1Request
	opts []grpc.CallOption
}

// ImapConcentratorClientMockGetMailboxV1Results contains results of the ImapConcentratorClient.GetMailboxV1
type ImapConcentratorClientMockGetMailboxV1Results struct {
	gp1 *GetMailboxV1Response
	err error
}

// Expect sets up expected params for ImapConcentratorClient.GetMailboxV1
func (mmGetMailboxV1 *mImapConcentratorClientMockGetMailboxV1) Expect(ctx context.Context, in *GetMailboxV1Request, opts ...grpc.CallOption) *mImapConcentratorClientMockGetMailboxV1 {
	if mmGetMailboxV1.mock.funcGetMailboxV1 != nil {
		mmGetMailboxV1.mock.t.Fatalf("ImapConcentratorClientMock.GetMailboxV1 mock is already set by Set")
	}

	if mmGetMailboxV1.defaultExpectation == nil {
		mmGetMailboxV1.defaultExpectation = &ImapConcentratorClientMockGetMailboxV1Expectation{}
	}

	mmGetMailboxV1.defaultExpectation.params = &ImapConcentratorClientMockGetMailboxV1Params{ctx, in, opts}
	for _, e := range mmGetMailboxV1.expectations {
		if minimock.Equal(e.params, mmGetMailboxV1.defaultExpectation.params) {
			mmGetMailboxV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetMailboxV1.defaultExpectation.params)
		}
	}

	return mmGetMailboxV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorClient.GetMailboxV1
func (mmGetMailboxV1 *mImapConcentratorClientMockGetMailboxV1) Inspect(f func(ctx context.Context, in *GetMailboxV1Request, opts ...grpc.CallOption)) *mImapConcentratorClientMockGetMailboxV1 {
	if mmGetMailboxV1.mock.inspectFuncGetMailboxV1 != nil {
		mmGetMailboxV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorClientMock.GetMailboxV1")
	}

	mmGetMailboxV1.mock.inspectFuncGetMailboxV1 = f

	return mmGetMailboxV1
}

// Return sets up results that will be returned by ImapConcentratorClient.GetMailboxV1
func (mmGetMailboxV1 *mImapConcentratorClientMockGetMailboxV1) Return(gp1 *GetMailboxV1Response, err error) *ImapConcentratorClientMock {
	if mmGetMailboxV1.mock.funcGetMailboxV1 != nil {
		mmGetMailboxV1.mock.t.Fatalf("ImapConcentratorClientMock.GetMailboxV1 mock is already set by Set")
	}

	if mmGetMailboxV1.defaultExpectation == nil {
		mmGetMailboxV1.defaultExpectation = &ImapConcentratorClientMockGetMailboxV1Expectation{mock: mmGetMailboxV1.mock}
	}
	mmGetMailboxV1.defaultExpectation.results = &ImapConcentratorClientMockGetMailboxV1Results{gp1, err}
	return mmGetMailboxV1.mock
}

//Set uses given function f to mock the ImapConcentratorClient.GetMailboxV1 method
func (mmGetMailboxV1 *mImapConcentratorClientMockGetMailboxV1) Set(f func(ctx context.Context, in *GetMailboxV1Request, opts ...grpc.CallOption) (gp1 *GetMailboxV1Response, err error)) *ImapConcentratorClientMock {
	if mmGetMailboxV1.defaultExpectation != nil {
		mmGetMailboxV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorClient.GetMailboxV1 method")
	}

	if len(mmGetMailboxV1.expectations) > 0 {
		mmGetMailboxV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorClient.GetMailboxV1 method")
	}

	mmGetMailboxV1.mock.funcGetMailboxV1 = f
	return mmGetMailboxV1.mock
}

// When sets expectation for the ImapConcentratorClient.GetMailboxV1 which will trigger the result defined by the following
// Then helper
func (mmGetMailboxV1 *mImapConcentratorClientMockGetMailboxV1) When(ctx context.Context, in *GetMailboxV1Request, opts ...grpc.CallOption) *ImapConcentratorClientMockGetMailboxV1Expectation {
	if mmGetMailboxV1.mock.funcGetMailboxV1 != nil {
		mmGetMailboxV1.mock.t.Fatalf("ImapConcentratorClientMock.GetMailboxV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorClientMockGetMailboxV1Expectation{
		mock:   mmGetMailboxV1.mock,
		params: &ImapConcentratorClientMockGetMailboxV1Params{ctx, in, opts},
	}
	mmGetMailboxV1.expectations = append(mmGetMailboxV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorClient.GetMailboxV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorClientMockGetMailboxV1Expectation) Then(gp1 *GetMailboxV1Response, err error) *ImapConcentratorClientMock {
	e.results = &ImapConcentratorClientMockGetMailboxV1Results{gp1, err}
	return e.mock
}

// GetMailboxV1 implements ImapConcentratorClient
func (mmGetMailboxV1 *ImapConcentratorClientMock) GetMailboxV1(ctx context.Context, in *GetMailboxV1Request, opts ...grpc.CallOption) (gp1 *GetMailboxV1Response, err error) {
	mm_atomic.AddUint64(&mmGetMailboxV1.beforeGetMailboxV1Counter, 1)
	defer mm_atomic.AddUint64(&mmGetMailboxV1.afterGetMailboxV1Counter, 1)

	if mmGetMailboxV1.inspectFuncGetMailboxV1 != nil {
		mmGetMailboxV1.inspectFuncGetMailboxV1(ctx, in, opts...)
	}

	mm_params := &ImapConcentratorClientMockGetMailboxV1Params{ctx, in, opts}

	// Record call args
	mmGetMailboxV1.GetMailboxV1Mock.mutex.Lock()
	mmGetMailboxV1.GetMailboxV1Mock.callArgs = append(mmGetMailboxV1.GetMailboxV1Mock.callArgs, mm_params)
	mmGetMailboxV1.GetMailboxV1Mock.mutex.Unlock()

	for _, e := range mmGetMailboxV1.GetMailboxV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetMailboxV1.GetMailboxV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetMailboxV1.GetMailboxV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmGetMailboxV1.GetMailboxV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorClientMockGetMailboxV1Params{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetMailboxV1.t.Errorf("ImapConcentratorClientMock.GetMailboxV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetMailboxV1.GetMailboxV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmGetMailboxV1.t.Fatal("No results are set for the ImapConcentratorClientMock.GetMailboxV1")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetMailboxV1.funcGetMailboxV1 != nil {
		return mmGetMailboxV1.funcGetMailboxV1(ctx, in, opts...)
	}
	mmGetMailboxV1.t.Fatalf("Unexpected call to ImapConcentratorClientMock.GetMailboxV1. %v %v %v", ctx, in, opts)
	return
}

// GetMailboxV1AfterCounter returns a count of finished ImapConcentratorClientMock.GetMailboxV1 invocations
func (mmGetMailboxV1 *ImapConcentratorClientMock) GetMailboxV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMailboxV1.afterGetMailboxV1Counter)
}

// GetMailboxV1BeforeCounter returns a count of ImapConcentratorClientMock.GetMailboxV1 invocations
func (mmGetMailboxV1 *ImapConcentratorClientMock) GetMailboxV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetMailboxV1.beforeGetMailboxV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorClientMock.GetMailboxV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetMailboxV1 *mImapConcentratorClientMockGetMailboxV1) Calls() []*ImapConcentratorClientMockGetMailboxV1Params {
	mmGetMailboxV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorClientMockGetMailboxV1Params, len(mmGetMailboxV1.callArgs))
	copy(argCopy, mmGetMailboxV1.callArgs)

	mmGetMailboxV1.mutex.RUnlock()

	return argCopy
}

// MinimockGetMailboxV1Done returns true if the count of the GetMailboxV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorClientMock) MinimockGetMailboxV1Done() bool {
	for _, e := range m.GetMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMailboxV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterGetMailboxV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockGetMailboxV1Inspect logs each unmet expectation
func (m *ImapConcentratorClientMock) MinimockGetMailboxV1Inspect() {
	for _, e := range m.GetMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.GetMailboxV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetMailboxV1Counter) < 1 {
		if m.GetMailboxV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorClientMock.GetMailboxV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.GetMailboxV1 with params: %#v", *m.GetMailboxV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterGetMailboxV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorClientMock.GetMailboxV1")
	}
}

type mImapConcentratorClientMockInsertChatV1 struct {
	mock               *ImapConcentratorClientMock
	defaultExpectation *ImapConcentratorClientMockInsertChatV1Expectation
	expectations       []*ImapConcentratorClientMockInsertChatV1Expectation

	callArgs []*ImapConcentratorClientMockInsertChatV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorClientMockInsertChatV1Expectation specifies expectation struct of the ImapConcentratorClient.InsertChatV1
type ImapConcentratorClientMockInsertChatV1Expectation struct {
	mock    *ImapConcentratorClientMock
	params  *ImapConcentratorClientMockInsertChatV1Params
	results *ImapConcentratorClientMockInsertChatV1Results
	Counter uint64
}

// ImapConcentratorClientMockInsertChatV1Params contains parameters of the ImapConcentratorClient.InsertChatV1
type ImapConcentratorClientMockInsertChatV1Params struct {
	ctx  context.Context
	in   *InsertChatV1Request
	opts []grpc.CallOption
}

// ImapConcentratorClientMockInsertChatV1Results contains results of the ImapConcentratorClient.InsertChatV1
type ImapConcentratorClientMockInsertChatV1Results struct {
	ap1 *Ack
	err error
}

// Expect sets up expected params for ImapConcentratorClient.InsertChatV1
func (mmInsertChatV1 *mImapConcentratorClientMockInsertChatV1) Expect(ctx context.Context, in *InsertChatV1Request, opts ...grpc.CallOption) *mImapConcentratorClientMockInsertChatV1 {
	if mmInsertChatV1.mock.funcInsertChatV1 != nil {
		mmInsertChatV1.mock.t.Fatalf("ImapConcentratorClientMock.InsertChatV1 mock is already set by Set")
	}

	if mmInsertChatV1.defaultExpectation == nil {
		mmInsertChatV1.defaultExpectation = &ImapConcentratorClientMockInsertChatV1Expectation{}
	}

	mmInsertChatV1.defaultExpectation.params = &ImapConcentratorClientMockInsertChatV1Params{ctx, in, opts}
	for _, e := range mmInsertChatV1.expectations {
		if minimock.Equal(e.params, mmInsertChatV1.defaultExpectation.params) {
			mmInsertChatV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertChatV1.defaultExpectation.params)
		}
	}

	return mmInsertChatV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorClient.InsertChatV1
func (mmInsertChatV1 *mImapConcentratorClientMockInsertChatV1) Inspect(f func(ctx context.Context, in *InsertChatV1Request, opts ...grpc.CallOption)) *mImapConcentratorClientMockInsertChatV1 {
	if mmInsertChatV1.mock.inspectFuncInsertChatV1 != nil {
		mmInsertChatV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorClientMock.InsertChatV1")
	}

	mmInsertChatV1.mock.inspectFuncInsertChatV1 = f

	return mmInsertChatV1
}

// Return sets up results that will be returned by ImapConcentratorClient.InsertChatV1
func (mmInsertChatV1 *mImapConcentratorClientMockInsertChatV1) Return(ap1 *Ack, err error) *ImapConcentratorClientMock {
	if mmInsertChatV1.mock.funcInsertChatV1 != nil {
		mmInsertChatV1.mock.t.Fatalf("ImapConcentratorClientMock.InsertChatV1 mock is already set by Set")
	}

	if mmInsertChatV1.defaultExpectation == nil {
		mmInsertChatV1.defaultExpectation = &ImapConcentratorClientMockInsertChatV1Expectation{mock: mmInsertChatV1.mock}
	}
	mmInsertChatV1.defaultExpectation.results = &ImapConcentratorClientMockInsertChatV1Results{ap1, err}
	return mmInsertChatV1.mock
}

//Set uses given function f to mock the ImapConcentratorClient.InsertChatV1 method
func (mmInsertChatV1 *mImapConcentratorClientMockInsertChatV1) Set(f func(ctx context.Context, in *InsertChatV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error)) *ImapConcentratorClientMock {
	if mmInsertChatV1.defaultExpectation != nil {
		mmInsertChatV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorClient.InsertChatV1 method")
	}

	if len(mmInsertChatV1.expectations) > 0 {
		mmInsertChatV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorClient.InsertChatV1 method")
	}

	mmInsertChatV1.mock.funcInsertChatV1 = f
	return mmInsertChatV1.mock
}

// When sets expectation for the ImapConcentratorClient.InsertChatV1 which will trigger the result defined by the following
// Then helper
func (mmInsertChatV1 *mImapConcentratorClientMockInsertChatV1) When(ctx context.Context, in *InsertChatV1Request, opts ...grpc.CallOption) *ImapConcentratorClientMockInsertChatV1Expectation {
	if mmInsertChatV1.mock.funcInsertChatV1 != nil {
		mmInsertChatV1.mock.t.Fatalf("ImapConcentratorClientMock.InsertChatV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorClientMockInsertChatV1Expectation{
		mock:   mmInsertChatV1.mock,
		params: &ImapConcentratorClientMockInsertChatV1Params{ctx, in, opts},
	}
	mmInsertChatV1.expectations = append(mmInsertChatV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorClient.InsertChatV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorClientMockInsertChatV1Expectation) Then(ap1 *Ack, err error) *ImapConcentratorClientMock {
	e.results = &ImapConcentratorClientMockInsertChatV1Results{ap1, err}
	return e.mock
}

// InsertChatV1 implements ImapConcentratorClient
func (mmInsertChatV1 *ImapConcentratorClientMock) InsertChatV1(ctx context.Context, in *InsertChatV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error) {
	mm_atomic.AddUint64(&mmInsertChatV1.beforeInsertChatV1Counter, 1)
	defer mm_atomic.AddUint64(&mmInsertChatV1.afterInsertChatV1Counter, 1)

	if mmInsertChatV1.inspectFuncInsertChatV1 != nil {
		mmInsertChatV1.inspectFuncInsertChatV1(ctx, in, opts...)
	}

	mm_params := &ImapConcentratorClientMockInsertChatV1Params{ctx, in, opts}

	// Record call args
	mmInsertChatV1.InsertChatV1Mock.mutex.Lock()
	mmInsertChatV1.InsertChatV1Mock.callArgs = append(mmInsertChatV1.InsertChatV1Mock.callArgs, mm_params)
	mmInsertChatV1.InsertChatV1Mock.mutex.Unlock()

	for _, e := range mmInsertChatV1.InsertChatV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmInsertChatV1.InsertChatV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertChatV1.InsertChatV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmInsertChatV1.InsertChatV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorClientMockInsertChatV1Params{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertChatV1.t.Errorf("ImapConcentratorClientMock.InsertChatV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertChatV1.InsertChatV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmInsertChatV1.t.Fatal("No results are set for the ImapConcentratorClientMock.InsertChatV1")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmInsertChatV1.funcInsertChatV1 != nil {
		return mmInsertChatV1.funcInsertChatV1(ctx, in, opts...)
	}
	mmInsertChatV1.t.Fatalf("Unexpected call to ImapConcentratorClientMock.InsertChatV1. %v %v %v", ctx, in, opts)
	return
}

// InsertChatV1AfterCounter returns a count of finished ImapConcentratorClientMock.InsertChatV1 invocations
func (mmInsertChatV1 *ImapConcentratorClientMock) InsertChatV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertChatV1.afterInsertChatV1Counter)
}

// InsertChatV1BeforeCounter returns a count of ImapConcentratorClientMock.InsertChatV1 invocations
func (mmInsertChatV1 *ImapConcentratorClientMock) InsertChatV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertChatV1.beforeInsertChatV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorClientMock.InsertChatV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertChatV1 *mImapConcentratorClientMockInsertChatV1) Calls() []*ImapConcentratorClientMockInsertChatV1Params {
	mmInsertChatV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorClientMockInsertChatV1Params, len(mmInsertChatV1.callArgs))
	copy(argCopy, mmInsertChatV1.callArgs)

	mmInsertChatV1.mutex.RUnlock()

	return argCopy
}

// MinimockInsertChatV1Done returns true if the count of the InsertChatV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorClientMock) MinimockInsertChatV1Done() bool {
	for _, e := range m.InsertChatV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertChatV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertChatV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertChatV1 != nil && mm_atomic.LoadUint64(&m.afterInsertChatV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockInsertChatV1Inspect logs each unmet expectation
func (m *ImapConcentratorClientMock) MinimockInsertChatV1Inspect() {
	for _, e := range m.InsertChatV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.InsertChatV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertChatV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertChatV1Counter) < 1 {
		if m.InsertChatV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorClientMock.InsertChatV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.InsertChatV1 with params: %#v", *m.InsertChatV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertChatV1 != nil && mm_atomic.LoadUint64(&m.afterInsertChatV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorClientMock.InsertChatV1")
	}
}

type mImapConcentratorClientMockInsertMailboxV1 struct {
	mock               *ImapConcentratorClientMock
	defaultExpectation *ImapConcentratorClientMockInsertMailboxV1Expectation
	expectations       []*ImapConcentratorClientMockInsertMailboxV1Expectation

	callArgs []*ImapConcentratorClientMockInsertMailboxV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorClientMockInsertMailboxV1Expectation specifies expectation struct of the ImapConcentratorClient.InsertMailboxV1
type ImapConcentratorClientMockInsertMailboxV1Expectation struct {
	mock    *ImapConcentratorClientMock
	params  *ImapConcentratorClientMockInsertMailboxV1Params
	results *ImapConcentratorClientMockInsertMailboxV1Results
	Counter uint64
}

// ImapConcentratorClientMockInsertMailboxV1Params contains parameters of the ImapConcentratorClient.InsertMailboxV1
type ImapConcentratorClientMockInsertMailboxV1Params struct {
	ctx  context.Context
	in   *InsertMailboxV1Request
	opts []grpc.CallOption
}

// ImapConcentratorClientMockInsertMailboxV1Results contains results of the ImapConcentratorClient.InsertMailboxV1
type ImapConcentratorClientMockInsertMailboxV1Results struct {
	ap1 *Ack
	err error
}

// Expect sets up expected params for ImapConcentratorClient.InsertMailboxV1
func (mmInsertMailboxV1 *mImapConcentratorClientMockInsertMailboxV1) Expect(ctx context.Context, in *InsertMailboxV1Request, opts ...grpc.CallOption) *mImapConcentratorClientMockInsertMailboxV1 {
	if mmInsertMailboxV1.mock.funcInsertMailboxV1 != nil {
		mmInsertMailboxV1.mock.t.Fatalf("ImapConcentratorClientMock.InsertMailboxV1 mock is already set by Set")
	}

	if mmInsertMailboxV1.defaultExpectation == nil {
		mmInsertMailboxV1.defaultExpectation = &ImapConcentratorClientMockInsertMailboxV1Expectation{}
	}

	mmInsertMailboxV1.defaultExpectation.params = &ImapConcentratorClientMockInsertMailboxV1Params{ctx, in, opts}
	for _, e := range mmInsertMailboxV1.expectations {
		if minimock.Equal(e.params, mmInsertMailboxV1.defaultExpectation.params) {
			mmInsertMailboxV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInsertMailboxV1.defaultExpectation.params)
		}
	}

	return mmInsertMailboxV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorClient.InsertMailboxV1
func (mmInsertMailboxV1 *mImapConcentratorClientMockInsertMailboxV1) Inspect(f func(ctx context.Context, in *InsertMailboxV1Request, opts ...grpc.CallOption)) *mImapConcentratorClientMockInsertMailboxV1 {
	if mmInsertMailboxV1.mock.inspectFuncInsertMailboxV1 != nil {
		mmInsertMailboxV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorClientMock.InsertMailboxV1")
	}

	mmInsertMailboxV1.mock.inspectFuncInsertMailboxV1 = f

	return mmInsertMailboxV1
}

// Return sets up results that will be returned by ImapConcentratorClient.InsertMailboxV1
func (mmInsertMailboxV1 *mImapConcentratorClientMockInsertMailboxV1) Return(ap1 *Ack, err error) *ImapConcentratorClientMock {
	if mmInsertMailboxV1.mock.funcInsertMailboxV1 != nil {
		mmInsertMailboxV1.mock.t.Fatalf("ImapConcentratorClientMock.InsertMailboxV1 mock is already set by Set")
	}

	if mmInsertMailboxV1.defaultExpectation == nil {
		mmInsertMailboxV1.defaultExpectation = &ImapConcentratorClientMockInsertMailboxV1Expectation{mock: mmInsertMailboxV1.mock}
	}
	mmInsertMailboxV1.defaultExpectation.results = &ImapConcentratorClientMockInsertMailboxV1Results{ap1, err}
	return mmInsertMailboxV1.mock
}

//Set uses given function f to mock the ImapConcentratorClient.InsertMailboxV1 method
func (mmInsertMailboxV1 *mImapConcentratorClientMockInsertMailboxV1) Set(f func(ctx context.Context, in *InsertMailboxV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error)) *ImapConcentratorClientMock {
	if mmInsertMailboxV1.defaultExpectation != nil {
		mmInsertMailboxV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorClient.InsertMailboxV1 method")
	}

	if len(mmInsertMailboxV1.expectations) > 0 {
		mmInsertMailboxV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorClient.InsertMailboxV1 method")
	}

	mmInsertMailboxV1.mock.funcInsertMailboxV1 = f
	return mmInsertMailboxV1.mock
}

// When sets expectation for the ImapConcentratorClient.InsertMailboxV1 which will trigger the result defined by the following
// Then helper
func (mmInsertMailboxV1 *mImapConcentratorClientMockInsertMailboxV1) When(ctx context.Context, in *InsertMailboxV1Request, opts ...grpc.CallOption) *ImapConcentratorClientMockInsertMailboxV1Expectation {
	if mmInsertMailboxV1.mock.funcInsertMailboxV1 != nil {
		mmInsertMailboxV1.mock.t.Fatalf("ImapConcentratorClientMock.InsertMailboxV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorClientMockInsertMailboxV1Expectation{
		mock:   mmInsertMailboxV1.mock,
		params: &ImapConcentratorClientMockInsertMailboxV1Params{ctx, in, opts},
	}
	mmInsertMailboxV1.expectations = append(mmInsertMailboxV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorClient.InsertMailboxV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorClientMockInsertMailboxV1Expectation) Then(ap1 *Ack, err error) *ImapConcentratorClientMock {
	e.results = &ImapConcentratorClientMockInsertMailboxV1Results{ap1, err}
	return e.mock
}

// InsertMailboxV1 implements ImapConcentratorClient
func (mmInsertMailboxV1 *ImapConcentratorClientMock) InsertMailboxV1(ctx context.Context, in *InsertMailboxV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error) {
	mm_atomic.AddUint64(&mmInsertMailboxV1.beforeInsertMailboxV1Counter, 1)
	defer mm_atomic.AddUint64(&mmInsertMailboxV1.afterInsertMailboxV1Counter, 1)

	if mmInsertMailboxV1.inspectFuncInsertMailboxV1 != nil {
		mmInsertMailboxV1.inspectFuncInsertMailboxV1(ctx, in, opts...)
	}

	mm_params := &ImapConcentratorClientMockInsertMailboxV1Params{ctx, in, opts}

	// Record call args
	mmInsertMailboxV1.InsertMailboxV1Mock.mutex.Lock()
	mmInsertMailboxV1.InsertMailboxV1Mock.callArgs = append(mmInsertMailboxV1.InsertMailboxV1Mock.callArgs, mm_params)
	mmInsertMailboxV1.InsertMailboxV1Mock.mutex.Unlock()

	for _, e := range mmInsertMailboxV1.InsertMailboxV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmInsertMailboxV1.InsertMailboxV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInsertMailboxV1.InsertMailboxV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmInsertMailboxV1.InsertMailboxV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorClientMockInsertMailboxV1Params{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInsertMailboxV1.t.Errorf("ImapConcentratorClientMock.InsertMailboxV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInsertMailboxV1.InsertMailboxV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmInsertMailboxV1.t.Fatal("No results are set for the ImapConcentratorClientMock.InsertMailboxV1")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmInsertMailboxV1.funcInsertMailboxV1 != nil {
		return mmInsertMailboxV1.funcInsertMailboxV1(ctx, in, opts...)
	}
	mmInsertMailboxV1.t.Fatalf("Unexpected call to ImapConcentratorClientMock.InsertMailboxV1. %v %v %v", ctx, in, opts)
	return
}

// InsertMailboxV1AfterCounter returns a count of finished ImapConcentratorClientMock.InsertMailboxV1 invocations
func (mmInsertMailboxV1 *ImapConcentratorClientMock) InsertMailboxV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertMailboxV1.afterInsertMailboxV1Counter)
}

// InsertMailboxV1BeforeCounter returns a count of ImapConcentratorClientMock.InsertMailboxV1 invocations
func (mmInsertMailboxV1 *ImapConcentratorClientMock) InsertMailboxV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInsertMailboxV1.beforeInsertMailboxV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorClientMock.InsertMailboxV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInsertMailboxV1 *mImapConcentratorClientMockInsertMailboxV1) Calls() []*ImapConcentratorClientMockInsertMailboxV1Params {
	mmInsertMailboxV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorClientMockInsertMailboxV1Params, len(mmInsertMailboxV1.callArgs))
	copy(argCopy, mmInsertMailboxV1.callArgs)

	mmInsertMailboxV1.mutex.RUnlock()

	return argCopy
}

// MinimockInsertMailboxV1Done returns true if the count of the InsertMailboxV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorClientMock) MinimockInsertMailboxV1Done() bool {
	for _, e := range m.InsertMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertMailboxV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterInsertMailboxV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockInsertMailboxV1Inspect logs each unmet expectation
func (m *ImapConcentratorClientMock) MinimockInsertMailboxV1Inspect() {
	for _, e := range m.InsertMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.InsertMailboxV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InsertMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInsertMailboxV1Counter) < 1 {
		if m.InsertMailboxV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorClientMock.InsertMailboxV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.InsertMailboxV1 with params: %#v", *m.InsertMailboxV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInsertMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterInsertMailboxV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorClientMock.InsertMailboxV1")
	}
}

type mImapConcentratorClientMockListMailboxesV1 struct {
	mock               *ImapConcentratorClientMock
	defaultExpectation *ImapConcentratorClientMockListMailboxesV1Expectation
	expectations       []*ImapConcentratorClientMockListMailboxesV1Expectation

	callArgs []*ImapConcentratorClientMockListMailboxesV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorClientMockListMailboxesV1Expectation specifies expectation struct of the ImapConcentratorClient.ListMailboxesV1
type ImapConcentratorClientMockListMailboxesV1Expectation struct {
	mock    *ImapConcentratorClientMock
	params  *ImapConcentratorClientMockListMailboxesV1Params
	results *ImapConcentratorClientMockListMailboxesV1Results
	Counter uint64
}

// ImapConcentratorClientMockListMailboxesV1Params contains parameters of the ImapConcentratorClient.ListMailboxesV1
type ImapConcentratorClientMockListMailboxesV1Params struct {
	ctx  context.Context
	in   *ListMailboxesV1Request
	opts []grpc.CallOption
}

// ImapConcentratorClientMockListMailboxesV1Results contains results of the ImapConcentratorClient.ListMailboxesV1
type ImapConcentratorClientMockListMailboxesV1Results struct {
	lp1 *ListMailboxesV1Response
	err error
}

// Expect sets up expected params for ImapConcentratorClient.ListMailboxesV1
func (mmListMailboxesV1 *mImapConcentratorClientMockListMailboxesV1) Expect(ctx context.Context, in *ListMailboxesV1Request, opts ...grpc.CallOption) *mImapConcentratorClientMockListMailboxesV1 {
	if mmListMailboxesV1.mock.funcListMailboxesV1 != nil {
		mmListMailboxesV1.mock.t.Fatalf("ImapConcentratorClientMock.ListMailboxesV1 mock is already set by Set")
	}

	if mmListMailboxesV1.defaultExpectation == nil {
		mmListMailboxesV1.defaultExpectation = &ImapConcentratorClientMockListMailboxesV1Expectation{}
	}

	mmListMailboxesV1.defaultExpectation.params = &ImapConcentratorClientMockListMailboxesV1Params{ctx, in, opts}
	for _, e := range mmListMailboxesV1.expectations {
		if minimock.Equal(e.params, mmListMailboxesV1.defaultExpectation.params) {
			mmListMailboxesV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListMailboxesV1.defaultExpectation.params)
		}
	}

	return mmListMailboxesV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorClient.ListMailboxesV1
func (mmListMailboxesV1 *mImapConcentratorClientMockListMailboxesV1) Inspect(f func(ctx context.Context, in *ListMailboxesV1Request, opts ...grpc.CallOption)) *mImapConcentratorClientMockListMailboxesV1 {
	if mmListMailboxesV1.mock.inspectFuncListMailboxesV1 != nil {
		mmListMailboxesV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorClientMock.ListMailboxesV1")
	}

	mmListMailboxesV1.mock.inspectFuncListMailboxesV1 = f

	return mmListMailboxesV1
}

// Return sets up results that will be returned by ImapConcentratorClient.ListMailboxesV1
func (mmListMailboxesV1 *mImapConcentratorClientMockListMailboxesV1) Return(lp1 *ListMailboxesV1Response, err error) *ImapConcentratorClientMock {
	if mmListMailboxesV1.mock.funcListMailboxesV1 != nil {
		mmListMailboxesV1.mock.t.Fatalf("ImapConcentratorClientMock.ListMailboxesV1 mock is already set by Set")
	}

	if mmListMailboxesV1.defaultExpectation == nil {
		mmListMailboxesV1.defaultExpectation = &ImapConcentratorClientMockListMailboxesV1Expectation{mock: mmListMailboxesV1.mock}
	}
	mmListMailboxesV1.defaultExpectation.results = &ImapConcentratorClientMockListMailboxesV1Results{lp1, err}
	return mmListMailboxesV1.mock
}

//Set uses given function f to mock the ImapConcentratorClient.ListMailboxesV1 method
func (mmListMailboxesV1 *mImapConcentratorClientMockListMailboxesV1) Set(f func(ctx context.Context, in *ListMailboxesV1Request, opts ...grpc.CallOption) (lp1 *ListMailboxesV1Response, err error)) *ImapConcentratorClientMock {
	if mmListMailboxesV1.defaultExpectation != nil {
		mmListMailboxesV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorClient.ListMailboxesV1 method")
	}

	if len(mmListMailboxesV1.expectations) > 0 {
		mmListMailboxesV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorClient.ListMailboxesV1 method")
	}

	mmListMailboxesV1.mock.funcListMailboxesV1 = f
	return mmListMailboxesV1.mock
}

// When sets expectation for the ImapConcentratorClient.ListMailboxesV1 which will trigger the result defined by the following
// Then helper
func (mmListMailboxesV1 *mImapConcentratorClientMockListMailboxesV1) When(ctx context.Context, in *ListMailboxesV1Request, opts ...grpc.CallOption) *ImapConcentratorClientMockListMailboxesV1Expectation {
	if mmListMailboxesV1.mock.funcListMailboxesV1 != nil {
		mmListMailboxesV1.mock.t.Fatalf("ImapConcentratorClientMock.ListMailboxesV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorClientMockListMailboxesV1Expectation{
		mock:   mmListMailboxesV1.mock,
		params: &ImapConcentratorClientMockListMailboxesV1Params{ctx, in, opts},
	}
	mmListMailboxesV1.expectations = append(mmListMailboxesV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorClient.ListMailboxesV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorClientMockListMailboxesV1Expectation) Then(lp1 *ListMailboxesV1Response, err error) *ImapConcentratorClientMock {
	e.results = &ImapConcentratorClientMockListMailboxesV1Results{lp1, err}
	return e.mock
}

// ListMailboxesV1 implements ImapConcentratorClient
func (mmListMailboxesV1 *ImapConcentratorClientMock) ListMailboxesV1(ctx context.Context, in *ListMailboxesV1Request, opts ...grpc.CallOption) (lp1 *ListMailboxesV1Response, err error) {
	mm_atomic.AddUint64(&mmListMailboxesV1.beforeListMailboxesV1Counter, 1)
	defer mm_atomic.AddUint64(&mmListMailboxesV1.afterListMailboxesV1Counter, 1)

	if mmListMailboxesV1.inspectFuncListMailboxesV1 != nil {
		mmListMailboxesV1.inspectFuncListMailboxesV1(ctx, in, opts...)
	}

	mm_params := &ImapConcentratorClientMockListMailboxesV1Params{ctx, in, opts}

	// Record call args
	mmListMailboxesV1.ListMailboxesV1Mock.mutex.Lock()
	mmListMailboxesV1.ListMailboxesV1Mock.callArgs = append(mmListMailboxesV1.ListMailboxesV1Mock.callArgs, mm_params)
	mmListMailboxesV1.ListMailboxesV1Mock.mutex.Unlock()

	for _, e := range mmListMailboxesV1.ListMailboxesV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.lp1, e.results.err
		}
	}

	if mmListMailboxesV1.ListMailboxesV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListMailboxesV1.ListMailboxesV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmListMailboxesV1.ListMailboxesV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorClientMockListMailboxesV1Params{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListMailboxesV1.t.Errorf("ImapConcentratorClientMock.ListMailboxesV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListMailboxesV1.ListMailboxesV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmListMailboxesV1.t.Fatal("No results are set for the ImapConcentratorClientMock.ListMailboxesV1")
		}
		return (*mm_results).lp1, (*mm_results).err
	}
	if mmListMailboxesV1.funcListMailboxesV1 != nil {
		return mmListMailboxesV1.funcListMailboxesV1(ctx, in, opts...)
	}
	mmListMailboxesV1.t.Fatalf("Unexpected call to ImapConcentratorClientMock.ListMailboxesV1. %v %v %v", ctx, in, opts)
	return
}

// ListMailboxesV1AfterCounter returns a count of finished ImapConcentratorClientMock.ListMailboxesV1 invocations
func (mmListMailboxesV1 *ImapConcentratorClientMock) ListMailboxesV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListMailboxesV1.afterListMailboxesV1Counter)
}

// ListMailboxesV1BeforeCounter returns a count of ImapConcentratorClientMock.ListMailboxesV1 invocations
func (mmListMailboxesV1 *ImapConcentratorClientMock) ListMailboxesV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListMailboxesV1.beforeListMailboxesV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorClientMock.ListMailboxesV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListMailboxesV1 *mImapConcentratorClientMockListMailboxesV1) Calls() []*ImapConcentratorClientMockListMailboxesV1Params {
	mmListMailboxesV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorClientMockListMailboxesV1Params, len(mmListMailboxesV1.callArgs))
	copy(argCopy, mmListMailboxesV1.callArgs)

	mmListMailboxesV1.mutex.RUnlock()

	return argCopy
}

// MinimockListMailboxesV1Done returns true if the count of the ListMailboxesV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorClientMock) MinimockListMailboxesV1Done() bool {
	for _, e := range m.ListMailboxesV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMailboxesV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListMailboxesV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListMailboxesV1 != nil && mm_atomic.LoadUint64(&m.afterListMailboxesV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockListMailboxesV1Inspect logs each unmet expectation
func (m *ImapConcentratorClientMock) MinimockListMailboxesV1Inspect() {
	for _, e := range m.ListMailboxesV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.ListMailboxesV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListMailboxesV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListMailboxesV1Counter) < 1 {
		if m.ListMailboxesV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorClientMock.ListMailboxesV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.ListMailboxesV1 with params: %#v", *m.ListMailboxesV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListMailboxesV1 != nil && mm_atomic.LoadUint64(&m.afterListMailboxesV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorClientMock.ListMailboxesV1")
	}
}

type mImapConcentratorClientMockPollV1 struct {
	mock               *ImapConcentratorClientMock
	defaultExpectation *ImapConcentratorClientMockPollV1Expectation
	expectations       []*ImapConcentratorClientMockPollV1Expectation

	callArgs []*ImapConcentratorClientMockPollV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorClientMockPollV1Expectation specifies expectation struct of the ImapConcentratorClient.PollV1
type ImapConcentratorClientMockPollV1Expectation struct {
	mock    *ImapConcentratorClientMock
	params  *ImapConcentratorClientMockPollV1Params
	results *ImapConcentratorClientMockPollV1Results
	Counter uint64
}

// ImapConcentratorClientMockPollV1Params contains parameters of the ImapConcentratorClient.PollV1
type ImapConcentratorClientMockPollV1Params struct {
	ctx  context.Context
	in   *PollV1Request
	opts []grpc.CallOption
}

// ImapConcentratorClientMockPollV1Results contains results of the ImapConcentratorClient.PollV1
type ImapConcentratorClientMockPollV1Results struct {
	ap1 *Ack
	err error
}

// Expect sets up expected params for ImapConcentratorClient.PollV1
func (mmPollV1 *mImapConcentratorClientMockPollV1) Expect(ctx context.Context, in *PollV1Request, opts ...grpc.CallOption) *mImapConcentratorClientMockPollV1 {
	if mmPollV1.mock.funcPollV1 != nil {
		mmPollV1.mock.t.Fatalf("ImapConcentratorClientMock.PollV1 mock is already set by Set")
	}

	if mmPollV1.defaultExpectation == nil {
		mmPollV1.defaultExpectation = &ImapConcentratorClientMockPollV1Expectation{}
	}

	mmPollV1.defaultExpectation.params = &ImapConcentratorClientMockPollV1Params{ctx, in, opts}
	for _, e := range mmPollV1.expectations {
		if minimock.Equal(e.params, mmPollV1.defaultExpectation.params) {
			mmPollV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPollV1.defaultExpectation.params)
		}
	}

	return mmPollV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorClient.PollV1
func (mmPollV1 *mImapConcentratorClientMockPollV1) Inspect(f func(ctx context.Context, in *PollV1Request, opts ...grpc.CallOption)) *mImapConcentratorClientMockPollV1 {
	if mmPollV1.mock.inspectFuncPollV1 != nil {
		mmPollV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorClientMock.PollV1")
	}

	mmPollV1.mock.inspectFuncPollV1 = f

	return mmPollV1
}

// Return sets up results that will be returned by ImapConcentratorClient.PollV1
func (mmPollV1 *mImapConcentratorClientMockPollV1) Return(ap1 *Ack, err error) *ImapConcentratorClientMock {
	if mmPollV1.mock.funcPollV1 != nil {
		mmPollV1.mock.t.Fatalf("ImapConcentratorClientMock.PollV1 mock is already set by Set")
	}

	if mmPollV1.defaultExpectation == nil {
		mmPollV1.defaultExpectation = &ImapConcentratorClientMockPollV1Expectation{mock: mmPollV1.mock}
	}
	mmPollV1.defaultExpectation.results = &ImapConcentratorClientMockPollV1Results{ap1, err}
	return mmPollV1.mock
}

//Set uses given function f to mock the ImapConcentratorClient.PollV1 method
func (mmPollV1 *mImapConcentratorClientMockPollV1) Set(f func(ctx context.Context, in *PollV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error)) *ImapConcentratorClientMock {
	if mmPollV1.defaultExpectation != nil {
		mmPollV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorClient.PollV1 method")
	}

	if len(mmPollV1.expectations) > 0 {
		mmPollV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorClient.PollV1 method")
	}

	mmPollV1.mock.funcPollV1 = f
	return mmPollV1.mock
}

// When sets expectation for the ImapConcentratorClient.PollV1 which will trigger the result defined by the following
// Then helper
func (mmPollV1 *mImapConcentratorClientMockPollV1) When(ctx context.Context, in *PollV1Request, opts ...grpc.CallOption) *ImapConcentratorClientMockPollV1Expectation {
	if mmPollV1.mock.funcPollV1 != nil {
		mmPollV1.mock.t.Fatalf("ImapConcentratorClientMock.PollV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorClientMockPollV1Expectation{
		mock:   mmPollV1.mock,
		params: &ImapConcentratorClientMockPollV1Params{ctx, in, opts},
	}
	mmPollV1.expectations = append(mmPollV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorClient.PollV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorClientMockPollV1Expectation) Then(ap1 *Ack, err error) *ImapConcentratorClientMock {
	e.results = &ImapConcentratorClientMockPollV1Results{ap1, err}
	return e.mock
}

// PollV1 implements ImapConcentratorClient
func (mmPollV1 *ImapConcentratorClientMock) PollV1(ctx context.Context, in *PollV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error) {
	mm_atomic.AddUint64(&mmPollV1.beforePollV1Counter, 1)
	defer mm_atomic.AddUint64(&mmPollV1.afterPollV1Counter, 1)

	if mmPollV1.inspectFuncPollV1 != nil {
		mmPollV1.inspectFuncPollV1(ctx, in, opts...)
	}

	mm_params := &ImapConcentratorClientMockPollV1Params{ctx, in, opts}

	// Record call args
	mmPollV1.PollV1Mock.mutex.Lock()
	mmPollV1.PollV1Mock.callArgs = append(mmPollV1.PollV1Mock.callArgs, mm_params)
	mmPollV1.PollV1Mock.mutex.Unlock()

	for _, e := range mmPollV1.PollV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmPollV1.PollV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPollV1.PollV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmPollV1.PollV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorClientMockPollV1Params{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPollV1.t.Errorf("ImapConcentratorClientMock.PollV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPollV1.PollV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmPollV1.t.Fatal("No results are set for the ImapConcentratorClientMock.PollV1")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmPollV1.funcPollV1 != nil {
		return mmPollV1.funcPollV1(ctx, in, opts...)
	}
	mmPollV1.t.Fatalf("Unexpected call to ImapConcentratorClientMock.PollV1. %v %v %v", ctx, in, opts)
	return
}

// PollV1AfterCounter returns a count of finished ImapConcentratorClientMock.PollV1 invocations
func (mmPollV1 *ImapConcentratorClientMock) PollV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPollV1.afterPollV1Counter)
}

// PollV1BeforeCounter returns a count of ImapConcentratorClientMock.PollV1 invocations
func (mmPollV1 *ImapConcentratorClientMock) PollV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPollV1.beforePollV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorClientMock.PollV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPollV1 *mImapConcentratorClientMockPollV1) Calls() []*ImapConcentratorClientMockPollV1Params {
	mmPollV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorClientMockPollV1Params, len(mmPollV1.callArgs))
	copy(argCopy, mmPollV1.callArgs)

	mmPollV1.mutex.RUnlock()

	return argCopy
}

// MinimockPollV1Done returns true if the count of the PollV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorClientMock) MinimockPollV1Done() bool {
	for _, e := range m.PollV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PollV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPollV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPollV1 != nil && mm_atomic.LoadUint64(&m.afterPollV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockPollV1Inspect logs each unmet expectation
func (m *ImapConcentratorClientMock) MinimockPollV1Inspect() {
	for _, e := range m.PollV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.PollV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PollV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPollV1Counter) < 1 {
		if m.PollV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorClientMock.PollV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.PollV1 with params: %#v", *m.PollV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPollV1 != nil && mm_atomic.LoadUint64(&m.afterPollV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorClientMock.PollV1")
	}
}

type mImapConcentratorClientMockSubscribeToAllNotificationsV1 struct {
	mock               *ImapConcentratorClientMock
	defaultExpectation *ImapConcentratorClientMockSubscribeToAllNotificationsV1Expectation
	expectations       []*ImapConcentratorClientMockSubscribeToAllNotificationsV1Expectation

	callArgs []*ImapConcentratorClientMockSubscribeToAllNotificationsV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorClientMockSubscribeToAllNotificationsV1Expectation specifies expectation struct of the ImapConcentratorClient.SubscribeToAllNotificationsV1
type ImapConcentratorClientMockSubscribeToAllNotificationsV1Expectation struct {
	mock    *ImapConcentratorClientMock
	params  *ImapConcentratorClientMockSubscribeToAllNotificationsV1Params
	results *ImapConcentratorClientMockSubscribeToAllNotificationsV1Results
	Counter uint64
}

// ImapConcentratorClientMockSubscribeToAllNotificationsV1Params contains parameters of the ImapConcentratorClient.SubscribeToAllNotificationsV1
type ImapConcentratorClientMockSubscribeToAllNotificationsV1Params struct {
	ctx  context.Context
	in   *SubscribeToAllNotificationsV1Request
	opts []grpc.CallOption
}

// ImapConcentratorClientMockSubscribeToAllNotificationsV1Results contains results of the ImapConcentratorClient.SubscribeToAllNotificationsV1
type ImapConcentratorClientMockSubscribeToAllNotificationsV1Results struct {
	i1  ImapConcentrator_SubscribeToAllNotificationsV1Client
	err error
}

// Expect sets up expected params for ImapConcentratorClient.SubscribeToAllNotificationsV1
func (mmSubscribeToAllNotificationsV1 *mImapConcentratorClientMockSubscribeToAllNotificationsV1) Expect(ctx context.Context, in *SubscribeToAllNotificationsV1Request, opts ...grpc.CallOption) *mImapConcentratorClientMockSubscribeToAllNotificationsV1 {
	if mmSubscribeToAllNotificationsV1.mock.funcSubscribeToAllNotificationsV1 != nil {
		mmSubscribeToAllNotificationsV1.mock.t.Fatalf("ImapConcentratorClientMock.SubscribeToAllNotificationsV1 mock is already set by Set")
	}

	if mmSubscribeToAllNotificationsV1.defaultExpectation == nil {
		mmSubscribeToAllNotificationsV1.defaultExpectation = &ImapConcentratorClientMockSubscribeToAllNotificationsV1Expectation{}
	}

	mmSubscribeToAllNotificationsV1.defaultExpectation.params = &ImapConcentratorClientMockSubscribeToAllNotificationsV1Params{ctx, in, opts}
	for _, e := range mmSubscribeToAllNotificationsV1.expectations {
		if minimock.Equal(e.params, mmSubscribeToAllNotificationsV1.defaultExpectation.params) {
			mmSubscribeToAllNotificationsV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubscribeToAllNotificationsV1.defaultExpectation.params)
		}
	}

	return mmSubscribeToAllNotificationsV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorClient.SubscribeToAllNotificationsV1
func (mmSubscribeToAllNotificationsV1 *mImapConcentratorClientMockSubscribeToAllNotificationsV1) Inspect(f func(ctx context.Context, in *SubscribeToAllNotificationsV1Request, opts ...grpc.CallOption)) *mImapConcentratorClientMockSubscribeToAllNotificationsV1 {
	if mmSubscribeToAllNotificationsV1.mock.inspectFuncSubscribeToAllNotificationsV1 != nil {
		mmSubscribeToAllNotificationsV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorClientMock.SubscribeToAllNotificationsV1")
	}

	mmSubscribeToAllNotificationsV1.mock.inspectFuncSubscribeToAllNotificationsV1 = f

	return mmSubscribeToAllNotificationsV1
}

// Return sets up results that will be returned by ImapConcentratorClient.SubscribeToAllNotificationsV1
func (mmSubscribeToAllNotificationsV1 *mImapConcentratorClientMockSubscribeToAllNotificationsV1) Return(i1 ImapConcentrator_SubscribeToAllNotificationsV1Client, err error) *ImapConcentratorClientMock {
	if mmSubscribeToAllNotificationsV1.mock.funcSubscribeToAllNotificationsV1 != nil {
		mmSubscribeToAllNotificationsV1.mock.t.Fatalf("ImapConcentratorClientMock.SubscribeToAllNotificationsV1 mock is already set by Set")
	}

	if mmSubscribeToAllNotificationsV1.defaultExpectation == nil {
		mmSubscribeToAllNotificationsV1.defaultExpectation = &ImapConcentratorClientMockSubscribeToAllNotificationsV1Expectation{mock: mmSubscribeToAllNotificationsV1.mock}
	}
	mmSubscribeToAllNotificationsV1.defaultExpectation.results = &ImapConcentratorClientMockSubscribeToAllNotificationsV1Results{i1, err}
	return mmSubscribeToAllNotificationsV1.mock
}

//Set uses given function f to mock the ImapConcentratorClient.SubscribeToAllNotificationsV1 method
func (mmSubscribeToAllNotificationsV1 *mImapConcentratorClientMockSubscribeToAllNotificationsV1) Set(f func(ctx context.Context, in *SubscribeToAllNotificationsV1Request, opts ...grpc.CallOption) (i1 ImapConcentrator_SubscribeToAllNotificationsV1Client, err error)) *ImapConcentratorClientMock {
	if mmSubscribeToAllNotificationsV1.defaultExpectation != nil {
		mmSubscribeToAllNotificationsV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorClient.SubscribeToAllNotificationsV1 method")
	}

	if len(mmSubscribeToAllNotificationsV1.expectations) > 0 {
		mmSubscribeToAllNotificationsV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorClient.SubscribeToAllNotificationsV1 method")
	}

	mmSubscribeToAllNotificationsV1.mock.funcSubscribeToAllNotificationsV1 = f
	return mmSubscribeToAllNotificationsV1.mock
}

// When sets expectation for the ImapConcentratorClient.SubscribeToAllNotificationsV1 which will trigger the result defined by the following
// Then helper
func (mmSubscribeToAllNotificationsV1 *mImapConcentratorClientMockSubscribeToAllNotificationsV1) When(ctx context.Context, in *SubscribeToAllNotificationsV1Request, opts ...grpc.CallOption) *ImapConcentratorClientMockSubscribeToAllNotificationsV1Expectation {
	if mmSubscribeToAllNotificationsV1.mock.funcSubscribeToAllNotificationsV1 != nil {
		mmSubscribeToAllNotificationsV1.mock.t.Fatalf("ImapConcentratorClientMock.SubscribeToAllNotificationsV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorClientMockSubscribeToAllNotificationsV1Expectation{
		mock:   mmSubscribeToAllNotificationsV1.mock,
		params: &ImapConcentratorClientMockSubscribeToAllNotificationsV1Params{ctx, in, opts},
	}
	mmSubscribeToAllNotificationsV1.expectations = append(mmSubscribeToAllNotificationsV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorClient.SubscribeToAllNotificationsV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorClientMockSubscribeToAllNotificationsV1Expectation) Then(i1 ImapConcentrator_SubscribeToAllNotificationsV1Client, err error) *ImapConcentratorClientMock {
	e.results = &ImapConcentratorClientMockSubscribeToAllNotificationsV1Results{i1, err}
	return e.mock
}

// SubscribeToAllNotificationsV1 implements ImapConcentratorClient
func (mmSubscribeToAllNotificationsV1 *ImapConcentratorClientMock) SubscribeToAllNotificationsV1(ctx context.Context, in *SubscribeToAllNotificationsV1Request, opts ...grpc.CallOption) (i1 ImapConcentrator_SubscribeToAllNotificationsV1Client, err error) {
	mm_atomic.AddUint64(&mmSubscribeToAllNotificationsV1.beforeSubscribeToAllNotificationsV1Counter, 1)
	defer mm_atomic.AddUint64(&mmSubscribeToAllNotificationsV1.afterSubscribeToAllNotificationsV1Counter, 1)

	if mmSubscribeToAllNotificationsV1.inspectFuncSubscribeToAllNotificationsV1 != nil {
		mmSubscribeToAllNotificationsV1.inspectFuncSubscribeToAllNotificationsV1(ctx, in, opts...)
	}

	mm_params := &ImapConcentratorClientMockSubscribeToAllNotificationsV1Params{ctx, in, opts}

	// Record call args
	mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.mutex.Lock()
	mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.callArgs = append(mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.callArgs, mm_params)
	mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.mutex.Unlock()

	for _, e := range mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorClientMockSubscribeToAllNotificationsV1Params{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubscribeToAllNotificationsV1.t.Errorf("ImapConcentratorClientMock.SubscribeToAllNotificationsV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSubscribeToAllNotificationsV1.SubscribeToAllNotificationsV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmSubscribeToAllNotificationsV1.t.Fatal("No results are set for the ImapConcentratorClientMock.SubscribeToAllNotificationsV1")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmSubscribeToAllNotificationsV1.funcSubscribeToAllNotificationsV1 != nil {
		return mmSubscribeToAllNotificationsV1.funcSubscribeToAllNotificationsV1(ctx, in, opts...)
	}
	mmSubscribeToAllNotificationsV1.t.Fatalf("Unexpected call to ImapConcentratorClientMock.SubscribeToAllNotificationsV1. %v %v %v", ctx, in, opts)
	return
}

// SubscribeToAllNotificationsV1AfterCounter returns a count of finished ImapConcentratorClientMock.SubscribeToAllNotificationsV1 invocations
func (mmSubscribeToAllNotificationsV1 *ImapConcentratorClientMock) SubscribeToAllNotificationsV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribeToAllNotificationsV1.afterSubscribeToAllNotificationsV1Counter)
}

// SubscribeToAllNotificationsV1BeforeCounter returns a count of ImapConcentratorClientMock.SubscribeToAllNotificationsV1 invocations
func (mmSubscribeToAllNotificationsV1 *ImapConcentratorClientMock) SubscribeToAllNotificationsV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribeToAllNotificationsV1.beforeSubscribeToAllNotificationsV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorClientMock.SubscribeToAllNotificationsV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubscribeToAllNotificationsV1 *mImapConcentratorClientMockSubscribeToAllNotificationsV1) Calls() []*ImapConcentratorClientMockSubscribeToAllNotificationsV1Params {
	mmSubscribeToAllNotificationsV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorClientMockSubscribeToAllNotificationsV1Params, len(mmSubscribeToAllNotificationsV1.callArgs))
	copy(argCopy, mmSubscribeToAllNotificationsV1.callArgs)

	mmSubscribeToAllNotificationsV1.mutex.RUnlock()

	return argCopy
}

// MinimockSubscribeToAllNotificationsV1Done returns true if the count of the SubscribeToAllNotificationsV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorClientMock) MinimockSubscribeToAllNotificationsV1Done() bool {
	for _, e := range m.SubscribeToAllNotificationsV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeToAllNotificationsV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeToAllNotificationsV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribeToAllNotificationsV1 != nil && mm_atomic.LoadUint64(&m.afterSubscribeToAllNotificationsV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockSubscribeToAllNotificationsV1Inspect logs each unmet expectation
func (m *ImapConcentratorClientMock) MinimockSubscribeToAllNotificationsV1Inspect() {
	for _, e := range m.SubscribeToAllNotificationsV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.SubscribeToAllNotificationsV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeToAllNotificationsV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeToAllNotificationsV1Counter) < 1 {
		if m.SubscribeToAllNotificationsV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorClientMock.SubscribeToAllNotificationsV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.SubscribeToAllNotificationsV1 with params: %#v", *m.SubscribeToAllNotificationsV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribeToAllNotificationsV1 != nil && mm_atomic.LoadUint64(&m.afterSubscribeToAllNotificationsV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorClientMock.SubscribeToAllNotificationsV1")
	}
}

type mImapConcentratorClientMockSubscribeToChatNotificationsV1 struct {
	mock               *ImapConcentratorClientMock
	defaultExpectation *ImapConcentratorClientMockSubscribeToChatNotificationsV1Expectation
	expectations       []*ImapConcentratorClientMockSubscribeToChatNotificationsV1Expectation

	callArgs []*ImapConcentratorClientMockSubscribeToChatNotificationsV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorClientMockSubscribeToChatNotificationsV1Expectation specifies expectation struct of the ImapConcentratorClient.SubscribeToChatNotificationsV1
type ImapConcentratorClientMockSubscribeToChatNotificationsV1Expectation struct {
	mock    *ImapConcentratorClientMock
	params  *ImapConcentratorClientMockSubscribeToChatNotificationsV1Params
	results *ImapConcentratorClientMockSubscribeToChatNotificationsV1Results
	Counter uint64
}

// ImapConcentratorClientMockSubscribeToChatNotificationsV1Params contains parameters of the ImapConcentratorClient.SubscribeToChatNotificationsV1
type ImapConcentratorClientMockSubscribeToChatNotificationsV1Params struct {
	ctx  context.Context
	in   *SubscribeToChatNotificationsV1Request
	opts []grpc.CallOption
}

// ImapConcentratorClientMockSubscribeToChatNotificationsV1Results contains results of the ImapConcentratorClient.SubscribeToChatNotificationsV1
type ImapConcentratorClientMockSubscribeToChatNotificationsV1Results struct {
	i1  ImapConcentrator_SubscribeToChatNotificationsV1Client
	err error
}

// Expect sets up expected params for ImapConcentratorClient.SubscribeToChatNotificationsV1
func (mmSubscribeToChatNotificationsV1 *mImapConcentratorClientMockSubscribeToChatNotificationsV1) Expect(ctx context.Context, in *SubscribeToChatNotificationsV1Request, opts ...grpc.CallOption) *mImapConcentratorClientMockSubscribeToChatNotificationsV1 {
	if mmSubscribeToChatNotificationsV1.mock.funcSubscribeToChatNotificationsV1 != nil {
		mmSubscribeToChatNotificationsV1.mock.t.Fatalf("ImapConcentratorClientMock.SubscribeToChatNotificationsV1 mock is already set by Set")
	}

	if mmSubscribeToChatNotificationsV1.defaultExpectation == nil {
		mmSubscribeToChatNotificationsV1.defaultExpectation = &ImapConcentratorClientMockSubscribeToChatNotificationsV1Expectation{}
	}

	mmSubscribeToChatNotificationsV1.defaultExpectation.params = &ImapConcentratorClientMockSubscribeToChatNotificationsV1Params{ctx, in, opts}
	for _, e := range mmSubscribeToChatNotificationsV1.expectations {
		if minimock.Equal(e.params, mmSubscribeToChatNotificationsV1.defaultExpectation.params) {
			mmSubscribeToChatNotificationsV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSubscribeToChatNotificationsV1.defaultExpectation.params)
		}
	}

	return mmSubscribeToChatNotificationsV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorClient.SubscribeToChatNotificationsV1
func (mmSubscribeToChatNotificationsV1 *mImapConcentratorClientMockSubscribeToChatNotificationsV1) Inspect(f func(ctx context.Context, in *SubscribeToChatNotificationsV1Request, opts ...grpc.CallOption)) *mImapConcentratorClientMockSubscribeToChatNotificationsV1 {
	if mmSubscribeToChatNotificationsV1.mock.inspectFuncSubscribeToChatNotificationsV1 != nil {
		mmSubscribeToChatNotificationsV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorClientMock.SubscribeToChatNotificationsV1")
	}

	mmSubscribeToChatNotificationsV1.mock.inspectFuncSubscribeToChatNotificationsV1 = f

	return mmSubscribeToChatNotificationsV1
}

// Return sets up results that will be returned by ImapConcentratorClient.SubscribeToChatNotificationsV1
func (mmSubscribeToChatNotificationsV1 *mImapConcentratorClientMockSubscribeToChatNotificationsV1) Return(i1 ImapConcentrator_SubscribeToChatNotificationsV1Client, err error) *ImapConcentratorClientMock {
	if mmSubscribeToChatNotificationsV1.mock.funcSubscribeToChatNotificationsV1 != nil {
		mmSubscribeToChatNotificationsV1.mock.t.Fatalf("ImapConcentratorClientMock.SubscribeToChatNotificationsV1 mock is already set by Set")
	}

	if mmSubscribeToChatNotificationsV1.defaultExpectation == nil {
		mmSubscribeToChatNotificationsV1.defaultExpectation = &ImapConcentratorClientMockSubscribeToChatNotificationsV1Expectation{mock: mmSubscribeToChatNotificationsV1.mock}
	}
	mmSubscribeToChatNotificationsV1.defaultExpectation.results = &ImapConcentratorClientMockSubscribeToChatNotificationsV1Results{i1, err}
	return mmSubscribeToChatNotificationsV1.mock
}

//Set uses given function f to mock the ImapConcentratorClient.SubscribeToChatNotificationsV1 method
func (mmSubscribeToChatNotificationsV1 *mImapConcentratorClientMockSubscribeToChatNotificationsV1) Set(f func(ctx context.Context, in *SubscribeToChatNotificationsV1Request, opts ...grpc.CallOption) (i1 ImapConcentrator_SubscribeToChatNotificationsV1Client, err error)) *ImapConcentratorClientMock {
	if mmSubscribeToChatNotificationsV1.defaultExpectation != nil {
		mmSubscribeToChatNotificationsV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorClient.SubscribeToChatNotificationsV1 method")
	}

	if len(mmSubscribeToChatNotificationsV1.expectations) > 0 {
		mmSubscribeToChatNotificationsV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorClient.SubscribeToChatNotificationsV1 method")
	}

	mmSubscribeToChatNotificationsV1.mock.funcSubscribeToChatNotificationsV1 = f
	return mmSubscribeToChatNotificationsV1.mock
}

// When sets expectation for the ImapConcentratorClient.SubscribeToChatNotificationsV1 which will trigger the result defined by the following
// Then helper
func (mmSubscribeToChatNotificationsV1 *mImapConcentratorClientMockSubscribeToChatNotificationsV1) When(ctx context.Context, in *SubscribeToChatNotificationsV1Request, opts ...grpc.CallOption) *ImapConcentratorClientMockSubscribeToChatNotificationsV1Expectation {
	if mmSubscribeToChatNotificationsV1.mock.funcSubscribeToChatNotificationsV1 != nil {
		mmSubscribeToChatNotificationsV1.mock.t.Fatalf("ImapConcentratorClientMock.SubscribeToChatNotificationsV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorClientMockSubscribeToChatNotificationsV1Expectation{
		mock:   mmSubscribeToChatNotificationsV1.mock,
		params: &ImapConcentratorClientMockSubscribeToChatNotificationsV1Params{ctx, in, opts},
	}
	mmSubscribeToChatNotificationsV1.expectations = append(mmSubscribeToChatNotificationsV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorClient.SubscribeToChatNotificationsV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorClientMockSubscribeToChatNotificationsV1Expectation) Then(i1 ImapConcentrator_SubscribeToChatNotificationsV1Client, err error) *ImapConcentratorClientMock {
	e.results = &ImapConcentratorClientMockSubscribeToChatNotificationsV1Results{i1, err}
	return e.mock
}

// SubscribeToChatNotificationsV1 implements ImapConcentratorClient
func (mmSubscribeToChatNotificationsV1 *ImapConcentratorClientMock) SubscribeToChatNotificationsV1(ctx context.Context, in *SubscribeToChatNotificationsV1Request, opts ...grpc.CallOption) (i1 ImapConcentrator_SubscribeToChatNotificationsV1Client, err error) {
	mm_atomic.AddUint64(&mmSubscribeToChatNotificationsV1.beforeSubscribeToChatNotificationsV1Counter, 1)
	defer mm_atomic.AddUint64(&mmSubscribeToChatNotificationsV1.afterSubscribeToChatNotificationsV1Counter, 1)

	if mmSubscribeToChatNotificationsV1.inspectFuncSubscribeToChatNotificationsV1 != nil {
		mmSubscribeToChatNotificationsV1.inspectFuncSubscribeToChatNotificationsV1(ctx, in, opts...)
	}

	mm_params := &ImapConcentratorClientMockSubscribeToChatNotificationsV1Params{ctx, in, opts}

	// Record call args
	mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.mutex.Lock()
	mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.callArgs = append(mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.callArgs, mm_params)
	mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.mutex.Unlock()

	for _, e := range mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorClientMockSubscribeToChatNotificationsV1Params{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSubscribeToChatNotificationsV1.t.Errorf("ImapConcentratorClientMock.SubscribeToChatNotificationsV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSubscribeToChatNotificationsV1.SubscribeToChatNotificationsV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmSubscribeToChatNotificationsV1.t.Fatal("No results are set for the ImapConcentratorClientMock.SubscribeToChatNotificationsV1")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmSubscribeToChatNotificationsV1.funcSubscribeToChatNotificationsV1 != nil {
		return mmSubscribeToChatNotificationsV1.funcSubscribeToChatNotificationsV1(ctx, in, opts...)
	}
	mmSubscribeToChatNotificationsV1.t.Fatalf("Unexpected call to ImapConcentratorClientMock.SubscribeToChatNotificationsV1. %v %v %v", ctx, in, opts)
	return
}

// SubscribeToChatNotificationsV1AfterCounter returns a count of finished ImapConcentratorClientMock.SubscribeToChatNotificationsV1 invocations
func (mmSubscribeToChatNotificationsV1 *ImapConcentratorClientMock) SubscribeToChatNotificationsV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribeToChatNotificationsV1.afterSubscribeToChatNotificationsV1Counter)
}

// SubscribeToChatNotificationsV1BeforeCounter returns a count of ImapConcentratorClientMock.SubscribeToChatNotificationsV1 invocations
func (mmSubscribeToChatNotificationsV1 *ImapConcentratorClientMock) SubscribeToChatNotificationsV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSubscribeToChatNotificationsV1.beforeSubscribeToChatNotificationsV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorClientMock.SubscribeToChatNotificationsV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSubscribeToChatNotificationsV1 *mImapConcentratorClientMockSubscribeToChatNotificationsV1) Calls() []*ImapConcentratorClientMockSubscribeToChatNotificationsV1Params {
	mmSubscribeToChatNotificationsV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorClientMockSubscribeToChatNotificationsV1Params, len(mmSubscribeToChatNotificationsV1.callArgs))
	copy(argCopy, mmSubscribeToChatNotificationsV1.callArgs)

	mmSubscribeToChatNotificationsV1.mutex.RUnlock()

	return argCopy
}

// MinimockSubscribeToChatNotificationsV1Done returns true if the count of the SubscribeToChatNotificationsV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorClientMock) MinimockSubscribeToChatNotificationsV1Done() bool {
	for _, e := range m.SubscribeToChatNotificationsV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeToChatNotificationsV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeToChatNotificationsV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribeToChatNotificationsV1 != nil && mm_atomic.LoadUint64(&m.afterSubscribeToChatNotificationsV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockSubscribeToChatNotificationsV1Inspect logs each unmet expectation
func (m *ImapConcentratorClientMock) MinimockSubscribeToChatNotificationsV1Inspect() {
	for _, e := range m.SubscribeToChatNotificationsV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.SubscribeToChatNotificationsV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SubscribeToChatNotificationsV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSubscribeToChatNotificationsV1Counter) < 1 {
		if m.SubscribeToChatNotificationsV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorClientMock.SubscribeToChatNotificationsV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.SubscribeToChatNotificationsV1 with params: %#v", *m.SubscribeToChatNotificationsV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSubscribeToChatNotificationsV1 != nil && mm_atomic.LoadUint64(&m.afterSubscribeToChatNotificationsV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorClientMock.SubscribeToChatNotificationsV1")
	}
}

type mImapConcentratorClientMockUnsubscribeFromNotificationsV1 struct {
	mock               *ImapConcentratorClientMock
	defaultExpectation *ImapConcentratorClientMockUnsubscribeFromNotificationsV1Expectation
	expectations       []*ImapConcentratorClientMockUnsubscribeFromNotificationsV1Expectation

	callArgs []*ImapConcentratorClientMockUnsubscribeFromNotificationsV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorClientMockUnsubscribeFromNotificationsV1Expectation specifies expectation struct of the ImapConcentratorClient.UnsubscribeFromNotificationsV1
type ImapConcentratorClientMockUnsubscribeFromNotificationsV1Expectation struct {
	mock    *ImapConcentratorClientMock
	params  *ImapConcentratorClientMockUnsubscribeFromNotificationsV1Params
	results *ImapConcentratorClientMockUnsubscribeFromNotificationsV1Results
	Counter uint64
}

// ImapConcentratorClientMockUnsubscribeFromNotificationsV1Params contains parameters of the ImapConcentratorClient.UnsubscribeFromNotificationsV1
type ImapConcentratorClientMockUnsubscribeFromNotificationsV1Params struct {
	ctx  context.Context
	in   *UnsubscribeFromNotificationsV1Request
	opts []grpc.CallOption
}

// ImapConcentratorClientMockUnsubscribeFromNotificationsV1Results contains results of the ImapConcentratorClient.UnsubscribeFromNotificationsV1
type ImapConcentratorClientMockUnsubscribeFromNotificationsV1Results struct {
	ap1 *Ack
	err error
}

// Expect sets up expected params for ImapConcentratorClient.UnsubscribeFromNotificationsV1
func (mmUnsubscribeFromNotificationsV1 *mImapConcentratorClientMockUnsubscribeFromNotificationsV1) Expect(ctx context.Context, in *UnsubscribeFromNotificationsV1Request, opts ...grpc.CallOption) *mImapConcentratorClientMockUnsubscribeFromNotificationsV1 {
	if mmUnsubscribeFromNotificationsV1.mock.funcUnsubscribeFromNotificationsV1 != nil {
		mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("ImapConcentratorClientMock.UnsubscribeFromNotificationsV1 mock is already set by Set")
	}

	if mmUnsubscribeFromNotificationsV1.defaultExpectation == nil {
		mmUnsubscribeFromNotificationsV1.defaultExpectation = &ImapConcentratorClientMockUnsubscribeFromNotificationsV1Expectation{}
	}

	mmUnsubscribeFromNotificationsV1.defaultExpectation.params = &ImapConcentratorClientMockUnsubscribeFromNotificationsV1Params{ctx, in, opts}
	for _, e := range mmUnsubscribeFromNotificationsV1.expectations {
		if minimock.Equal(e.params, mmUnsubscribeFromNotificationsV1.defaultExpectation.params) {
			mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUnsubscribeFromNotificationsV1.defaultExpectation.params)
		}
	}

	return mmUnsubscribeFromNotificationsV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorClient.UnsubscribeFromNotificationsV1
func (mmUnsubscribeFromNotificationsV1 *mImapConcentratorClientMockUnsubscribeFromNotificationsV1) Inspect(f func(ctx context.Context, in *UnsubscribeFromNotificationsV1Request, opts ...grpc.CallOption)) *mImapConcentratorClientMockUnsubscribeFromNotificationsV1 {
	if mmUnsubscribeFromNotificationsV1.mock.inspectFuncUnsubscribeFromNotificationsV1 != nil {
		mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorClientMock.UnsubscribeFromNotificationsV1")
	}

	mmUnsubscribeFromNotificationsV1.mock.inspectFuncUnsubscribeFromNotificationsV1 = f

	return mmUnsubscribeFromNotificationsV1
}

// Return sets up results that will be returned by ImapConcentratorClient.UnsubscribeFromNotificationsV1
func (mmUnsubscribeFromNotificationsV1 *mImapConcentratorClientMockUnsubscribeFromNotificationsV1) Return(ap1 *Ack, err error) *ImapConcentratorClientMock {
	if mmUnsubscribeFromNotificationsV1.mock.funcUnsubscribeFromNotificationsV1 != nil {
		mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("ImapConcentratorClientMock.UnsubscribeFromNotificationsV1 mock is already set by Set")
	}

	if mmUnsubscribeFromNotificationsV1.defaultExpectation == nil {
		mmUnsubscribeFromNotificationsV1.defaultExpectation = &ImapConcentratorClientMockUnsubscribeFromNotificationsV1Expectation{mock: mmUnsubscribeFromNotificationsV1.mock}
	}
	mmUnsubscribeFromNotificationsV1.defaultExpectation.results = &ImapConcentratorClientMockUnsubscribeFromNotificationsV1Results{ap1, err}
	return mmUnsubscribeFromNotificationsV1.mock
}

//Set uses given function f to mock the ImapConcentratorClient.UnsubscribeFromNotificationsV1 method
func (mmUnsubscribeFromNotificationsV1 *mImapConcentratorClientMockUnsubscribeFromNotificationsV1) Set(f func(ctx context.Context, in *UnsubscribeFromNotificationsV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error)) *ImapConcentratorClientMock {
	if mmUnsubscribeFromNotificationsV1.defaultExpectation != nil {
		mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorClient.UnsubscribeFromNotificationsV1 method")
	}

	if len(mmUnsubscribeFromNotificationsV1.expectations) > 0 {
		mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorClient.UnsubscribeFromNotificationsV1 method")
	}

	mmUnsubscribeFromNotificationsV1.mock.funcUnsubscribeFromNotificationsV1 = f
	return mmUnsubscribeFromNotificationsV1.mock
}

// When sets expectation for the ImapConcentratorClient.UnsubscribeFromNotificationsV1 which will trigger the result defined by the following
// Then helper
func (mmUnsubscribeFromNotificationsV1 *mImapConcentratorClientMockUnsubscribeFromNotificationsV1) When(ctx context.Context, in *UnsubscribeFromNotificationsV1Request, opts ...grpc.CallOption) *ImapConcentratorClientMockUnsubscribeFromNotificationsV1Expectation {
	if mmUnsubscribeFromNotificationsV1.mock.funcUnsubscribeFromNotificationsV1 != nil {
		mmUnsubscribeFromNotificationsV1.mock.t.Fatalf("ImapConcentratorClientMock.UnsubscribeFromNotificationsV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorClientMockUnsubscribeFromNotificationsV1Expectation{
		mock:   mmUnsubscribeFromNotificationsV1.mock,
		params: &ImapConcentratorClientMockUnsubscribeFromNotificationsV1Params{ctx, in, opts},
	}
	mmUnsubscribeFromNotificationsV1.expectations = append(mmUnsubscribeFromNotificationsV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorClient.UnsubscribeFromNotificationsV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorClientMockUnsubscribeFromNotificationsV1Expectation) Then(ap1 *Ack, err error) *ImapConcentratorClientMock {
	e.results = &ImapConcentratorClientMockUnsubscribeFromNotificationsV1Results{ap1, err}
	return e.mock
}

// UnsubscribeFromNotificationsV1 implements ImapConcentratorClient
func (mmUnsubscribeFromNotificationsV1 *ImapConcentratorClientMock) UnsubscribeFromNotificationsV1(ctx context.Context, in *UnsubscribeFromNotificationsV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error) {
	mm_atomic.AddUint64(&mmUnsubscribeFromNotificationsV1.beforeUnsubscribeFromNotificationsV1Counter, 1)
	defer mm_atomic.AddUint64(&mmUnsubscribeFromNotificationsV1.afterUnsubscribeFromNotificationsV1Counter, 1)

	if mmUnsubscribeFromNotificationsV1.inspectFuncUnsubscribeFromNotificationsV1 != nil {
		mmUnsubscribeFromNotificationsV1.inspectFuncUnsubscribeFromNotificationsV1(ctx, in, opts...)
	}

	mm_params := &ImapConcentratorClientMockUnsubscribeFromNotificationsV1Params{ctx, in, opts}

	// Record call args
	mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.mutex.Lock()
	mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.callArgs = append(mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.callArgs, mm_params)
	mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.mutex.Unlock()

	for _, e := range mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorClientMockUnsubscribeFromNotificationsV1Params{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUnsubscribeFromNotificationsV1.t.Errorf("ImapConcentratorClientMock.UnsubscribeFromNotificationsV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUnsubscribeFromNotificationsV1.UnsubscribeFromNotificationsV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmUnsubscribeFromNotificationsV1.t.Fatal("No results are set for the ImapConcentratorClientMock.UnsubscribeFromNotificationsV1")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmUnsubscribeFromNotificationsV1.funcUnsubscribeFromNotificationsV1 != nil {
		return mmUnsubscribeFromNotificationsV1.funcUnsubscribeFromNotificationsV1(ctx, in, opts...)
	}
	mmUnsubscribeFromNotificationsV1.t.Fatalf("Unexpected call to ImapConcentratorClientMock.UnsubscribeFromNotificationsV1. %v %v %v", ctx, in, opts)
	return
}

// UnsubscribeFromNotificationsV1AfterCounter returns a count of finished ImapConcentratorClientMock.UnsubscribeFromNotificationsV1 invocations
func (mmUnsubscribeFromNotificationsV1 *ImapConcentratorClientMock) UnsubscribeFromNotificationsV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnsubscribeFromNotificationsV1.afterUnsubscribeFromNotificationsV1Counter)
}

// UnsubscribeFromNotificationsV1BeforeCounter returns a count of ImapConcentratorClientMock.UnsubscribeFromNotificationsV1 invocations
func (mmUnsubscribeFromNotificationsV1 *ImapConcentratorClientMock) UnsubscribeFromNotificationsV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUnsubscribeFromNotificationsV1.beforeUnsubscribeFromNotificationsV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorClientMock.UnsubscribeFromNotificationsV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUnsubscribeFromNotificationsV1 *mImapConcentratorClientMockUnsubscribeFromNotificationsV1) Calls() []*ImapConcentratorClientMockUnsubscribeFromNotificationsV1Params {
	mmUnsubscribeFromNotificationsV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorClientMockUnsubscribeFromNotificationsV1Params, len(mmUnsubscribeFromNotificationsV1.callArgs))
	copy(argCopy, mmUnsubscribeFromNotificationsV1.callArgs)

	mmUnsubscribeFromNotificationsV1.mutex.RUnlock()

	return argCopy
}

// MinimockUnsubscribeFromNotificationsV1Done returns true if the count of the UnsubscribeFromNotificationsV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorClientMock) MinimockUnsubscribeFromNotificationsV1Done() bool {
	for _, e := range m.UnsubscribeFromNotificationsV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnsubscribeFromNotificationsV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeFromNotificationsV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnsubscribeFromNotificationsV1 != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeFromNotificationsV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockUnsubscribeFromNotificationsV1Inspect logs each unmet expectation
func (m *ImapConcentratorClientMock) MinimockUnsubscribeFromNotificationsV1Inspect() {
	for _, e := range m.UnsubscribeFromNotificationsV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.UnsubscribeFromNotificationsV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UnsubscribeFromNotificationsV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeFromNotificationsV1Counter) < 1 {
		if m.UnsubscribeFromNotificationsV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorClientMock.UnsubscribeFromNotificationsV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.UnsubscribeFromNotificationsV1 with params: %#v", *m.UnsubscribeFromNotificationsV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUnsubscribeFromNotificationsV1 != nil && mm_atomic.LoadUint64(&m.afterUnsubscribeFromNotificationsV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorClientMock.UnsubscribeFromNotificationsV1")
	}
}

type mImapConcentratorClientMockUpdateMailboxV1 struct {
	mock               *ImapConcentratorClientMock
	defaultExpectation *ImapConcentratorClientMockUpdateMailboxV1Expectation
	expectations       []*ImapConcentratorClientMockUpdateMailboxV1Expectation

	callArgs []*ImapConcentratorClientMockUpdateMailboxV1Params
	mutex    sync.RWMutex
}

// ImapConcentratorClientMockUpdateMailboxV1Expectation specifies expectation struct of the ImapConcentratorClient.UpdateMailboxV1
type ImapConcentratorClientMockUpdateMailboxV1Expectation struct {
	mock    *ImapConcentratorClientMock
	params  *ImapConcentratorClientMockUpdateMailboxV1Params
	results *ImapConcentratorClientMockUpdateMailboxV1Results
	Counter uint64
}

// ImapConcentratorClientMockUpdateMailboxV1Params contains parameters of the ImapConcentratorClient.UpdateMailboxV1
type ImapConcentratorClientMockUpdateMailboxV1Params struct {
	ctx  context.Context
	in   *UpdateMailboxV1Request
	opts []grpc.CallOption
}

// ImapConcentratorClientMockUpdateMailboxV1Results contains results of the ImapConcentratorClient.UpdateMailboxV1
type ImapConcentratorClientMockUpdateMailboxV1Results struct {
	ap1 *Ack
	err error
}

// Expect sets up expected params for ImapConcentratorClient.UpdateMailboxV1
func (mmUpdateMailboxV1 *mImapConcentratorClientMockUpdateMailboxV1) Expect(ctx context.Context, in *UpdateMailboxV1Request, opts ...grpc.CallOption) *mImapConcentratorClientMockUpdateMailboxV1 {
	if mmUpdateMailboxV1.mock.funcUpdateMailboxV1 != nil {
		mmUpdateMailboxV1.mock.t.Fatalf("ImapConcentratorClientMock.UpdateMailboxV1 mock is already set by Set")
	}

	if mmUpdateMailboxV1.defaultExpectation == nil {
		mmUpdateMailboxV1.defaultExpectation = &ImapConcentratorClientMockUpdateMailboxV1Expectation{}
	}

	mmUpdateMailboxV1.defaultExpectation.params = &ImapConcentratorClientMockUpdateMailboxV1Params{ctx, in, opts}
	for _, e := range mmUpdateMailboxV1.expectations {
		if minimock.Equal(e.params, mmUpdateMailboxV1.defaultExpectation.params) {
			mmUpdateMailboxV1.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateMailboxV1.defaultExpectation.params)
		}
	}

	return mmUpdateMailboxV1
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentratorClient.UpdateMailboxV1
func (mmUpdateMailboxV1 *mImapConcentratorClientMockUpdateMailboxV1) Inspect(f func(ctx context.Context, in *UpdateMailboxV1Request, opts ...grpc.CallOption)) *mImapConcentratorClientMockUpdateMailboxV1 {
	if mmUpdateMailboxV1.mock.inspectFuncUpdateMailboxV1 != nil {
		mmUpdateMailboxV1.mock.t.Fatalf("Inspect function is already set for ImapConcentratorClientMock.UpdateMailboxV1")
	}

	mmUpdateMailboxV1.mock.inspectFuncUpdateMailboxV1 = f

	return mmUpdateMailboxV1
}

// Return sets up results that will be returned by ImapConcentratorClient.UpdateMailboxV1
func (mmUpdateMailboxV1 *mImapConcentratorClientMockUpdateMailboxV1) Return(ap1 *Ack, err error) *ImapConcentratorClientMock {
	if mmUpdateMailboxV1.mock.funcUpdateMailboxV1 != nil {
		mmUpdateMailboxV1.mock.t.Fatalf("ImapConcentratorClientMock.UpdateMailboxV1 mock is already set by Set")
	}

	if mmUpdateMailboxV1.defaultExpectation == nil {
		mmUpdateMailboxV1.defaultExpectation = &ImapConcentratorClientMockUpdateMailboxV1Expectation{mock: mmUpdateMailboxV1.mock}
	}
	mmUpdateMailboxV1.defaultExpectation.results = &ImapConcentratorClientMockUpdateMailboxV1Results{ap1, err}
	return mmUpdateMailboxV1.mock
}

//Set uses given function f to mock the ImapConcentratorClient.UpdateMailboxV1 method
func (mmUpdateMailboxV1 *mImapConcentratorClientMockUpdateMailboxV1) Set(f func(ctx context.Context, in *UpdateMailboxV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error)) *ImapConcentratorClientMock {
	if mmUpdateMailboxV1.defaultExpectation != nil {
		mmUpdateMailboxV1.mock.t.Fatalf("Default expectation is already set for the ImapConcentratorClient.UpdateMailboxV1 method")
	}

	if len(mmUpdateMailboxV1.expectations) > 0 {
		mmUpdateMailboxV1.mock.t.Fatalf("Some expectations are already set for the ImapConcentratorClient.UpdateMailboxV1 method")
	}

	mmUpdateMailboxV1.mock.funcUpdateMailboxV1 = f
	return mmUpdateMailboxV1.mock
}

// When sets expectation for the ImapConcentratorClient.UpdateMailboxV1 which will trigger the result defined by the following
// Then helper
func (mmUpdateMailboxV1 *mImapConcentratorClientMockUpdateMailboxV1) When(ctx context.Context, in *UpdateMailboxV1Request, opts ...grpc.CallOption) *ImapConcentratorClientMockUpdateMailboxV1Expectation {
	if mmUpdateMailboxV1.mock.funcUpdateMailboxV1 != nil {
		mmUpdateMailboxV1.mock.t.Fatalf("ImapConcentratorClientMock.UpdateMailboxV1 mock is already set by Set")
	}

	expectation := &ImapConcentratorClientMockUpdateMailboxV1Expectation{
		mock:   mmUpdateMailboxV1.mock,
		params: &ImapConcentratorClientMockUpdateMailboxV1Params{ctx, in, opts},
	}
	mmUpdateMailboxV1.expectations = append(mmUpdateMailboxV1.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentratorClient.UpdateMailboxV1 return parameters for the expectation previously defined by the When method
func (e *ImapConcentratorClientMockUpdateMailboxV1Expectation) Then(ap1 *Ack, err error) *ImapConcentratorClientMock {
	e.results = &ImapConcentratorClientMockUpdateMailboxV1Results{ap1, err}
	return e.mock
}

// UpdateMailboxV1 implements ImapConcentratorClient
func (mmUpdateMailboxV1 *ImapConcentratorClientMock) UpdateMailboxV1(ctx context.Context, in *UpdateMailboxV1Request, opts ...grpc.CallOption) (ap1 *Ack, err error) {
	mm_atomic.AddUint64(&mmUpdateMailboxV1.beforeUpdateMailboxV1Counter, 1)
	defer mm_atomic.AddUint64(&mmUpdateMailboxV1.afterUpdateMailboxV1Counter, 1)

	if mmUpdateMailboxV1.inspectFuncUpdateMailboxV1 != nil {
		mmUpdateMailboxV1.inspectFuncUpdateMailboxV1(ctx, in, opts...)
	}

	mm_params := &ImapConcentratorClientMockUpdateMailboxV1Params{ctx, in, opts}

	// Record call args
	mmUpdateMailboxV1.UpdateMailboxV1Mock.mutex.Lock()
	mmUpdateMailboxV1.UpdateMailboxV1Mock.callArgs = append(mmUpdateMailboxV1.UpdateMailboxV1Mock.callArgs, mm_params)
	mmUpdateMailboxV1.UpdateMailboxV1Mock.mutex.Unlock()

	for _, e := range mmUpdateMailboxV1.UpdateMailboxV1Mock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmUpdateMailboxV1.UpdateMailboxV1Mock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateMailboxV1.UpdateMailboxV1Mock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateMailboxV1.UpdateMailboxV1Mock.defaultExpectation.params
		mm_got := ImapConcentratorClientMockUpdateMailboxV1Params{ctx, in, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateMailboxV1.t.Errorf("ImapConcentratorClientMock.UpdateMailboxV1 got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateMailboxV1.UpdateMailboxV1Mock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateMailboxV1.t.Fatal("No results are set for the ImapConcentratorClientMock.UpdateMailboxV1")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmUpdateMailboxV1.funcUpdateMailboxV1 != nil {
		return mmUpdateMailboxV1.funcUpdateMailboxV1(ctx, in, opts...)
	}
	mmUpdateMailboxV1.t.Fatalf("Unexpected call to ImapConcentratorClientMock.UpdateMailboxV1. %v %v %v", ctx, in, opts)
	return
}

// UpdateMailboxV1AfterCounter returns a count of finished ImapConcentratorClientMock.UpdateMailboxV1 invocations
func (mmUpdateMailboxV1 *ImapConcentratorClientMock) UpdateMailboxV1AfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMailboxV1.afterUpdateMailboxV1Counter)
}

// UpdateMailboxV1BeforeCounter returns a count of ImapConcentratorClientMock.UpdateMailboxV1 invocations
func (mmUpdateMailboxV1 *ImapConcentratorClientMock) UpdateMailboxV1BeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateMailboxV1.beforeUpdateMailboxV1Counter)
}

// Calls returns a list of arguments used in each call to ImapConcentratorClientMock.UpdateMailboxV1.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateMailboxV1 *mImapConcentratorClientMockUpdateMailboxV1) Calls() []*ImapConcentratorClientMockUpdateMailboxV1Params {
	mmUpdateMailboxV1.mutex.RLock()

	argCopy := make([]*ImapConcentratorClientMockUpdateMailboxV1Params, len(mmUpdateMailboxV1.callArgs))
	copy(argCopy, mmUpdateMailboxV1.callArgs)

	mmUpdateMailboxV1.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateMailboxV1Done returns true if the count of the UpdateMailboxV1 invocations corresponds
// the number of defined expectations
func (m *ImapConcentratorClientMock) MinimockUpdateMailboxV1Done() bool {
	for _, e := range m.UpdateMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateMailboxV1Counter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterUpdateMailboxV1Counter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateMailboxV1Inspect logs each unmet expectation
func (m *ImapConcentratorClientMock) MinimockUpdateMailboxV1Inspect() {
	for _, e := range m.UpdateMailboxV1Mock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.UpdateMailboxV1 with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMailboxV1Mock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateMailboxV1Counter) < 1 {
		if m.UpdateMailboxV1Mock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentratorClientMock.UpdateMailboxV1")
		} else {
			m.t.Errorf("Expected call to ImapConcentratorClientMock.UpdateMailboxV1 with params: %#v", *m.UpdateMailboxV1Mock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateMailboxV1 != nil && mm_atomic.LoadUint64(&m.afterUpdateMailboxV1Counter) < 1 {
		m.t.Error("Expected call to ImapConcentratorClientMock.UpdateMailboxV1")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ImapConcentratorClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAssignUniqueClientIDInspect()

		m.MinimockDeleteMailboxV1Inspect()

		m.MinimockGetMailboxV1Inspect()

		m.MinimockInsertChatV1Inspect()

		m.MinimockInsertMailboxV1Inspect()

		m.MinimockListMailboxesV1Inspect()

		m.MinimockPollV1Inspect()

		m.MinimockSubscribeToAllNotificationsV1Inspect()

		m.MinimockSubscribeToChatNotificationsV1Inspect()

		m.MinimockUnsubscribeFromNotificationsV1Inspect()

		m.MinimockUpdateMailboxV1Inspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ImapConcentratorClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ImapConcentratorClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAssignUniqueClientIDDone() &&
		m.MinimockDeleteMailboxV1Done() &&
		m.MinimockGetMailboxV1Done() &&
		m.MinimockInsertChatV1Done() &&
		m.MinimockInsertMailboxV1Done() &&
		m.MinimockListMailboxesV1Done() &&
		m.MinimockPollV1Done() &&
		m.MinimockSubscribeToAllNotificationsV1Done() &&
		m.MinimockSubscribeToChatNotificationsV1Done() &&
		m.MinimockUnsubscribeFromNotificationsV1Done() &&
		m.MinimockUpdateMailboxV1Done()
}
