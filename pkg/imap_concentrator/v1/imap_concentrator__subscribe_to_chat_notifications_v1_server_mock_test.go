package imap_concentrator

// Code generated by http://github.com/gojuno/minimock (3.0.10). DO NOT EDIT.

//go:generate minimock -i github.com/aveplen/silicon-funnel/pkg/imap_concentrator/v1.ImapConcentrator_SubscribeToChatNotificationsV1Server -o ./imap_concentrator__subscribe_to_chat_notifications_v1_server_mock_test.go -n ImapConcentrator_SubscribeToChatNotificationsV1ServerMock

import (
	context "context"
	sync "sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"google.golang.org/grpc/metadata"
)

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMock implements ImapConcentrator_SubscribeToChatNotificationsV1Server
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMock struct {
	t minimock.Tester

	funcContext          func() (c1 context.Context)
	inspectFuncContext   func()
	afterContextCounter  uint64
	beforeContextCounter uint64
	ContextMock          mImapConcentrator_SubscribeToChatNotificationsV1ServerMockContext

	funcRecvMsg          func(m interface{}) (err error)
	inspectFuncRecvMsg   func(m interface{})
	afterRecvMsgCounter  uint64
	beforeRecvMsgCounter uint64
	RecvMsgMock          mImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsg

	funcSend          func(np1 *NotificationV1) (err error)
	inspectFuncSend   func(np1 *NotificationV1)
	afterSendCounter  uint64
	beforeSendCounter uint64
	SendMock          mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSend

	funcSendHeader          func(m1 metadata.MD) (err error)
	inspectFuncSendHeader   func(m1 metadata.MD)
	afterSendHeaderCounter  uint64
	beforeSendHeaderCounter uint64
	SendHeaderMock          mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeader

	funcSendMsg          func(m interface{}) (err error)
	inspectFuncSendMsg   func(m interface{})
	afterSendMsgCounter  uint64
	beforeSendMsgCounter uint64
	SendMsgMock          mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsg

	funcSetHeader          func(m1 metadata.MD) (err error)
	inspectFuncSetHeader   func(m1 metadata.MD)
	afterSetHeaderCounter  uint64
	beforeSetHeaderCounter uint64
	SetHeaderMock          mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeader

	funcSetTrailer          func(m1 metadata.MD)
	inspectFuncSetTrailer   func(m1 metadata.MD)
	afterSetTrailerCounter  uint64
	beforeSetTrailerCounter uint64
	SetTrailerMock          mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailer
}

// NewImapConcentrator_SubscribeToChatNotificationsV1ServerMock returns a mock for ImapConcentrator_SubscribeToChatNotificationsV1Server
func NewImapConcentrator_SubscribeToChatNotificationsV1ServerMock(t minimock.Tester) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	m := &ImapConcentrator_SubscribeToChatNotificationsV1ServerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ContextMock = mImapConcentrator_SubscribeToChatNotificationsV1ServerMockContext{mock: m}

	m.RecvMsgMock = mImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsg{mock: m}
	m.RecvMsgMock.callArgs = []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgParams{}

	m.SendMock = mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSend{mock: m}
	m.SendMock.callArgs = []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendParams{}

	m.SendHeaderMock = mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeader{mock: m}
	m.SendHeaderMock.callArgs = []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderParams{}

	m.SendMsgMock = mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsg{mock: m}
	m.SendMsgMock.callArgs = []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgParams{}

	m.SetHeaderMock = mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeader{mock: m}
	m.SetHeaderMock.callArgs = []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderParams{}

	m.SetTrailerMock = mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailer{mock: m}
	m.SetTrailerMock.callArgs = []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerParams{}

	return m
}

type mImapConcentrator_SubscribeToChatNotificationsV1ServerMockContext struct {
	mock               *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	defaultExpectation *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockContextExpectation
	expectations       []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockContextExpectation
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockContextExpectation specifies expectation struct of the ImapConcentrator_SubscribeToChatNotificationsV1Server.Context
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockContextExpectation struct {
	mock *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock

	results *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockContextResults
	Counter uint64
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockContextResults contains results of the ImapConcentrator_SubscribeToChatNotificationsV1Server.Context
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockContextResults struct {
	c1 context.Context
}

// Expect sets up expected params for ImapConcentrator_SubscribeToChatNotificationsV1Server.Context
func (mmContext *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockContext) Expect() *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockContext {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Context mock is already set by Set")
	}

	if mmContext.defaultExpectation == nil {
		mmContext.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockContextExpectation{}
	}

	return mmContext
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToChatNotificationsV1Server.Context
func (mmContext *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockContext) Inspect(f func()) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockContext {
	if mmContext.mock.inspectFuncContext != nil {
		mmContext.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Context")
	}

	mmContext.mock.inspectFuncContext = f

	return mmContext
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToChatNotificationsV1Server.Context
func (mmContext *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockContext) Return(c1 context.Context) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmContext.mock.funcContext != nil {
		mmContext.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Context mock is already set by Set")
	}

	if mmContext.defaultExpectation == nil {
		mmContext.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockContextExpectation{mock: mmContext.mock}
	}
	mmContext.defaultExpectation.results = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockContextResults{c1}
	return mmContext.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToChatNotificationsV1Server.Context method
func (mmContext *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockContext) Set(f func() (c1 context.Context)) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmContext.defaultExpectation != nil {
		mmContext.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.Context method")
	}

	if len(mmContext.expectations) > 0 {
		mmContext.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.Context method")
	}

	mmContext.mock.funcContext = f
	return mmContext.mock
}

// Context implements ImapConcentrator_SubscribeToChatNotificationsV1Server
func (mmContext *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) Context() (c1 context.Context) {
	mm_atomic.AddUint64(&mmContext.beforeContextCounter, 1)
	defer mm_atomic.AddUint64(&mmContext.afterContextCounter, 1)

	if mmContext.inspectFuncContext != nil {
		mmContext.inspectFuncContext()
	}

	if mmContext.ContextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmContext.ContextMock.defaultExpectation.Counter, 1)

		mm_results := mmContext.ContextMock.defaultExpectation.results
		if mm_results == nil {
			mmContext.t.Fatal("No results are set for the ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Context")
		}
		return (*mm_results).c1
	}
	if mmContext.funcContext != nil {
		return mmContext.funcContext()
	}
	mmContext.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Context.")
	return
}

// ContextAfterCounter returns a count of finished ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Context invocations
func (mmContext *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) ContextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContext.afterContextCounter)
}

// ContextBeforeCounter returns a count of ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Context invocations
func (mmContext *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) ContextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmContext.beforeContextCounter)
}

// MinimockContextDone returns true if the count of the Context invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockContextDone() bool {
	for _, e := range m.ContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContext != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		return false
	}
	return true
}

// MinimockContextInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockContextInspect() {
	for _, e := range m.ContextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Context")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ContextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Context")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcContext != nil && mm_atomic.LoadUint64(&m.afterContextCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Context")
	}
}

type mImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsg struct {
	mock               *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	defaultExpectation *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgExpectation
	expectations       []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgExpectation

	callArgs []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgParams
	mutex    sync.RWMutex
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgExpectation specifies expectation struct of the ImapConcentrator_SubscribeToChatNotificationsV1Server.RecvMsg
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgExpectation struct {
	mock    *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	params  *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgParams
	results *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgResults
	Counter uint64
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgParams contains parameters of the ImapConcentrator_SubscribeToChatNotificationsV1Server.RecvMsg
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgParams struct {
	m interface{}
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgResults contains results of the ImapConcentrator_SubscribeToChatNotificationsV1Server.RecvMsg
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgResults struct {
	err error
}

// Expect sets up expected params for ImapConcentrator_SubscribeToChatNotificationsV1Server.RecvMsg
func (mmRecvMsg *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsg) Expect(m interface{}) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsg {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg mock is already set by Set")
	}

	if mmRecvMsg.defaultExpectation == nil {
		mmRecvMsg.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgExpectation{}
	}

	mmRecvMsg.defaultExpectation.params = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgParams{m}
	for _, e := range mmRecvMsg.expectations {
		if minimock.Equal(e.params, mmRecvMsg.defaultExpectation.params) {
			mmRecvMsg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRecvMsg.defaultExpectation.params)
		}
	}

	return mmRecvMsg
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToChatNotificationsV1Server.RecvMsg
func (mmRecvMsg *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsg) Inspect(f func(m interface{})) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsg {
	if mmRecvMsg.mock.inspectFuncRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg")
	}

	mmRecvMsg.mock.inspectFuncRecvMsg = f

	return mmRecvMsg
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToChatNotificationsV1Server.RecvMsg
func (mmRecvMsg *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsg) Return(err error) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg mock is already set by Set")
	}

	if mmRecvMsg.defaultExpectation == nil {
		mmRecvMsg.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgExpectation{mock: mmRecvMsg.mock}
	}
	mmRecvMsg.defaultExpectation.results = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgResults{err}
	return mmRecvMsg.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToChatNotificationsV1Server.RecvMsg method
func (mmRecvMsg *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsg) Set(f func(m interface{}) (err error)) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmRecvMsg.defaultExpectation != nil {
		mmRecvMsg.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.RecvMsg method")
	}

	if len(mmRecvMsg.expectations) > 0 {
		mmRecvMsg.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.RecvMsg method")
	}

	mmRecvMsg.mock.funcRecvMsg = f
	return mmRecvMsg.mock
}

// When sets expectation for the ImapConcentrator_SubscribeToChatNotificationsV1Server.RecvMsg which will trigger the result defined by the following
// Then helper
func (mmRecvMsg *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsg) When(m interface{}) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgExpectation {
	if mmRecvMsg.mock.funcRecvMsg != nil {
		mmRecvMsg.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg mock is already set by Set")
	}

	expectation := &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgExpectation{
		mock:   mmRecvMsg.mock,
		params: &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgParams{m},
	}
	mmRecvMsg.expectations = append(mmRecvMsg.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentrator_SubscribeToChatNotificationsV1Server.RecvMsg return parameters for the expectation previously defined by the When method
func (e *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgExpectation) Then(err error) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	e.results = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgResults{err}
	return e.mock
}

// RecvMsg implements ImapConcentrator_SubscribeToChatNotificationsV1Server
func (mmRecvMsg *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) RecvMsg(m interface{}) (err error) {
	mm_atomic.AddUint64(&mmRecvMsg.beforeRecvMsgCounter, 1)
	defer mm_atomic.AddUint64(&mmRecvMsg.afterRecvMsgCounter, 1)

	if mmRecvMsg.inspectFuncRecvMsg != nil {
		mmRecvMsg.inspectFuncRecvMsg(m)
	}

	mm_params := &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgParams{m}

	// Record call args
	mmRecvMsg.RecvMsgMock.mutex.Lock()
	mmRecvMsg.RecvMsgMock.callArgs = append(mmRecvMsg.RecvMsgMock.callArgs, mm_params)
	mmRecvMsg.RecvMsgMock.mutex.Unlock()

	for _, e := range mmRecvMsg.RecvMsgMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRecvMsg.RecvMsgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRecvMsg.RecvMsgMock.defaultExpectation.Counter, 1)
		mm_want := mmRecvMsg.RecvMsgMock.defaultExpectation.params
		mm_got := ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgParams{m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRecvMsg.t.Errorf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRecvMsg.RecvMsgMock.defaultExpectation.results
		if mm_results == nil {
			mmRecvMsg.t.Fatal("No results are set for the ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg")
		}
		return (*mm_results).err
	}
	if mmRecvMsg.funcRecvMsg != nil {
		return mmRecvMsg.funcRecvMsg(m)
	}
	mmRecvMsg.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg. %v", m)
	return
}

// RecvMsgAfterCounter returns a count of finished ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg invocations
func (mmRecvMsg *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) RecvMsgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecvMsg.afterRecvMsgCounter)
}

// RecvMsgBeforeCounter returns a count of ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg invocations
func (mmRecvMsg *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) RecvMsgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRecvMsg.beforeRecvMsgCounter)
}

// Calls returns a list of arguments used in each call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRecvMsg *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsg) Calls() []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgParams {
	mmRecvMsg.mutex.RLock()

	argCopy := make([]*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockRecvMsgParams, len(mmRecvMsg.callArgs))
	copy(argCopy, mmRecvMsg.callArgs)

	mmRecvMsg.mutex.RUnlock()

	return argCopy
}

// MinimockRecvMsgDone returns true if the count of the RecvMsg invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockRecvMsgDone() bool {
	for _, e := range m.RecvMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecvMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecvMsg != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		return false
	}
	return true
}

// MinimockRecvMsgInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockRecvMsgInspect() {
	for _, e := range m.RecvMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RecvMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		if m.RecvMsgMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg")
		} else {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg with params: %#v", *m.RecvMsgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRecvMsg != nil && mm_atomic.LoadUint64(&m.afterRecvMsgCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.RecvMsg")
	}
}

type mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSend struct {
	mock               *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	defaultExpectation *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendExpectation
	expectations       []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendExpectation

	callArgs []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendParams
	mutex    sync.RWMutex
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendExpectation specifies expectation struct of the ImapConcentrator_SubscribeToChatNotificationsV1Server.Send
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendExpectation struct {
	mock    *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	params  *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendParams
	results *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendResults
	Counter uint64
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendParams contains parameters of the ImapConcentrator_SubscribeToChatNotificationsV1Server.Send
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendParams struct {
	np1 *NotificationV1
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendResults contains results of the ImapConcentrator_SubscribeToChatNotificationsV1Server.Send
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendResults struct {
	err error
}

// Expect sets up expected params for ImapConcentrator_SubscribeToChatNotificationsV1Server.Send
func (mmSend *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSend) Expect(np1 *NotificationV1) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSend {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendExpectation{}
	}

	mmSend.defaultExpectation.params = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendParams{np1}
	for _, e := range mmSend.expectations {
		if minimock.Equal(e.params, mmSend.defaultExpectation.params) {
			mmSend.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSend.defaultExpectation.params)
		}
	}

	return mmSend
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToChatNotificationsV1Server.Send
func (mmSend *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSend) Inspect(f func(np1 *NotificationV1)) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSend {
	if mmSend.mock.inspectFuncSend != nil {
		mmSend.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send")
	}

	mmSend.mock.inspectFuncSend = f

	return mmSend
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToChatNotificationsV1Server.Send
func (mmSend *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSend) Return(err error) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send mock is already set by Set")
	}

	if mmSend.defaultExpectation == nil {
		mmSend.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendExpectation{mock: mmSend.mock}
	}
	mmSend.defaultExpectation.results = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendResults{err}
	return mmSend.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToChatNotificationsV1Server.Send method
func (mmSend *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSend) Set(f func(np1 *NotificationV1) (err error)) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmSend.defaultExpectation != nil {
		mmSend.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.Send method")
	}

	if len(mmSend.expectations) > 0 {
		mmSend.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.Send method")
	}

	mmSend.mock.funcSend = f
	return mmSend.mock
}

// When sets expectation for the ImapConcentrator_SubscribeToChatNotificationsV1Server.Send which will trigger the result defined by the following
// Then helper
func (mmSend *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSend) When(np1 *NotificationV1) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendExpectation {
	if mmSend.mock.funcSend != nil {
		mmSend.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send mock is already set by Set")
	}

	expectation := &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendExpectation{
		mock:   mmSend.mock,
		params: &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendParams{np1},
	}
	mmSend.expectations = append(mmSend.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentrator_SubscribeToChatNotificationsV1Server.Send return parameters for the expectation previously defined by the When method
func (e *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendExpectation) Then(err error) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	e.results = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendResults{err}
	return e.mock
}

// Send implements ImapConcentrator_SubscribeToChatNotificationsV1Server
func (mmSend *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) Send(np1 *NotificationV1) (err error) {
	mm_atomic.AddUint64(&mmSend.beforeSendCounter, 1)
	defer mm_atomic.AddUint64(&mmSend.afterSendCounter, 1)

	if mmSend.inspectFuncSend != nil {
		mmSend.inspectFuncSend(np1)
	}

	mm_params := &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendParams{np1}

	// Record call args
	mmSend.SendMock.mutex.Lock()
	mmSend.SendMock.callArgs = append(mmSend.SendMock.callArgs, mm_params)
	mmSend.SendMock.mutex.Unlock()

	for _, e := range mmSend.SendMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSend.SendMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSend.SendMock.defaultExpectation.Counter, 1)
		mm_want := mmSend.SendMock.defaultExpectation.params
		mm_got := ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendParams{np1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSend.t.Errorf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSend.SendMock.defaultExpectation.results
		if mm_results == nil {
			mmSend.t.Fatal("No results are set for the ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send")
		}
		return (*mm_results).err
	}
	if mmSend.funcSend != nil {
		return mmSend.funcSend(np1)
	}
	mmSend.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send. %v", np1)
	return
}

// SendAfterCounter returns a count of finished ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send invocations
func (mmSend *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SendAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.afterSendCounter)
}

// SendBeforeCounter returns a count of ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send invocations
func (mmSend *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SendBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSend.beforeSendCounter)
}

// Calls returns a list of arguments used in each call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSend *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSend) Calls() []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendParams {
	mmSend.mutex.RLock()

	argCopy := make([]*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendParams, len(mmSend.callArgs))
	copy(argCopy, mmSend.callArgs)

	mmSend.mutex.RUnlock()

	return argCopy
}

// MinimockSendDone returns true if the count of the Send invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockSendDone() bool {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockSendInspect() {
	for _, e := range m.SendMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		if m.SendMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send")
		} else {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send with params: %#v", *m.SendMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSend != nil && mm_atomic.LoadUint64(&m.afterSendCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.Send")
	}
}

type mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeader struct {
	mock               *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	defaultExpectation *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderExpectation
	expectations       []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderExpectation

	callArgs []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderParams
	mutex    sync.RWMutex
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderExpectation specifies expectation struct of the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendHeader
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderExpectation struct {
	mock    *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	params  *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderParams
	results *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderResults
	Counter uint64
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderParams contains parameters of the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendHeader
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderParams struct {
	m1 metadata.MD
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderResults contains results of the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendHeader
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderResults struct {
	err error
}

// Expect sets up expected params for ImapConcentrator_SubscribeToChatNotificationsV1Server.SendHeader
func (mmSendHeader *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeader) Expect(m1 metadata.MD) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeader {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader mock is already set by Set")
	}

	if mmSendHeader.defaultExpectation == nil {
		mmSendHeader.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderExpectation{}
	}

	mmSendHeader.defaultExpectation.params = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderParams{m1}
	for _, e := range mmSendHeader.expectations {
		if minimock.Equal(e.params, mmSendHeader.defaultExpectation.params) {
			mmSendHeader.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendHeader.defaultExpectation.params)
		}
	}

	return mmSendHeader
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendHeader
func (mmSendHeader *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeader) Inspect(f func(m1 metadata.MD)) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeader {
	if mmSendHeader.mock.inspectFuncSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader")
	}

	mmSendHeader.mock.inspectFuncSendHeader = f

	return mmSendHeader
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToChatNotificationsV1Server.SendHeader
func (mmSendHeader *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeader) Return(err error) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader mock is already set by Set")
	}

	if mmSendHeader.defaultExpectation == nil {
		mmSendHeader.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderExpectation{mock: mmSendHeader.mock}
	}
	mmSendHeader.defaultExpectation.results = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderResults{err}
	return mmSendHeader.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendHeader method
func (mmSendHeader *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeader) Set(f func(m1 metadata.MD) (err error)) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmSendHeader.defaultExpectation != nil {
		mmSendHeader.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendHeader method")
	}

	if len(mmSendHeader.expectations) > 0 {
		mmSendHeader.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendHeader method")
	}

	mmSendHeader.mock.funcSendHeader = f
	return mmSendHeader.mock
}

// When sets expectation for the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendHeader which will trigger the result defined by the following
// Then helper
func (mmSendHeader *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeader) When(m1 metadata.MD) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderExpectation {
	if mmSendHeader.mock.funcSendHeader != nil {
		mmSendHeader.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader mock is already set by Set")
	}

	expectation := &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderExpectation{
		mock:   mmSendHeader.mock,
		params: &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderParams{m1},
	}
	mmSendHeader.expectations = append(mmSendHeader.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentrator_SubscribeToChatNotificationsV1Server.SendHeader return parameters for the expectation previously defined by the When method
func (e *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderExpectation) Then(err error) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	e.results = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderResults{err}
	return e.mock
}

// SendHeader implements ImapConcentrator_SubscribeToChatNotificationsV1Server
func (mmSendHeader *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SendHeader(m1 metadata.MD) (err error) {
	mm_atomic.AddUint64(&mmSendHeader.beforeSendHeaderCounter, 1)
	defer mm_atomic.AddUint64(&mmSendHeader.afterSendHeaderCounter, 1)

	if mmSendHeader.inspectFuncSendHeader != nil {
		mmSendHeader.inspectFuncSendHeader(m1)
	}

	mm_params := &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderParams{m1}

	// Record call args
	mmSendHeader.SendHeaderMock.mutex.Lock()
	mmSendHeader.SendHeaderMock.callArgs = append(mmSendHeader.SendHeaderMock.callArgs, mm_params)
	mmSendHeader.SendHeaderMock.mutex.Unlock()

	for _, e := range mmSendHeader.SendHeaderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendHeader.SendHeaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendHeader.SendHeaderMock.defaultExpectation.Counter, 1)
		mm_want := mmSendHeader.SendHeaderMock.defaultExpectation.params
		mm_got := ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendHeader.t.Errorf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendHeader.SendHeaderMock.defaultExpectation.results
		if mm_results == nil {
			mmSendHeader.t.Fatal("No results are set for the ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader")
		}
		return (*mm_results).err
	}
	if mmSendHeader.funcSendHeader != nil {
		return mmSendHeader.funcSendHeader(m1)
	}
	mmSendHeader.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader. %v", m1)
	return
}

// SendHeaderAfterCounter returns a count of finished ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader invocations
func (mmSendHeader *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SendHeaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendHeader.afterSendHeaderCounter)
}

// SendHeaderBeforeCounter returns a count of ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader invocations
func (mmSendHeader *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SendHeaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendHeader.beforeSendHeaderCounter)
}

// Calls returns a list of arguments used in each call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendHeader *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeader) Calls() []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderParams {
	mmSendHeader.mutex.RLock()

	argCopy := make([]*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendHeaderParams, len(mmSendHeader.callArgs))
	copy(argCopy, mmSendHeader.callArgs)

	mmSendHeader.mutex.RUnlock()

	return argCopy
}

// MinimockSendHeaderDone returns true if the count of the SendHeader invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockSendHeaderDone() bool {
	for _, e := range m.SendHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendHeaderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendHeader != nil && mm_atomic.LoadUint64(&m.afterSendHeaderCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendHeaderInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockSendHeaderInspect() {
	for _, e := range m.SendHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendHeaderCounter) < 1 {
		if m.SendHeaderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader")
		} else {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader with params: %#v", *m.SendHeaderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendHeader != nil && mm_atomic.LoadUint64(&m.afterSendHeaderCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendHeader")
	}
}

type mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsg struct {
	mock               *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	defaultExpectation *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgExpectation
	expectations       []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgExpectation

	callArgs []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgParams
	mutex    sync.RWMutex
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgExpectation specifies expectation struct of the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendMsg
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgExpectation struct {
	mock    *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	params  *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgParams
	results *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgResults
	Counter uint64
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgParams contains parameters of the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendMsg
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgParams struct {
	m interface{}
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgResults contains results of the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendMsg
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgResults struct {
	err error
}

// Expect sets up expected params for ImapConcentrator_SubscribeToChatNotificationsV1Server.SendMsg
func (mmSendMsg *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsg) Expect(m interface{}) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsg {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgExpectation{}
	}

	mmSendMsg.defaultExpectation.params = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgParams{m}
	for _, e := range mmSendMsg.expectations {
		if minimock.Equal(e.params, mmSendMsg.defaultExpectation.params) {
			mmSendMsg.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMsg.defaultExpectation.params)
		}
	}

	return mmSendMsg
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendMsg
func (mmSendMsg *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsg) Inspect(f func(m interface{})) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsg {
	if mmSendMsg.mock.inspectFuncSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg")
	}

	mmSendMsg.mock.inspectFuncSendMsg = f

	return mmSendMsg
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToChatNotificationsV1Server.SendMsg
func (mmSendMsg *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsg) Return(err error) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg mock is already set by Set")
	}

	if mmSendMsg.defaultExpectation == nil {
		mmSendMsg.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgExpectation{mock: mmSendMsg.mock}
	}
	mmSendMsg.defaultExpectation.results = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgResults{err}
	return mmSendMsg.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendMsg method
func (mmSendMsg *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsg) Set(f func(m interface{}) (err error)) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmSendMsg.defaultExpectation != nil {
		mmSendMsg.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendMsg method")
	}

	if len(mmSendMsg.expectations) > 0 {
		mmSendMsg.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendMsg method")
	}

	mmSendMsg.mock.funcSendMsg = f
	return mmSendMsg.mock
}

// When sets expectation for the ImapConcentrator_SubscribeToChatNotificationsV1Server.SendMsg which will trigger the result defined by the following
// Then helper
func (mmSendMsg *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsg) When(m interface{}) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgExpectation {
	if mmSendMsg.mock.funcSendMsg != nil {
		mmSendMsg.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg mock is already set by Set")
	}

	expectation := &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgExpectation{
		mock:   mmSendMsg.mock,
		params: &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgParams{m},
	}
	mmSendMsg.expectations = append(mmSendMsg.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentrator_SubscribeToChatNotificationsV1Server.SendMsg return parameters for the expectation previously defined by the When method
func (e *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgExpectation) Then(err error) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	e.results = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgResults{err}
	return e.mock
}

// SendMsg implements ImapConcentrator_SubscribeToChatNotificationsV1Server
func (mmSendMsg *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SendMsg(m interface{}) (err error) {
	mm_atomic.AddUint64(&mmSendMsg.beforeSendMsgCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMsg.afterSendMsgCounter, 1)

	if mmSendMsg.inspectFuncSendMsg != nil {
		mmSendMsg.inspectFuncSendMsg(m)
	}

	mm_params := &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgParams{m}

	// Record call args
	mmSendMsg.SendMsgMock.mutex.Lock()
	mmSendMsg.SendMsgMock.callArgs = append(mmSendMsg.SendMsgMock.callArgs, mm_params)
	mmSendMsg.SendMsgMock.mutex.Unlock()

	for _, e := range mmSendMsg.SendMsgMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMsg.SendMsgMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMsg.SendMsgMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMsg.SendMsgMock.defaultExpectation.params
		mm_got := ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgParams{m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMsg.t.Errorf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMsg.SendMsgMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMsg.t.Fatal("No results are set for the ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg")
		}
		return (*mm_results).err
	}
	if mmSendMsg.funcSendMsg != nil {
		return mmSendMsg.funcSendMsg(m)
	}
	mmSendMsg.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg. %v", m)
	return
}

// SendMsgAfterCounter returns a count of finished ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg invocations
func (mmSendMsg *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SendMsgAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMsg.afterSendMsgCounter)
}

// SendMsgBeforeCounter returns a count of ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg invocations
func (mmSendMsg *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SendMsgBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMsg.beforeSendMsgCounter)
}

// Calls returns a list of arguments used in each call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMsg *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsg) Calls() []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgParams {
	mmSendMsg.mutex.RLock()

	argCopy := make([]*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSendMsgParams, len(mmSendMsg.callArgs))
	copy(argCopy, mmSendMsg.callArgs)

	mmSendMsg.mutex.RUnlock()

	return argCopy
}

// MinimockSendMsgDone returns true if the count of the SendMsg invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockSendMsgDone() bool {
	for _, e := range m.SendMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMsg != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMsgInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockSendMsgInspect() {
	for _, e := range m.SendMsgMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMsgMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		if m.SendMsgMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg")
		} else {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg with params: %#v", *m.SendMsgMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMsg != nil && mm_atomic.LoadUint64(&m.afterSendMsgCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SendMsg")
	}
}

type mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeader struct {
	mock               *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	defaultExpectation *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderExpectation
	expectations       []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderExpectation

	callArgs []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderParams
	mutex    sync.RWMutex
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderExpectation specifies expectation struct of the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetHeader
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderExpectation struct {
	mock    *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	params  *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderParams
	results *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderResults
	Counter uint64
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderParams contains parameters of the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetHeader
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderParams struct {
	m1 metadata.MD
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderResults contains results of the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetHeader
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderResults struct {
	err error
}

// Expect sets up expected params for ImapConcentrator_SubscribeToChatNotificationsV1Server.SetHeader
func (mmSetHeader *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeader) Expect(m1 metadata.MD) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeader {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader mock is already set by Set")
	}

	if mmSetHeader.defaultExpectation == nil {
		mmSetHeader.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderExpectation{}
	}

	mmSetHeader.defaultExpectation.params = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderParams{m1}
	for _, e := range mmSetHeader.expectations {
		if minimock.Equal(e.params, mmSetHeader.defaultExpectation.params) {
			mmSetHeader.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetHeader.defaultExpectation.params)
		}
	}

	return mmSetHeader
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetHeader
func (mmSetHeader *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeader) Inspect(f func(m1 metadata.MD)) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeader {
	if mmSetHeader.mock.inspectFuncSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader")
	}

	mmSetHeader.mock.inspectFuncSetHeader = f

	return mmSetHeader
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToChatNotificationsV1Server.SetHeader
func (mmSetHeader *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeader) Return(err error) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader mock is already set by Set")
	}

	if mmSetHeader.defaultExpectation == nil {
		mmSetHeader.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderExpectation{mock: mmSetHeader.mock}
	}
	mmSetHeader.defaultExpectation.results = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderResults{err}
	return mmSetHeader.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetHeader method
func (mmSetHeader *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeader) Set(f func(m1 metadata.MD) (err error)) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmSetHeader.defaultExpectation != nil {
		mmSetHeader.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetHeader method")
	}

	if len(mmSetHeader.expectations) > 0 {
		mmSetHeader.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetHeader method")
	}

	mmSetHeader.mock.funcSetHeader = f
	return mmSetHeader.mock
}

// When sets expectation for the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetHeader which will trigger the result defined by the following
// Then helper
func (mmSetHeader *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeader) When(m1 metadata.MD) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderExpectation {
	if mmSetHeader.mock.funcSetHeader != nil {
		mmSetHeader.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader mock is already set by Set")
	}

	expectation := &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderExpectation{
		mock:   mmSetHeader.mock,
		params: &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderParams{m1},
	}
	mmSetHeader.expectations = append(mmSetHeader.expectations, expectation)
	return expectation
}

// Then sets up ImapConcentrator_SubscribeToChatNotificationsV1Server.SetHeader return parameters for the expectation previously defined by the When method
func (e *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderExpectation) Then(err error) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	e.results = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderResults{err}
	return e.mock
}

// SetHeader implements ImapConcentrator_SubscribeToChatNotificationsV1Server
func (mmSetHeader *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SetHeader(m1 metadata.MD) (err error) {
	mm_atomic.AddUint64(&mmSetHeader.beforeSetHeaderCounter, 1)
	defer mm_atomic.AddUint64(&mmSetHeader.afterSetHeaderCounter, 1)

	if mmSetHeader.inspectFuncSetHeader != nil {
		mmSetHeader.inspectFuncSetHeader(m1)
	}

	mm_params := &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderParams{m1}

	// Record call args
	mmSetHeader.SetHeaderMock.mutex.Lock()
	mmSetHeader.SetHeaderMock.callArgs = append(mmSetHeader.SetHeaderMock.callArgs, mm_params)
	mmSetHeader.SetHeaderMock.mutex.Unlock()

	for _, e := range mmSetHeader.SetHeaderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetHeader.SetHeaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetHeader.SetHeaderMock.defaultExpectation.Counter, 1)
		mm_want := mmSetHeader.SetHeaderMock.defaultExpectation.params
		mm_got := ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetHeader.t.Errorf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetHeader.SetHeaderMock.defaultExpectation.results
		if mm_results == nil {
			mmSetHeader.t.Fatal("No results are set for the ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader")
		}
		return (*mm_results).err
	}
	if mmSetHeader.funcSetHeader != nil {
		return mmSetHeader.funcSetHeader(m1)
	}
	mmSetHeader.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader. %v", m1)
	return
}

// SetHeaderAfterCounter returns a count of finished ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader invocations
func (mmSetHeader *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SetHeaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetHeader.afterSetHeaderCounter)
}

// SetHeaderBeforeCounter returns a count of ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader invocations
func (mmSetHeader *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SetHeaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetHeader.beforeSetHeaderCounter)
}

// Calls returns a list of arguments used in each call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetHeader *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeader) Calls() []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderParams {
	mmSetHeader.mutex.RLock()

	argCopy := make([]*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetHeaderParams, len(mmSetHeader.callArgs))
	copy(argCopy, mmSetHeader.callArgs)

	mmSetHeader.mutex.RUnlock()

	return argCopy
}

// MinimockSetHeaderDone returns true if the count of the SetHeader invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockSetHeaderDone() bool {
	for _, e := range m.SetHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetHeaderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetHeader != nil && mm_atomic.LoadUint64(&m.afterSetHeaderCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetHeaderInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockSetHeaderInspect() {
	for _, e := range m.SetHeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetHeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetHeaderCounter) < 1 {
		if m.SetHeaderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader")
		} else {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader with params: %#v", *m.SetHeaderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetHeader != nil && mm_atomic.LoadUint64(&m.afterSetHeaderCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetHeader")
	}
}

type mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailer struct {
	mock               *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	defaultExpectation *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerExpectation
	expectations       []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerExpectation

	callArgs []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerParams
	mutex    sync.RWMutex
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerExpectation specifies expectation struct of the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetTrailer
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerExpectation struct {
	mock   *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock
	params *ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerParams

	Counter uint64
}

// ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerParams contains parameters of the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetTrailer
type ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerParams struct {
	m1 metadata.MD
}

// Expect sets up expected params for ImapConcentrator_SubscribeToChatNotificationsV1Server.SetTrailer
func (mmSetTrailer *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailer) Expect(m1 metadata.MD) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailer {
	if mmSetTrailer.mock.funcSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetTrailer mock is already set by Set")
	}

	if mmSetTrailer.defaultExpectation == nil {
		mmSetTrailer.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerExpectation{}
	}

	mmSetTrailer.defaultExpectation.params = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerParams{m1}
	for _, e := range mmSetTrailer.expectations {
		if minimock.Equal(e.params, mmSetTrailer.defaultExpectation.params) {
			mmSetTrailer.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetTrailer.defaultExpectation.params)
		}
	}

	return mmSetTrailer
}

// Inspect accepts an inspector function that has same arguments as the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetTrailer
func (mmSetTrailer *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailer) Inspect(f func(m1 metadata.MD)) *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailer {
	if mmSetTrailer.mock.inspectFuncSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("Inspect function is already set for ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetTrailer")
	}

	mmSetTrailer.mock.inspectFuncSetTrailer = f

	return mmSetTrailer
}

// Return sets up results that will be returned by ImapConcentrator_SubscribeToChatNotificationsV1Server.SetTrailer
func (mmSetTrailer *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailer) Return() *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmSetTrailer.mock.funcSetTrailer != nil {
		mmSetTrailer.mock.t.Fatalf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetTrailer mock is already set by Set")
	}

	if mmSetTrailer.defaultExpectation == nil {
		mmSetTrailer.defaultExpectation = &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerExpectation{mock: mmSetTrailer.mock}
	}

	return mmSetTrailer.mock
}

//Set uses given function f to mock the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetTrailer method
func (mmSetTrailer *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailer) Set(f func(m1 metadata.MD)) *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock {
	if mmSetTrailer.defaultExpectation != nil {
		mmSetTrailer.mock.t.Fatalf("Default expectation is already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetTrailer method")
	}

	if len(mmSetTrailer.expectations) > 0 {
		mmSetTrailer.mock.t.Fatalf("Some expectations are already set for the ImapConcentrator_SubscribeToChatNotificationsV1Server.SetTrailer method")
	}

	mmSetTrailer.mock.funcSetTrailer = f
	return mmSetTrailer.mock
}

// SetTrailer implements ImapConcentrator_SubscribeToChatNotificationsV1Server
func (mmSetTrailer *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SetTrailer(m1 metadata.MD) {
	mm_atomic.AddUint64(&mmSetTrailer.beforeSetTrailerCounter, 1)
	defer mm_atomic.AddUint64(&mmSetTrailer.afterSetTrailerCounter, 1)

	if mmSetTrailer.inspectFuncSetTrailer != nil {
		mmSetTrailer.inspectFuncSetTrailer(m1)
	}

	mm_params := &ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerParams{m1}

	// Record call args
	mmSetTrailer.SetTrailerMock.mutex.Lock()
	mmSetTrailer.SetTrailerMock.callArgs = append(mmSetTrailer.SetTrailerMock.callArgs, mm_params)
	mmSetTrailer.SetTrailerMock.mutex.Unlock()

	for _, e := range mmSetTrailer.SetTrailerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSetTrailer.SetTrailerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetTrailer.SetTrailerMock.defaultExpectation.Counter, 1)
		mm_want := mmSetTrailer.SetTrailerMock.defaultExpectation.params
		mm_got := ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerParams{m1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetTrailer.t.Errorf("ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetTrailer got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSetTrailer.funcSetTrailer != nil {
		mmSetTrailer.funcSetTrailer(m1)
		return
	}
	mmSetTrailer.t.Fatalf("Unexpected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetTrailer. %v", m1)

}

// SetTrailerAfterCounter returns a count of finished ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetTrailer invocations
func (mmSetTrailer *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SetTrailerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTrailer.afterSetTrailerCounter)
}

// SetTrailerBeforeCounter returns a count of ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetTrailer invocations
func (mmSetTrailer *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) SetTrailerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetTrailer.beforeSetTrailerCounter)
}

// Calls returns a list of arguments used in each call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetTrailer.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetTrailer *mImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailer) Calls() []*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerParams {
	mmSetTrailer.mutex.RLock()

	argCopy := make([]*ImapConcentrator_SubscribeToChatNotificationsV1ServerMockSetTrailerParams, len(mmSetTrailer.callArgs))
	copy(argCopy, mmSetTrailer.callArgs)

	mmSetTrailer.mutex.RUnlock()

	return argCopy
}

// MinimockSetTrailerDone returns true if the count of the SetTrailer invocations corresponds
// the number of defined expectations
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockSetTrailerDone() bool {
	for _, e := range m.SetTrailerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTrailerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTrailerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTrailer != nil && mm_atomic.LoadUint64(&m.afterSetTrailerCounter) < 1 {
		return false
	}
	return true
}

// MinimockSetTrailerInspect logs each unmet expectation
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockSetTrailerInspect() {
	for _, e := range m.SetTrailerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetTrailer with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SetTrailerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSetTrailerCounter) < 1 {
		if m.SetTrailerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetTrailer")
		} else {
			m.t.Errorf("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetTrailer with params: %#v", *m.SetTrailerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetTrailer != nil && mm_atomic.LoadUint64(&m.afterSetTrailerCounter) < 1 {
		m.t.Error("Expected call to ImapConcentrator_SubscribeToChatNotificationsV1ServerMock.SetTrailer")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockContextInspect()

		m.MinimockRecvMsgInspect()

		m.MinimockSendInspect()

		m.MinimockSendHeaderInspect()

		m.MinimockSendMsgInspect()

		m.MinimockSetHeaderInspect()

		m.MinimockSetTrailerInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ImapConcentrator_SubscribeToChatNotificationsV1ServerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockContextDone() &&
		m.MinimockRecvMsgDone() &&
		m.MinimockSendDone() &&
		m.MinimockSendHeaderDone() &&
		m.MinimockSendMsgDone() &&
		m.MinimockSetHeaderDone() &&
		m.MinimockSetTrailerDone()
}
